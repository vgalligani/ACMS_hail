#------------------------------------------------------------------------------# These are re-analysis ? or forecasts? # (Plots of 0000 UTC 10 Nov model run valid )# 1200 UTC, 1500UTC and 1800UTC 10 November and 0000 UTC 11 November#oko que deberia ser 9*24+0)  # para 11-10-00:00 AND CLEAN CODE # todo: loop over times. plot synop domain y ponerle unidades! #------------------------------------------------------------------------------from netCDF4 import Datasetimport matplotlib.pyplot as pltimport numpy as np from matplotlib.cm import get_cmapimport matplotlib.colors as mcolorsimport colormaps_new as cmapsimport gcimport xarray as xrimport metpyfrom metpy.units import unitsimport psutilimport osfrom matplotlib.colors import LinearSegmentedColormapplt.matplotlib.rc('font', family='serif', size = 12)plt.rcParams['xtick.labelsize']=12plt.rcParams['ytick.labelsize']=12  #------------------------------------------------------------------------------#------------------------------------------------------------------------------# provinciasprov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')# carpetas con ERA5    oldERA5   ='/home/vito.galligani/datosmunin3/Get_ERA5/20181011_netcdf/'extraERA5 = '/relampago/datos/hernan.bechis/era5_surface/ERA5_sl_20181101.nc'# topografia fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'ds = Dataset(fn)topo_lat = ds.variables['lat'][:]topo_lon = ds.variables['lon'][:]topo_dat = ds.variables['Band1'][:]/1e3lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)#-- Get lat/lon grids for old ERA5ds = Dataset(oldERA5+'ERA5-20181110-20181111-sl.nc')lat = ds.variables['latitude'][:]lon = ds.variables['longitude'][:]lons_era5, lats_era5 = np.meshgrid(lon,lat)    # limites synop pero CURSO y compare era5slon_lim  = [-75,-50]lat_lim  = [-40,-20]figsize1 = 20figsize2 = 8figdir   = '/home/vito.galligani/datosmunin3/Work/Studies/HAILCASE_10112018/Plots_curso/era5_synop/'subplot = [1,1]synop = 1params_skip = 5#------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_zthickness(lons_era5, lats_era5, msl, u10, v10, z, validtime):             g         = 9.80665    #--- Plot MSLP (black), 10m winds (kts) and 1000-500 hpa thickness (shaded)        # 1) Convert geopotential to geopotential height (in meters)    z_1000 = z.sel(pressure_level=1000)    z_500 = z.sel(pressure_level=500)    z_1000 = z_1000[:,:] / g  # dims: time, level, lat, lon    z_500 = z_500[:,:] / g  # dims: time, level, lat, lon    thickness = z_500 - z_1000  # in meters    del z_1000, z_500    # Optionally: save or plot    title = 'MSLP (blue), 10-m wind (ms$^{-1}$), 1000-500 hPa thickness (shaded)'    #-------     # Define the color stops: blue -> yellow -> red    #colors = ['blue', 'yellow', 'red']    #cmap_name = 'blue_yellow_red'        #-------    # Total number of colors in colormap    n_total = 256    # Proportions for each segment    frac_blue = 7/11 #10    frac_red  = 4/11  #10    n_blue = int(n_total * frac_blue)    n_red = n_total - n_blue  # remainder    # Color arrays    colors_blue = plt.cm.BuPu_r(np.linspace(0.3, 0.8, n_blue))    colors_red = plt.cm.YlOrRd(np.linspace(0.0, 1.0, n_red))    # Combine    colors_combined = np.vstack((colors_blue, colors_red))    params_ccmap = mcolors.LinearSegmentedColormap.from_list('blue_red', colors_combined)        #-------     params_llevels = np.arange(940,1050,4)    cffield        = thickness    ####params_ccmap   = LinearSegmentedColormap.from_list(cmap_name, colors, N=256) #"RdBu_r"    params_clevels =  np.arange(5160, 5820+60, 60)  # every 60 m                fig, ax = plt.subplots(nrows=subplot[0], ncols=subplot[1], figsize=(figsize1,figsize2) )     # old ERA5    #validtime = f"{(told_index):02d}"     cf = ax.contourf(lons_era5, lats_era5, cffield, cmap=params_ccmap, levels=params_clevels, extend='both')    cbar = fig.colorbar(cf, ax=ax, orientation='vertical', label="Geopotential thickness between 1000 and 500 hPa")    cbar.set_ticks(np.arange(5160, 5820+60, 60))  # Sets ticks at every 2 units from -12 to +12    if synop == 0:        #- countour        mask = np.ones(lons_era5.shape).astype(bool)        if lon_lim:            mask = mask & (lons_era5>=lon_lim[0]) & (lons_era5<=lon_lim[1])        if lat_lim:            mask = mask & (lats_era5>=lat_lim[0]) & (lats_era5<=lat_lim[1])        xm = np.ma.masked_where(~mask , lons_era5)        ym = np.ma.masked_where(~mask , lats_era5)        zm = np.ma.masked_where(~mask , msl[:,:])        CS = ax.contour(xm, ym, zm/100, 10, colors="navy", levels=params_llevels, linewidths=1.2)        ax.clabel(CS, inline=True, fmt='%d',  fontsize=8)            elif synop==1:        #- countour        params_llevels = np.arange(940,1050,2)        label_levels   = np.arange(940, 1050, 4)  # label every 4 hPa        mask = np.ones(lons_era5.shape).astype(bool)        if lon_lim:            mask = mask & (lons_era5>=lon_lim[0]) & (lons_era5<=lon_lim[1])        if lat_lim:            mask = mask & (lats_era5>=lat_lim[0]) & (lats_era5<=lat_lim[1])        xm = np.ma.masked_where(~mask , lons_era5)        ym = np.ma.masked_where(~mask , lats_era5)        zm = np.ma.masked_where(~mask , msl[:,:])        CS = ax.contour(xm, ym, zm/100, colors="navy", levels=params_llevels, linewidths=1.2)        ax.clabel(CS, levels=label_levels, inline=True, fmt='%d',  inline_spacing=1, fontsize=10, use_clabeltext=False)                ax.set_xlim(lon_lim)     ax.set_ylim(lat_lim)      #- barbs    ax.barbs(lons_era5[::params_skip,::params_skip],                  lats_era5[::params_skip,::params_skip],                  u10[ ::params_skip, ::params_skip],                 v10[ ::params_skip, ::params_skip], length=5, linewidth=0.75, zorder=10)    ax.plot(prov[:,0],prov[:,1],color='k');         ax.set_title('ERA5 ('+validtime+':00 UTC)')    ax.set_xlabel('Longitude')        ax.set_ylabel('Latitude')        # supttitle:    plt.suptitle(title)        filename = 'compare_era5s_geopotDiff'+'_20181110_'+validtime+'00UTC'    fig.savefig(figdir+filename, dpi=300, transparent=False, bbox_inches='tight')       plt.close(fig)             return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_relativevorticity(lons_era5, lats_era5, uwind, vwind, z, validtime):     g         = 9.80665    # Optionally: save or plot    title = '500 hpa: geopotential ht (blue), wind (ms$^{-1}$), relative vorticity (shaded)'        z_500 = z.sel(pressure_level=500) / g  # dims: time, level, lat, lon    u500  = uwind.sel(pressure_level=500)    v500  = vwind.sel(pressure_level=500)            #---- from https://mariacharakarypidou.github.io/ClimateToolbox/Kinematics/RelativeVorticity.html    dx, dy = metpy.calc.lat_lon_grid_deltas(lons_era5, lats_era5)    rel_vorticity  = metpy.calc.vorticity(u500[:,:],  v500[:,:], dx=dx, dy=dy)    clevs = np.linspace(-12, 12, 13)  # e.g., every 1 unit step    #----     # Total number of colors in colormap    n_total = 256        # Proportions for each segment    frac_blue = 10/24 #10    frac_white = 4/24 #4    frac_red = 10/24  #10        # Number of colors per segment    n_blue = int(n_total * frac_blue)    n_white = int(n_total * frac_white)    n_red = n_total - n_blue - n_white  # remainder        # Color arrays    colors_blue = plt.cm.BuPu_r(np.linspace(0.3, 0.8, n_blue))    colors_white = np.ones((n_white, 4))  # white RGBA     colors_red = plt.cm.YlOrRd(np.linspace(0.0, 1.0, n_red))        # Combine    colors_combined = np.vstack((colors_blue, colors_white, colors_red))    params_ccmap = mcolors.LinearSegmentedColormap.from_list('blue_white_red', colors_combined)    print('ok')    #-------     params_llevels = np.arange(940,1050,4)     cffield        = rel_vorticity     #params_ccmap   = 'YlOrBr'    params_clevels =  np.arange(560, 600, 30)  # every 60 m            fig, ax = plt.subplots(nrows=subplot[0], ncols=subplot[1], figsize=(figsize1,figsize2) )     # old ERA5    #validtime = f"{(told_index):02d}"     cf = ax.contourf(lons_era5, lats_era5, cffield*1e5, clevs, cmap=params_ccmap, extend='both') #, levels=params_clevels, extend='both')    #cf = ax.contourf(lons_era5, lats_era5, cffield*1e-5 , colors=params_ccmap, extend='both') #, levels=params_clevels, extend='both')    cbar = fig.colorbar(cf, ax=ax, orientation='vertical', label="Relative vorticity [10$^{-5}$s${-1}$]")    cbar.set_ticks(np.arange(-12, 13, 2))  # Sets ticks at every 2 units from -12 to +12    if synop == 0:        #- countour        mask = np.ones(lons_era5.shape).astype(bool)        if lon_lim:            mask = mask & (lons_era5>=lon_lim[0]) & (lons_era5<=lon_lim[1])        if lat_lim:            mask = mask & (lats_era5>=lat_lim[0]) & (lats_era5<=lat_lim[1])        xm = np.ma.masked_where(~mask , lons_era5)        ym = np.ma.masked_where(~mask , lats_era5)        zm = np.ma.masked_where(~mask , z_500[:,:])        CS = ax.contour(xm, ym, zm, 10, colors="navy", linewidths=1.2) #levels=params_llevels,         ax.clabel(CS, inline=True, fmt='%d',  inline_spacing=1, fontsize=10, use_clabeltext=False)        elif synop==1:        #- countour        params_llevels = np.arange(5000,6800,30)         mask = np.ones(lons_era5.shape).astype(bool)        if lon_lim:            mask = mask & (lons_era5>=lon_lim[0]) & (lons_era5<=lon_lim[1])        if lat_lim:            mask = mask & (lats_era5>=lat_lim[0]) & (lats_era5<=lat_lim[1])        xm = np.ma.masked_where(~mask , lons_era5)        ym = np.ma.masked_where(~mask , lats_era5)        zm = np.ma.masked_where(~mask , z_500[:,:])        CS = ax.contour(lons_era5, lats_era5, z_500, levels=params_llevels, colors="navy", linewidths=1.2)        #CS = ax.contour(xm, ym, zm, levels=params_llevels, colors="navy", linewidths=1.2)        ax.clabel(CS, inline=True, fmt='%d', inline_spacing=1, fontsize=10, use_clabeltext=False)                   ax.set_xlim(lon_lim)     ax.set_ylim(lat_lim)      #- barbs    ax.barbs(lons_era5[::params_skip,::params_skip],                  lats_era5[::params_skip,::params_skip],                  u500[::params_skip, ::params_skip],                 v500[::params_skip, ::params_skip], length=5, linewidth=0.75, zorder=10)    ax.plot(prov[:,0],prov[:,1],color='k');         ax.set_title('ERA5 ('+validtime+':00 UTC)')    ax.set_xlabel('Longitude')        ax.set_ylabel('Latitude')            # supttitle:    plt.suptitle(title)        filename = 'compare_era5s_RelVorticity'+'_20181110_'+validtime+'00UTC'    fig.savefig(figdir+filename, dpi=300, transparent=False, bbox_inches='tight')         plt.close(fig)        print('ok?')    return    #------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_CAPE(lons, lats, lons_era5, lats_era5, mucape, u10, v10, u_1km, v_1km, validtime):     # Optionally: save or plot    title = '0-6km bulk wind difference (barbs), cape (shaded)'            shear_mag = np.sqrt((u_1km - u10)**2 + (v_1km - v10)**2)    shear_u = u_1km - u10    shear_v = v_1km - v10    print("lons:", lons_era5.shape)    print("lats:", lats_era5.shape)    print("shear_u:", shear_u.shape)    print("shear_v:", shear_v.shape)    #----     print('ok')    #-------     clevs   =[100,500,1000,1500,2000,2500,3000,3500,4000]    colors1 = plt.cm.YlOrRd(np.linspace(0.2, 0.65, 50))    colors2 = plt.cm.Reds(np.linspace(0.6, 1.0, 64))    colors3 = plt.cm.Purples(np.linspace(0.5, 0.9, 64))    colors = np.vstack((colors1,colors2,colors3))#, colors2, colors1))    cmap_cape= mcolors.LinearSegmentedColormap.from_list('my_colormap', colors)    cmap_cape.set_over((0.3,0,1))    cmap_cape.set_under((1,1,1))                #fig, ax = plt.subplots(nrows=subplot[0], ncols=subplot[1], figsize=(figsize1,figsize2) )     fig, ax = plt.subplots(nrows=subplot[0], ncols=subplot[1], figsize=(10,12) )     cf = ax.contourf(lons, lats, mucape, clevs, cmap=cmap_cape, extend='both') #, levels=params_clevels, extend='both')    cbar = fig.colorbar(cf, ax=ax, orientation='vertical', label="CAPE [J kg**-1]")    #cbar.set_ticks(np.arange(-12, 13, 2))  # Sets ticks at every 2 units from -12 to +12    #- barbs    ax.barbs(lons_era5[::params_skip,::params_skip],                  lats_era5[::params_skip,::params_skip],                  shear_u[::params_skip, ::params_skip],                 shear_v[::params_skip, ::params_skip], length=5, linewidth=0.75, zorder=10)        ax.set_xlim(lon_lim)     ax.set_ylim(lat_lim)      ax.plot(prov[:,0],prov[:,1],color='k');         ax.set_title('ERA5 ('+validtime+':00 UTC)')    ax.set_xlabel('Longitude')        ax.set_ylabel('Latitude')            # supttitle:    plt.suptitle(title)        filename = 'muCAPE'+'_20181110_'+validtime+'00UTC_resize'    fig.savefig(figdir+filename, dpi=300, transparent=False, bbox_inches='tight')         plt.close(fig)        print('ok?')    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def pressure_generator(ds: xr.Dataset, pressure_level: int, version: int) -> xr.Dataset:    if version == 0:         pressure_ds = xr.full_like(ds['z'], pressure_level).rename('PRES')    elif version == 1:         pressure_ds = xr.full_like(ds['Z'], pressure_level).rename('PRES')    pressure_ds.attrs['units'] = 'hPa' # adding units to make it work in the metpy function    pressure_ds.attrs['long_name'] = 'pressure'    ds['PRES'] = pressure_ds # adding the newly created array to the dataset as the PRES variable    ds = ds.metpy.parse_cf()        return ds#------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_eth(lons_era5, lats_era5, d2m, subset, validtime):         # Optionally: save or plot    title = '850 hpa: winds (ms$^{-1}$), theta_e (blue), moisture div. (shaded)'        z_850   = subset['z'].sel(pressure_level=850)    u850    = subset['u'].sel(pressure_level=850)    v850    = subset['v'].sel(pressure_level=850)    q850    = subset['q'].sel(pressure_level=850)    temp850 = subset['t'].sel(pressure_level=850)        theta_e   = metpy.calc.equivalent_potential_temperature(subset['PRES'][0,:,:],                                                             temp850[:,:], d2m[:,:])        #------------     # Multiply to get moisture flux components    uq = q850 * u850  # [kg/kg * m/s]    vq = q850 * v850  # [kg/kg * m/s]    # Estimate grid spacing (in meters)    # Note: assumes regular lat/lon grid    dx, dy = metpy.calc.lat_lon_grid_deltas(lons_era5, lats_era5)    # Compute divergence of the moisture flux    div_qv = metpy.calc.divergence(uq, vq, dx=dx, dy=dy)  # units: kg/kg/s    # Convert to g/kg/day    moist_div_gkg_day = div_qv * 1e3 * 86400 #'g/kg/day')    #-------     params_ccmap   = 'YlOrBr'    ticks = [-80, -70, -60, -50, -40, -30, -20, -15, -10, -5, -1, 0]        # Custom colormap: red → yellow → green → white    colors = ["red", "yellow", "green", "white"]    params_ccmap = mcolors.LinearSegmentedColormap.from_list("moist_div_cmap", colors, N=256)        params_clevels = [-80, -70, -60, -50, -40, -30, -20, -15, -10, -5, -1, 0]            fig, ax = plt.subplots(nrows=subplot[0], ncols=subplot[1], figsize=(figsize1,figsize2) )     # old ERA5    cf = ax.contourf(lons_era5, lats_era5, moist_div_gkg_day , cmap=params_ccmap, extend='both', levels=params_clevels)    cbar = fig.colorbar(cf, ax=ax, ticks=params_clevels, orientation='vertical', label="Moisture divergence (g/kg/day)")    #cbar.ax.set_yticklabels([str(t) for t in params_clevels])  # Optional, for custom format    if synop == 0:        #- countour        mask = np.ones(lons_era5.shape).astype(bool)        if lon_lim:            mask = mask & (lons_era5>=lon_lim[0]) & (lons_era5<=lon_lim[1])        if lat_lim:            mask = mask & (lats_era5>=lat_lim[0]) & (lats_era5<=lat_lim[1])        xm = np.ma.masked_where(~mask , lons_era5)        ym = np.ma.masked_where(~mask , lats_era5)        zm = np.ma.masked_where(~mask , theta_e)        #-         CS = ax.contour(xm, ym, zm, 10, colors="navy",  linewidths=1.2) #levels=params_llevels,        ax.clabel(CS, inline=True, fmt='%d',  fontsize=12)        elif synop == 1:        params_llevels = np.arange(200,400,10)         CS = ax.contour(lons_era5, lats_era5, theta_e, levels=params_llevels, colors="navy", linewidths=1.2) #levels=params_llevels,        ax.clabel(CS, inline=True, fmt='%d', inline_spacing=1, fontsize=10, use_clabeltext=False)         ax.set_xlim(lon_lim)     ax.set_ylim(lat_lim)      #- barbs    ax.barbs(lons_era5[::params_skip,::params_skip],                  lats_era5[::params_skip,::params_skip],                  u850[::params_skip, ::params_skip],                 v850[::params_skip, ::params_skip], length=5, linewidth=0.75, zorder=10)    ax.plot(prov[:,0],prov[:,1],color='k');         ax.set_title('ERA5 ('+validtime+':00 UTC)')    ax.set_xlabel('Longitude')        ax.set_ylabel('Latitude')        # supttitle:    plt.suptitle(title)        filename = 'compare_era5s_ethDivergence'+'_20181110_'+validtime+'00UTC'    fig.savefig(figdir+filename, dpi=300, transparent=False, bbox_inches='tight')                return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_oldera5(ds, tindex):        sel = ds.isel(valid_time=tindex)    t2m = sel['t2m'] - 273    sst = sel['sst']    d2m = sel['t2m'] - 273    msl = sel['msl'] # air_pressure_at_mean_sea_level    skt = sel['skt'] - 273    u10 = sel['u10']    v10 = sel['v10']    sp  = sel['sp']            return t2m, sst, d2m, msl, skt, u10, v10, sp        #------------------------------------------------------------------------------#------------------------------------------------------------------------------def calc_era5_mucape(p, T, Td):        cape_out = np.zeros((T.shape[1], T.shape[2]))    #cin = np.zeros((T.shape[1], T.shape[2]))    for i in range(T.shape[1]):        for j in range(T.shape[2]):            valid = np.isfinite(T[:,i,j]) & np.isfinite(Td[:,i,j])            if np.count_nonzero(valid) < 5:                cape = np.nan                 cin  = np.nan             else:                mu_p, mu_T, mu_Td, _ = metpy.calc.most_unstable_parcel(p* metpy.units.units.hPa, T[:,i,j], Td[:,i,j])                # compture parcel temperature                prof = metpy.calc.parcel_profile(p, T[0,i,j], Td[0,i,j])                cape, cin = metpy.calc.cape_cin(p, T[:,i,j], Td[:,i,j], prof)                cape_out[i,j] = cape.to('J/kg').magnitude                return cape_out#------------------------------------------------------------------------------#------------------------------------------------------------------------------def main_run_pl_plots(ds, dp, dp_, oldera_sl_time, extra_era5_time):        # extra_era5_time 9*4 + ii    titletime = f"{ (oldera_sl_time):02d}"     t2m, sst, d2m, msl, skt, u10, v10, sp =  get_oldera5(ds, oldera_sl_time)     #--- pressure variables have tdim == 48.     #ds = Dataset(oldERA5+'ERA5-20181110-20181111-pl.nc')    sel = dp.isel(valid_time=oldera_sl_time)    z     = sel['z']  #geopotential (m**2 s**-2)    uwind = sel['u']    vwind = sel['v']    temp  = sel['t']    pres  = sel['pressure_level']        # Ensure units    #temp = temp * metpy.units.units.kelvin    #    #Td = metpy.calc.dewpoint_from_relative_humidity(temp, sel['r']/100.)    #mucape = calc_era5_mucape(pres, temp, Td)    sel2 = dp_.isel(valid_time=extra_era5_time)    cape  = sel2['cape']    cin   = sel2['cin']    lat2   = sel2['latitude']    lon2   = sel2['longitude']            # keep only one time and make 850hPa pressure field    #subset = ds.isel(valid_time=0)  #----------------- time    #subset = pressure_generator(subset, 850, 0)    sel = pressure_generator(sel, 850, 0)        #gc.collect()    #plot_zthickness(lons_era5, lats_era5, msl, u10, v10, z, titletime)              #gc.collect()        #plot_relativevorticity(lons_era5, lats_era5, uwind, vwind, z, titletime)    #gc.collect()    #    u_500 = uwind.sel(pressure_level=500)    v_500 = vwind.sel(pressure_level=500)    u1000 = uwind.sel(pressure_level=1000)    v1000 = vwind.sel(pressure_level=1000)        plot_CAPE(lon2, lat2, lons_era5, lats_era5, cape, u1000, v1000, u_500, v_500, titletime)    gc.collect()        del d2m     ds  = ds.isel(valid_time=oldera_sl_time)    d2m = ds['t2m'].load()     plot_eth(lons_era5, lats_era5, d2m, sel, titletime)    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def print_memory_usage():    process = psutil.Process(os.getpid())    mem = process.memory_info().rss / 1024**2  # in MB    print(f"Memory used: {mem:.2f} MB")    #------------------------------------------------------------------------------#------------------------------------------------------------------------------def main_plots(ds, dp, dp_, time, ii):    #main_run_sfc_plots(ds, time, 9*24+time)    main_run_pl_plots(ds, dp, dp_, time, 9*4+ii)    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def main():    """Main driver function."""    # Example: loop through a few timesteps    with xr.open_dataset(oldERA5 + 'ERA5-20181110-20181111-sl.nc') as ds:        with xr.open_dataset(oldERA5+'ERA5-20181110-20181111-pl.nc') as dp: #            with xr.open_dataset(extraERA5) as dp_: #                counter_ii = 0                for t in [0, 6, 12, 18]: #[0, 12, 15, 23]:                    print(f"Processing time index: {t}")                    main_plots(ds, dp, dp_, t, counter_ii)                    counter_ii = counter_ii+1                                        #try:                    #    print_memory_usage()                    #    main_plots(ds, dp, dp_, t, counter_ii)                    #    print_memory_usage()                    #    counter_ii = counter_ii+1                    #except Exception as e:                    #    print(f"Failed at timestep {t}: {e}")                    #                     # finally:                    #    import gc                    #    gc.collect()                    # -------------------------# ENTRY POINT# -------------------------if __name__ == '__main__':    main()            #------------------------------------------------------------------------------# TODO:# - Correigir contornos     