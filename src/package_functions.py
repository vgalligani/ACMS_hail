import numpy as npfrom scipy.special import gammaimport wrffrom scipy import integrateimport copyfrom scipy.interpolate import interp2d#------------------------------------------------------------------------------def airdensity(p,t):     """ Function to calculate the air density by trivial    application of the ideal gas law    """    Re  = 287.04        rho = p / ( Re * t )           return rho#------------------------------------------------------------------------------def mixr2massconc(mixr,  pres, temp):    """ Function to calculate the mass cocentration    from mass mixing ratio assuming a mixture of an     atmospheric species and dry air. Output in kg/m3     """    Re  = 287.04        rho = airdensity( pres, temp )              massconc = rho * mixr                   return massconc#------------------------------------------------------------------------------def get_q_ints6(ncfile):        Re       = 6.3781e6        # ncfile1: WSM6    temp     = wrf.g_temp.get_tk(ncfile)    pressure = wrf.g_pressure.get_pressure(ncfile)    geopo_p  = wrf.g_geoht.get_height(ncfile) # geopotential height as Mean Sea Level (MSL    z_level  = Re*geopo_p/(Re-geopo_p)    qr = mixr2massconc( np.squeeze(ncfile.variables["QRAIN"][0,:,:,:]  ), pressure, temp )            qs = mixr2massconc( np.squeeze(ncfile.variables["QSNOW"][0,:,:,:]  ), pressure, temp )            qi = mixr2massconc( np.squeeze(ncfile.variables["QICE"][0,:,:,:]   ), pressure, temp )            qc = mixr2massconc( np.squeeze(ncfile.variables["QCLOUD"][0,:,:,:] ), pressure, temp )           qg = mixr2massconc( np.squeeze(ncfile.variables["QGRAUP"][0,:,:,:] ), pressure, temp )     qr_int = integrate.trapz(np.ma.array(qr, mask=np.isnan(qr)) , z_level, axis=0)    qs_int = integrate.trapz(np.ma.array(qr, mask=np.isnan(qs)) , z_level, axis=0)    qg_int = integrate.trapz(np.ma.array(qr, mask=np.isnan(qg)) , z_level, axis=0)    qi_int = integrate.trapz(np.ma.array(qi, mask=np.isnan(qi)) , z_level, axis=0)    qc_int = integrate.trapz(np.ma.array(qc, mask=np.isnan(qc)) , z_level, axis=0)        qr_int[qr_int<0.0001] = np.nan    qs_int[qs_int<0.0001] = np.nan    qg_int[qg_int<0.0001] = np.nan    qi_int[qi_int<0.0001] = np.nan    qc_int[qc_int<0.0001] = np.nan            return [qr, qs, qi, qc, qg, qr_int, qs_int, qi_int, qc_int, qg_int]#------------------------------------------------------------------------------def get_q_ints3(ncfile):        Re       = 6.3781e6        # ncfile1: WSM6    temp     = wrf.g_temp.get_tk(ncfile)    pressure = wrf.g_pressure.get_pressure(ncfile)    geopo_p  = wrf.g_geoht.get_height(ncfile) # geopotential height as Mean Sea Level (MSL)    z_level  = Re*geopo_p/(Re-geopo_p)    qr = mixr2massconc( np.squeeze(ncfile.variables["QRAIN"][0,:,:,:]  ), pressure, temp )            qi = mixr2massconc( np.squeeze(ncfile.variables["QICE"][0,:,:,:]   ), pressure, temp )            qc = mixr2massconc( np.squeeze(ncfile.variables["QCLOUD"][0,:,:,:] ), pressure, temp )           qir = mixr2massconc( np.squeeze(ncfile.variables["QIR"][0,:,:,:] ), pressure, temp )           qib = mixr2massconc( np.squeeze(ncfile.variables["QIB"][0,:,:,:] ), pressure, temp )           qil = mixr2massconc( np.squeeze(ncfile.variables["QIL"][0,:,:,:] ), pressure, temp )           qr_int = integrate.trapz(np.ma.array(qr, mask=np.isnan(qr)) , z_level, axis=0)    qi_int = integrate.trapz(np.ma.array(qi, mask=np.isnan(qi)) , z_level, axis=0)    qc_int = integrate.trapz(np.ma.array(qc, mask=np.isnan(qc)) , z_level, axis=0)        qr_int[qr_int<0.0001] = np.nan    qi_int[qi_int<0.0001] = np.nan    qc_int[qc_int<0.0001] = np.nan        return [qr, qi, qc, qr_int, qi_int, qc_int, qir, qib, qil]    #------------------------------------------------------------------------------def find_0( arr, target ):        # Find the indices and values closest to 273 in each column    diff =  np.abs(arr.data - target)    closest_indices = np.nanargmin(diff, axis=0)    ### closest_values = arr.data[closest_indices, np.arange(arr.shape[1])]    #closest_values = height_arr.data[closest_indices, np.arange(arr.shape[1])]    return closest_indices#------------------------------------------------------------------------------def find_00( arr, target, arrZ):        x_dim = arr.data.shape[1]    y_dim = arr.data.shape[2]        output_array_T = np.empty((x_dim, y_dim))    output_array_Z = np.empty((x_dim, y_dim))        # Iterate over each (x, y) position to find the closest value along the z-axis    for i in range(x_dim):        for j in range(y_dim):            # Find the index in z-dimension closest to the target value            closest_index = np.argmin(np.abs(arr.data[:, i, j] - target))            # Store the value at this index            output_array_T[i, j] = arr.data[closest_index, i, j]            output_array_Z[i, j] = arrZ.data[closest_index, i, j]    return output_array_T, output_array_Z#------------------------------------------------------------------------------# Helper function to convert HHMM to minutes since midnightdef hhmm_to_minutes(hhmm):    hours = int(hhmm[:2])    minutes = int(hhmm[2:])    return hours * 60 + minutes#------------------------------------------------------------------------------# Helper function to convert minutes since midnight back to HHMM formatdef minutes_to_hhmm(minutes):    hours = minutes // 60    mins = minutes % 60    return f"{hours:02d}{mins:02d}"#------------------------------------------------------------------------------def get_colmax(radar, field, gatefilter):        # Determine the lowest sweep (used for metadata and such)    minimum_sweep = np.min(radar.sweep_number["data"])        # loop over all measured sweeps    for sweep in sorted(radar.sweep_number["data"]):        # get start and stop index numbers        sweep_slice = radar.get_slice(sweep)        # grab radar data        z = radar.get_field(sweep, field)        z_dtype = z.dtype        # Use gatefilter        if gatefilter is not None:           mask_sweep = gatefilter.gate_excluded[sweep_slice, :]           z = np.ma.masked_array(z, mask_sweep)        # extract lat lons        lon = radar.gate_longitude["data"][sweep_slice, :]        lat = radar.gate_latitude["data"][sweep_slice, :]                   # get the range and time        ranges = radar.range["data"]        time = radar.time["data"]        # get azimuth        az = radar.azimuth["data"][sweep_slice]        # get order of azimuths        az_ids = np.argsort(az)        # reorder azs so they are in order        az = az[az_ids]        z = z[az_ids]        lon = lon[az_ids]        lat = lat[az_ids]        time = time[az_ids]                       # if the first sweep, store re-ordered lons/lats        if sweep == minimum_sweep:            azimuth_final = az            time_final = time            lon_0 = copy.deepcopy(lon)            lon_0[-1, :] = lon_0[0, :]            lat_0 = copy.deepcopy(lat)            lat_0[-1, :] = lat_0[0, :]            else:            # Configure the intperpolator            z_interpolator = interp2d(ranges, az, z, kind="linear")            # Apply the interpolation            z = z_interpolator(ranges, azimuth_final)                    # if first sweep, create new dim, otherwise concat them up        if sweep == minimum_sweep:            z_stack = copy.deepcopy(z[np.newaxis, :, :])        else:            z_stack = np.concatenate([z_stack, z[np.newaxis, :, :]])        # now that the stack is made, take max across vertical    out_compz = np.nanmax(z_stack.data, axis=0) #.astype(z_dtype)                return lon_0,lat_0,out_compz#------------------------------------------------------------------------------# Helper function to convert HHMM to minutes since midnightdef hhmm_to_minutes(hhmm):    hours = int(hhmm[:2])    minutes = int(hhmm[2:])    return hours * 60 + minutes#------------------------------------------------------------------------------def maxHailSize(nit, lam, mu, pres, temp):     # !--------------------------------------------------------------------------    # ! Computes the maximum hail size by estimating the maximum size that is    # ! physically observable (and not just a numerical artifact of the complete    # ! gamma size distribution).    # !    # ! Follows the method described in Milbrandt and Yau (2006a).    # !    # !--------------------------------------------------------------------------    # ! Arguments:    #  real, intent(in) :: rho        ! air density   [kg m-3]    #  real, intent(in) :: nit        ! total num and total number mixing ratio    #  real, intent(in) :: rhofaci    ! air density correction factor for ice fall speed    #  real, intent(in) :: lam,mu     ! PSD slope and shape parameters        # ! Local variables:    #  real, parameter  :: dD       = 1.e-3    ! diameter bin width [m]    #  real, parameter  :: Dmax_psd = 150.e-3  ! maximum diameter in PSD to compute integral  [m]    #  real, parameter  :: Ncrit    = 5.e-4    ! threshold physically observable number concentration [# m-3]    #  real, parameter  :: Rcrit    = 1.e-3    ! threshold physically observable number flux          [# m-2 s-1]    #  real, parameter  :: ch       = 206.89   ! coefficient in V-D fall speed relation for hail (from MY2006a)    #  real, parameter  :: dh       = 0.6384   ! exponent in V-D fall speed relation for hail (from MY2006a)    #  double precision :: n0                  ! shape parameter in gamma distribution    #  real             :: Di                  ! diameter  [m]    #  real             :: N_tot               ! total number concentration  [# m-3]    #  real             :: N_tail              ! number conc. from Di to infinity; i.e. trial for Nh*{D*} in MY2006a [# m-3]    #  real             :: R_tail              ! number flux of large hail; i.e. trial for Rh*{D*} (corrected from MY2006a [# m-2 s-1]    #  real             :: V_h                 ! fall speed of hail of size D     [m s-1]    #  integer          :: nd                  ! maximum number of size bins for integral    #  integer          :: i                   ! index for integration        # !-----------------------------------------------------------------------    # note that rhofaci = (rhrosui*inv_rho)**0.54    rd     = 287.15    rhosui = 60000/(rd*253.15)    # calculate some time-varying atmospheric variables    rho     = pres/(rd*temp)   # dry air density     inv_rho = 1/rho            # inverse    rhofaci =  (rhosui*inv_rho)**0.54        # !-----------------------------------------------------------------------        Dmax_psd = 150e-3  # maximum diameter in PSD to compute integral  [m]    dD       = 1e-3    # diameter bin width [m]    ch       = 206.89  # coefficient in V-D fall speed relation for hail (from MY2006a)    Dh       = 0.6384  # exponent in V-D fall speed relation for hail (from MY2006a)    Rcrit    = 1e-3    # threshold physically observable number flux          [# m-2 s-1]                                                                                    maxHailSize = 0    nd  = int(Dmax_psd/dD)    n0  = nit*lam**(mu+1.)/gamma(mu+1.)    #-- method 1, based on Rh*crit:    R_tail   = 0    for i in range(nd, 0, -1):          Di  = i*dD        V_h = rhofaci*(ch*Di**Dh)        R_tail = R_tail + V_h*n0*Di**mu*np.exp(-lam*Di)*dD        if (R_tail>Rcrit):            maxHailSize = Di                        return maxHailSize                  