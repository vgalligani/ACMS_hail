import Tools2Plot as T2Pimport seaborn as sns import numpy as npimport xarray as xrfrom config import config_foldersimport sysimport matplotlib.pyplot as pltimport netCDF4 as ncimport matplotlib.gridspec as gridspecfrom Tools2RunRTTOV import read_wrffrom matplotlib.patches import Polygonfrom matplotlib.collections import PatchCollectionfrom netCDF4 import Datasetfrom Tools2RunRTTOV import filter_pixels_monotonicfrom Tools2Plot import GMI_colormapplt.matplotlib.rc('font', family='serif', size = 16)plt.rcParams['xtick.labelsize']=16plt.rcParams['ytick.labelsize']=16  #------------------------------------------------------------------------------def get_edges_2d(center_lat, center_lon):    """    Computes the grid edges for 2D lat/lon arrays for use with pcolormesh.    """    ny, nx = center_lat.shape    # Extend arrays by 1 row/column to hold edges    lat_edges = np.zeros((ny + 1, nx + 1))    lon_edges = np.zeros((ny + 1, nx + 1))    # Interior points: average 4 surrounding center points    lat_edges[1:-1, 1:-1] = 0.25 * (center_lat[:-1, :-1] + center_lat[1:, :-1] +                                    center_lat[:-1, 1:] + center_lat[1:, 1:])    lon_edges[1:-1, 1:-1] = 0.25 * (center_lon[:-1, :-1] + center_lon[1:, :-1] +                                    center_lon[:-1, 1:] + center_lon[1:, 1:])    # Edge rows and columns — extrapolate    lat_edges[0, 1:-1] = 2 * center_lat[0, :-1] - lat_edges[1, 1:-1]    lat_edges[-1, 1:-1] = 2 * center_lat[-1, :-1] - lat_edges[-2, 1:-1]    lat_edges[1:-1, 0] = 2 * center_lat[:-1, 0] - lat_edges[1:-1, 1]    lat_edges[1:-1, -1] = 2 * center_lat[:-1, -1] - lat_edges[1:-1, -2]    lon_edges[0, 1:-1] = 2 * center_lon[0, :-1] - lon_edges[1, 1:-1]    lon_edges[-1, 1:-1] = 2 * center_lon[-1, :-1] - lon_edges[-2, 1:-1]    lon_edges[1:-1, 0] = 2 * center_lon[:-1, 0] - lon_edges[1:-1, 1]    lon_edges[1:-1, -1] = 2 * center_lon[:-1, -1] - lon_edges[1:-1, -2]    # Corners — extrapolate from adjacent values    lat_edges[0, 0] = 2 * center_lat[0, 0] - lat_edges[1, 1]    lat_edges[0, -1] = 2 * center_lat[0, -1] - lat_edges[1, -2]    lat_edges[-1, 0] = 2 * center_lat[-1, 0] - lat_edges[-2, 1]    lat_edges[-1, -1] = 2 * center_lat[-1, -1] - lat_edges[-2, -2]    lon_edges[0, 0] = 2 * center_lon[0, 0] - lon_edges[1, 1]    lon_edges[0, -1] = 2 * center_lon[0, -1] - lon_edges[1, -2]    lon_edges[-1, 0] = 2 * center_lon[-1, 0] - lon_edges[-2, 1]    lon_edges[-1, -1] = 2 * center_lon[-1, -1] - lon_edges[-2, -2]    return lat_edges, lon_edges#------------------------------------------------------------------------------def make_simBTvar_maps(lon,lat,VAR,vminn,vmaxx,colorbarlabel,title):            cmaps = T2P.GMI_colormap()             # Some basic info for paths      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    plotpath, folders = config_folders(server)        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        # Channel selections    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    channels_indexplot = [0,1,3,4]        y_ticks = np.arange(-34, -31.9, 0.5)  # -31.9 to include -32        fig = plt.figure(figsize=(20, 7))    gs = gridspec.GridSpec(1, 5, width_ratios=[1, 1, 1, 1, 0.05], wspace=0.3)    axes = [fig.add_subplot(gs[i]) for i in range(4)]    cax = fig.add_subplot(gs[4])  # dedicated axis for colorbar        for index, i in enumerate(channels_indexplot):        #pcm = axes[index].pcolormesh(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data[i,:,:],          #                                cmap=cmaps['turbo_r'], shading='auto', vmin=tbmin_, vmax=300)        pcm = axes[index].pcolormesh(lon,lat,VAR[i,:,:],                                          cmap=cmaps['turbo_r'], shading='auto', vmin=vminn, vmax=vmaxx)        axes[index].set_xlim([-64,-61])        axes[index].set_ylim([-34,-32])         axes[index].set_yticks(y_ticks)        axes[index].set_yticklabels([str(y) for y in y_ticks])        axes[index].plot(prov[:,0],prov[:,1],color='w');         axes[index].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)        axes[index].set_title(ichan_title[index]+' GHz')    axes[0].set_xlabel('Latitude')    axes[0].set_ylabel('Longitude')    cbar = fig.colorbar(pcm, cax=cax, orientation='vertical', label=colorbarlabel)    plt.suptitle( f'{title}', fontweight='bold')    #fig.savefig(plotpath+'/poster/'+f'{experiment}_allfootprintCs_maps_zoomout.png', dpi=300,transparent=False)           return fig#------------------------------------------------------------------------------def make_BTvar_maps(lon,lat,VAR,vminn,vmaxx,colorbarlabel,title):            cmaps = T2P.GMI_colormap()             # Some basic info for paths      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    plotpath, folders = config_folders(server)        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        # Channel selections    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    channels_indexplot = [0,1,3,4]        fig = plt.figure(figsize=(20, 7))    gs = gridspec.GridSpec(1, 5, width_ratios=[1, 1, 1, 1, 0.05], wspace=0.2)    axes = [fig.add_subplot(gs[i]) for i in range(4)]    cax = fig.add_subplot(gs[4])  # dedicated axis for colorbar        for index, i in enumerate(channels_indexplot):        #pcm = axes[index].pcolormesh(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data[i,:,:],          #                                cmap=cmaps['turbo_r'], shading='auto', vmin=tbmin_, vmax=300)        pcm = axes[index].pcolormesh(lon,lat,VAR[i,:,:],                                          cmap=cmaps['turbo_r'], shading='auto', vmin=vminn, vmax=vmaxx)        axes[index].set_xlim([-66,-58])        axes[index].set_ylim([-36,-31])            axes[index].plot(prov[:,0],prov[:,1],color='w');         axes[index].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)        axes[index].set_title('MHS '+title+' ('+ichan_title[index]+' GHz)')    axes[0].set_xlabel('Latitude')    axes[0].set_ylabel('Longitude')    cbar = fig.colorbar(pcm, cax=cax, orientation='vertical', label=colorbarlabel)    #plt.suptitle( f'{experiment}', fontweight='bold')    #fig.savefig(plotpath+'/poster/'+f'{experiment}_allfootprintCs_maps_zoomout.png', dpi=300,transparent=False)           return fig#------------------------------------------------------------------------------def make_IWP_maps(lon, lat, VAR1, VAR2, VAR1q, VAR2q, alt, vminn, vmaxx, colorbarlabel):            cmaps = T2P.GMI_colormap()             # Some basic info for paths      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    plotpath, folders = config_folders(server)        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)            fig = plt.figure(figsize=(12,6))    gs = gridspec.GridSpec(4, 3,                           width_ratios=[1, 0.05, 2],   # col 0: square, col 2: wide, col 1: spacing                           height_ratios=[1, 0.05, 1, 0.05], wspace=0.27, hspace=0.4)     # Square map plots (ax1, ax3) — taller    ax1 = fig.add_subplot(gs[0, 0])    ax3 = fig.add_subplot(gs[2, 0])    # Rectangular transect plots (ax2, ax4) — wider and shorter    ax2 = fig.add_subplot(gs[0, 2])    ax4 = fig.add_subplot(gs[2, 2])            pcm = ax1.pcolormesh(lon,lat,VAR1, cmap='viridis', shading='auto', vmin=vminn, vmax=vmaxx)    cbar = plt.colorbar(pcm, ax=ax1, orientation='vertical', label=r'[kg/m$^2$]')    pcm = ax3.pcolormesh(lon,lat,VAR2, cmap='viridis', shading='auto', vmin=vminn, vmax=vmaxx)    cbar = plt.colorbar(pcm, ax=ax3, orientation='vertical', label=r'[kg/m$^2$]')    for ax in ([ax1,ax3]):         ax.set_xlim([-66,-60])        ax.set_ylim([-34,-31])            ax.plot(prov[:,0],prov[:,1],color='r');         ax.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    ax1.set_title(r'WRF snow iwc')    ax3.set_title(r'WRF grau iwc')    ax3.set_xlabel('Longitude')    ax3.set_ylabel('Latitude')    #cbar = fig.colorbar(pcm, cax=cax, orientation='vertical', label=colorbarlabel)    #plt.suptitle( f'{experiment}', fontweight='bold')        # add transect lines    ax1.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    ax3.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)            #, WRFvars['wrf_lat'], WRFvars['WRF_intqs'], WRFvars['WRF_intqg'], 0, 20, '')    # Example    target_lat = -32.8         # Convertí el xarray a numpy (por si no lo está)    lat_vals = WRFvars['wrf_lat'].values    lat_diff = np.abs(lat_vals - target_lat)    i_lat, i_lon = np.unravel_index(np.argmin(lat_diff), lat_diff.shape)        transect_VAR1   = VAR1q[:, i_lat, :]   # shape: (nlev, 1099)    transect_VAR2   = VAR2q[:, i_lat, :]   # shape: (nlev, 1099)    transect_lons   = lon.values[i_lat, :]  # shape: (1099,)    transect_height = alt[:,i_lat,:]        transect_height_filled = np.nan_to_num(transect_height, nan=-999)    pcm1 = ax2.pcolormesh(transect_lons, transect_height_filled/1e3, transect_VAR1, cmap='viridis', vmin=0, vmax=0.003)    pcm2 = ax4.pcolormesh(transect_lons, transect_height_filled/1e3, transect_VAR2, cmap='viridis', vmin=0, vmax=0.003)    cbar = plt.colorbar(pcm1, ax=ax2, orientation='vertical', label=r'[kg/m$^3$]')    cbar = plt.colorbar(pcm2, ax=ax4, orientation='vertical', label=r'[kg/m$^3$]')    ax2.set_title(r'WRF snow iwc')    ax4.set_title(r'WRF grau iwc')        for ax in ([ax2,ax4]):         ax.set_xlim([-64,-62])        ax.set_ylim([0,20])            ax4.set_xlabel('Longitude')    ax4.set_ylabel('Height [km]')              return fig#------------------------------------------------------------------------------def footprint_WRF_maps(d_cs, A):        cmaps = T2P.GMI_colormap()             # Some basic info for paths          if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        ii = 390    ij = 550    ji = 100    jj = 419        lat_edges, lon_edges = get_edges_2d(d_cs['MHS_lat'],d_cs['MHS_lon'])  # your 2D lat/lon centers    ny, nx = d_cs['MHS_lat'].shape  # number of grid cells    patches = []    for j in range(ny):        for i in range(nx):            # Define corners of the cell            corners = [                (lon_edges[j, i],     lat_edges[j, i]),                (lon_edges[j, i+1],   lat_edges[j, i+1]),                (lon_edges[j+1, i+1], lat_edges[j+1, i+1]),                (lon_edges[j+1, i],   lat_edges[j+1, i])            ]            poly = Polygon(corners, closed=True)            patches.append(poly)                pc = PatchCollection(patches, facecolor='none', edgecolor='red', linewidths=0.5)    fig, axes = plt.subplots(nrows=1, ncols=2, constrained_layout=True,figsize=[16,8])    pcm = axes[0].pcolormesh(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto')    cbar = plt.colorbar(pcm, ax=axes[0], orientation='vertical', label='BT [K]')    pcm = axes[1].pcolormesh(A['XLONG'][ii:ij,ji:jj], A['XLAT'][ii:ij,ji:jj], np.sum(A['swc'],0)[ii:ij,ji:jj], cmap='viridis', shading='auto')     cbar = plt.colorbar(pcm, ax=axes[1], orientation='vertical', label=r'WRF snow [kg/m^2]')    axes[1].add_collection(pc)    axes[0].plot(prov[:,0],prov[:,1],color='r');    axes[1].plot(prov[:,0],prov[:,1],color='r');    for index in range(2):        axes[index].set_xlim([-66,-60])        axes[index].set_ylim([-34,-31.5])       axes[0].set_xlabel('Latitude')    axes[0].set_ylabel('Longitude')    axes[0].set_title(r'MHS 89 GHz')    axes[1].set_title(r'SNOW [kg/m$^2$]')        return fig#------------------------------------------------------------------------------def get_arrays_liu_grausp(experiment, processedFolder, rttov_approach):         # define the experiments    # experiment = '' for 2dummy snow profiles, wrf orig    # experiment = '_halfgrau'             tb_as      = []     tb_as_gaus = []        if 'sieron' in rttov_approach:        for isnow in range(11):            expname = 'liusnow'+str(isnow)+'_grausp_aggregatesliu'+str(isnow)+experiment            d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')            var      = d_as['rttov_as'].values            var_gaus = d_as['rttov_as_Gaussianantennasigma_'].values            tb_as.append(var)            tb_as_gaus.append( var_gaus )            d_as.close()        tb_as_gaus = np.array(tb_as_gaus)               tb_as      = np.array(tb_as)                   elif 'iwcrescaling' in rttov_approach:         for isnow in range(11):            expname = 'liusnow'+str(isnow)+'_grausp'+experiment            d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_iwcrescaling_allsky_'+expname+'.nc')            var      = d_as['rttov_as'].values            var_gaus = d_as['rttov_as_Gaussianantennasigma_'].values            tb_as.append(var)            tb_as_gaus.append( var_gaus )            d_as.close()        tb_as_gaus = np.array(tb_as_gaus)               tb_as      = np.array(tb_as)                   elif 'eqMass' in rttov_approach:         for isnow in range(11):            expname = 'liusnow'+str(isnow)+'_grausp'+experiment            d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_eqmass_allsky_'+expname+'.nc')            var      = d_as['rttov_as'].values            var_gaus = d_as['rttov_as_Gaussianantennasigma_'].values            tb_as.append(var)            tb_as_gaus.append( var_gaus )            d_as.close()        tb_as_gaus = np.array(tb_as_gaus)               tb_as      = np.array(tb_as)                                   return tb_as, tb_as_gaus#------------------------------------------------------------------------------def get_arrays_liuliu(experiment, processedFolder, rttov_approach):             tb_as      = []     tb_as_gaus = []        if 'sieron' in rttov_approach:        for isnow in range(11):            rowi1 = []            rowi2 = []            for igrau in [2, 5, 8, 9, 10]:                expname = 'liusnow'+str(isnow)+'liugrau'+str(igrau)+experiment                d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')                var      = d_as['rttov_as'].values                var_gaus = d_as['rttov_as_Gaussianantennasigma_'].values                rowi1.append(var)                rowi2.append(var_gaus)                        tb_as.append(rowi1)            tb_as_gaus.append(rowi2)            d_as.close()        tb_as_gaus = np.array(tb_as_gaus)               tb_as      = np.array(tb_as)                elif 'iwcrescaling' in rttov_approach:         for isnow in range(11):            rowi1 = []            rowi2 = []            for igrau in [2, 5, 8, 9, 10]:                expname = 'liusnow'+str(isnow)+'_liugrau'+str(igrau)+experiment                d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_iwcrescaling_allsky_'+expname+'.nc')                var      = d_as['rttov_as'].values                var_gaus = d_as['rttov_as_Gaussianantennasigma_'].values                rowi1.append(var)                rowi2.append(var_gaus)                        tb_as.append(rowi1)            tb_as_gaus.append(rowi2)            d_as.close()        tb_as_gaus = np.array(tb_as_gaus)               tb_as      = np.array(tb_as)           elif 'eqMass' in rttov_approach:         for isnow in range(11):            rowi1 = []            rowi2 = []            for igrau in [2, 5, 8, 9, 10]:                expname = 'liusnow'+str(isnow)+'_liugrau'+str(igrau)+experiment                d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_eqmass_allsky_'+expname+'.nc')                var      = d_as['rttov_as'].values                var_gaus = d_as['rttov_as_Gaussianantennasigma_'].values                rowi1.append(var)                rowi2.append(var_gaus)                        tb_as.append(rowi1)            tb_as_gaus.append(rowi2)            d_as.close()        tb_as_gaus = np.array(tb_as_gaus)               tb_as      = np.array(tb_as)                          return tb_as, tb_as_gaus#------------------------------------------------------------------------------def make_hists_liugrausp(d_cs, rttov_as_exp, title, binreso):                 # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          isspname = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']            # all_shades = []    # for base in base_colors:    #     shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)    #     all_shades.append(shades)    #------------------------------------------------------    #---- All in one figure     fig, axes = plt.subplots(nrows=2, ncols=2, constrained_layout=True,figsize=[8,8])     axes = axes.flatten()    for index, i in enumerate(chan_indx):        varobs =  d_cs['MHs_domain_obs'].data[i,:,:]        varobs = varobs.flatten()                for isnow in range(11):            axes[index].plot([],[],color=base_colors[isnow], label=f'{isspname[isnow]}')        axes[index].plot([],[],color='k', label='Obs.')                            for isnow in range(11):            var  = rttov_as_exp[isnow,i,:,:].flatten()             counts, bin_edges = np.histogram(var, bins=np.arange(10,300,binreso),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=1.2, linestyle='-', color=base_colors[isnow])        axes[index].set_title(ichan_title[index]+' GHz')        axes[index].set_xlim([20,310])        #axes[index].set_ylim([1e-4,0.1])                counts, _ = np.histogram(varobs, bins=np.arange(10,300,binreso), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='k')        axes[index-1].set_ylabel('Count')           handles, labels = axes[0].get_legend_handles_labels()    axes[2].set_xlabel('BT [K]')    axes[3].set_xlabel('BT [K]')    fig.legend(handles, labels, ncol=3, loc='lower right', bbox_to_anchor=(0.95,-0.2))               fig.suptitle(title, fontweight='bold', fontsize=14)    plt.close()         return fig#------------------------------------------------------------------------------def make_hists_liuliu_grausp_1fig_perigrau(d_cs, rttov_as_exp, rttov_as_grausp, title, rttov_approach, binreso):                 # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          isspname = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']            grau_dda = [2,5,8,9,10]    grau_combinations = [isspname[2],isspname[5],isspname[8],isspname[9],isspname[10] ]        #------------------------------------------------------    for igrau, index_grau in enumerate(grau_dda):        #---- All in one figure         fig, axes = plt.subplots(nrows=2, ncols=2, constrained_layout=True,figsize=[8,8])         axes = axes.flatten()        for index, i in enumerate(chan_indx):            varobs =  d_cs['MHs_domain_obs'].data[i,:,:]            varobs = varobs.flatten()                    for isnow in range(11):                axes[index].plot([],[],color=base_colors[isnow], label=f'{isspname[isnow]}')            axes[index].plot([],[],color='k', label='Obs.')                        axes[index].plot([],[],color='gray', label='soft sphere')                                    varobs =  d_cs['MHs_domain_obs'].data[i,:,:]            varobs = varobs.flatten()                    for isnow in range(11):                var  = rttov_as_exp[isnow,igrau,i,:,:].flatten()                 counts, bin_edges = np.histogram(var, bins=np.arange(10,300,binreso),density=True)                bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2                axes[index].semilogy(bin_centers, counts, linewidth=1.2, linestyle='-', color=base_colors[isnow])                            counts, _ = np.histogram(varobs, bins=np.arange(10,300,binreso), density=True)            axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='k')                        #grausp            var  = rttov_as_grausp[isnow,i,:,:].flatten()             counts, bin_edges = np.histogram(var, bins=np.arange(10,300,binreso),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=1.2, linestyle='-', color='gray')                        axes[index-1].set_ylabel('Count')                        axes[index].set_title(ichan_title[index]+' GHz')            axes[index].set_xlim([20,310])                        handles, labels = axes[0].get_legend_handles_labels()            axes[2].set_xlabel('BT [K]')            axes[3].set_xlabel('BT [K]')            fig.legend(handles, labels, ncol=3, loc='lower right', bbox_to_anchor=(0.95,-0.3), title='SNOW combination')                   fig.suptitle(title+f', SNOW: {isspname[isnow]}', fontweight='bold', fontsize=14)            fig.savefig(plotpath+f'/histograms/{rttov_approach}/loghist_rttovas_{title}_gliu{str(igrau)}combinations_grausp.png', dpi=300,transparent=False, bbox_inches='tight')            plt.close()        return#------------------------------------------------------------------------------def make_hists_liuliu_grausp_1fig_pershape(d_cs, rttov_as_exp, rttov_as_grausp, title, rttov_approach, binreso):                 # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          isspname = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']            grau_dda = [2,5,8,9,10]    grau_combinations = [isspname[2],isspname[5],isspname[8],isspname[9],isspname[10] ]        #------------------------------------------------------    for isnow in range(11):         #---- All in one figure         fig, axes = plt.subplots(nrows=2, ncols=2, constrained_layout=True,figsize=[8,8])         axes = axes.flatten()        for index, i in enumerate(chan_indx):            varobs =  d_cs['MHs_domain_obs'].data[i,:,:]            varobs = varobs.flatten()                    for igrau, index_grau in enumerate(grau_dda):                axes[index].plot([],[],color=base_colors[igrau], label=f'{grau_combinations[igrau]}')            axes[index].plot([],[],color='k', label='Obs.')                        axes[index].plot([],[],color='gray', label='soft sphere')                                    varobs =  d_cs['MHs_domain_obs'].data[i,:,:]            varobs = varobs.flatten()                    for igrau, index_grau in enumerate(grau_dda):                var  = rttov_as_exp[isnow,igrau,i,:,:].flatten()                 counts, bin_edges = np.histogram(var, bins=np.arange(10,300,binreso),density=True)                bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2                axes[index].semilogy(bin_centers, counts, linewidth=1.2, linestyle='-', color=base_colors[igrau])                            counts, _ = np.histogram(varobs, bins=np.arange(10,300,binreso), density=True)            axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='k')                        #grausp            var  = rttov_as_grausp[isnow,i,:,:].flatten()             counts, bin_edges = np.histogram(var, bins=np.arange(10,300,binreso),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=1.2, linestyle='-', color='gray')                        axes[index-1].set_ylabel('Count')                        axes[index].set_title(ichan_title[index]+' GHz')            axes[index].set_xlim([20,310])                        handles, labels = axes[0].get_legend_handles_labels()            axes[2].set_xlabel('BT [K]')            axes[3].set_xlabel('BT [K]')            fig.legend(handles, labels, ncol=3, loc='lower right', bbox_to_anchor=(0.95,-0.2), title='GRAU combination')                   fig.suptitle(title+f', SNOW: {isspname[isnow]}', fontweight='bold', fontsize=14)            fig.savefig(plotpath+f'/histograms/{rttov_approach}/loghist_rttovas_{title}_sliu{str(isnow)}combinations_grausp.png', dpi=300,transparent=False, bbox_inches='tight')            plt.close()        return#------------------------------------------------------------------------------# Plot selection of graupel combinations for snow block 6-b sector and dendrite def make_hists_4oral(d_cs, rttov_as_exp, rttov_as_grausp, title, rttov_approach, binreso):                 # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '190.311']    chan_indx   = [0,1,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          isspname = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']            grau_dda = [2,5,8,9,10]    grau_combinations = [isspname[2],isspname[5],isspname[8],isspname[9],isspname[10] ]            lineline=['-','--','-.']    #------------------------------------------------------    if 'sieron' in rttov_approach:        title = 'M(D) Sieron et al. (2018) approach'    if 'iwc' in rttov_approach:        title = 'iwc rescaling approach (rttov default)'    if 'eqMass' in rttov_approach:        title = 'eqMass approach'    #------------------------------------------------------    #---- All in one figure     fig, axes = plt.subplots(nrows=1, ncols=3, constrained_layout=True,figsize=[16,4])     axes = axes.flatten()        # legends        for igrau, index_grau in enumerate(grau_dda):        axes[0].plot([],[],color=base_colors[igrau], label=f'{grau_combinations[igrau]}')    axes[0].plot([],[],color='gray', label='soft sphere')        axes[0].plot([],[],color='k', label='Obs.')                axes[1].plot([],[], linewidth=1.2, linestyle='-', color='k', label='6b ros.')    axes[1].plot([],[], linewidth=1.2, linestyle='--', color='k', label='Sector')    #axes[1].plot([],[], linewidth=1.2, linestyle='-.', color='k', label='Dendrite')            for sindex, isnow in enumerate(range(8,10)):         for index, i in enumerate(chan_indx):            varobs =  d_cs['MHs_domain_obs'].data[i,:,:]            varobs = varobs.flatten()                    for igrau, index_grau in enumerate(grau_dda):                var  = rttov_as_exp[isnow,igrau,i,:,:].flatten()                 counts, bin_edges = np.histogram(var, bins=np.arange(10,300,binreso),density=True)                bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2                axes[index].semilogy(bin_centers, counts, linewidth=1.2, linestyle=lineline[sindex], color=base_colors[igrau])                            counts, _ = np.histogram(varobs, bins=np.arange(10,300,binreso), density=True)            axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='k')                        #grausp            var  = rttov_as_grausp[isnow,i,:,:].flatten()             counts, bin_edges = np.histogram(var, bins=np.arange(10,300,binreso),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=1.2, linestyle=lineline[sindex], color='gray')                        axes[index-1].set_ylabel('Count')                        axes[index].set_title(ichan_title[index]+' GHz')            axes[index].set_xlim([20,310])                axes[0].set_xlabel('BT [K]')        handles, labels = axes[0].get_legend_handles_labels()    fig.legend(handles, labels, ncol=7, loc='lower right', bbox_to_anchor=(0.95,-0.23), title='Graupel combinations')       handles, labels = axes[1].get_legend_handles_labels()    fig.legend(handles, labels, ncol=5, loc='lower right', bbox_to_anchor=(0.7,-0.5), title='Snow habits')               fig.suptitle(title, fontweight='bold')        #fig.savefig(plotpath+f'/oral/loghist_rttovas_{title}.png',     #            dpi=300,transparent=False, bbox_inches='tight')       fig.savefig(plotpath+f'/oral/loghist_rttovas_{title}_withoutdendrite.png',                 dpi=300,transparent=False, bbox_inches='tight')        plt.close()        return#------------------------------------------------------------------------------def quickProcessandPlot(instrument, HHtime, mp_version, server, allskyfile):     plotpath, folders = config_folders(server)        # Select server and folder locations    #--------------------------------------------------------------------------    if 'yakaira' in server:         upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        sys.path.insert(1,'/home/vito.galligani/datosmunin3/Work/Studies/HAILCASE_10112018/src')        processedFolder = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/Processed/'          elif 'cnrm' in server:        upfolder    = '/home/galliganiv/'           sys.path.insert(1,'/home/galliganiv/ACMS_hail/src')        processedFolder = '/home/galliganiv/Work/HAILCASE_10112018/RTTOVinout/Processed/'            #--------------------------------------------------------------------------    # server dependent files        from package_functions import pressure2height    import package_functions as funs            #--------------------------------------------------------------------------    if mp_version == 6:        mp_physics = 'WRF-WSM6'        ncfile     = upfolder+'WRFOUT/WSM6_domain3_NoahMP/wrfout_d02_2018-11-10_'+HHtime+':00'        ncdata     = Dataset(ncfile,'r')         [qr, qs, qi, qc, qg, qr_int, qs_int, qi_int, qc_int, qg_int] = funs.get_q_ints6(ncdata)        int_titles = ['qr','qc','qi','qs','qg']        skipProfs = filter_pixels_monotonic(mp_version, '20:30', server)       elif mp_version == 6.1:                mp_physics = 'WRFWSM6_YSU12hr'        ncfolder  = upfolder+'WRFOUT_1domain/WSM6_1domaintest_12hrs_YSU/'            ncfile    = ncfolder+'wrfout_d01_2018-11-10_'+HHtime+':00'                  ncdata     = Dataset(ncfile,'r')         [qr, qs, qi, qc, qg, qr_int, qs_int, qi_int, qc_int, qg_int] = funs.get_q_ints6(ncdata)        int_titles = ['qr','qc','qi','qs','qg']                # RTTOVout folders and file.         outfolder = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/WRFWSM6_YSU12hr/rttov_sieron/'        WSM6_file = np.genfromtxt(outfolder+'output_cs_tb_'+instrument)        skipProfs = filter_pixels_monotonic(mp_version, '20:00', server)               #--------------------------------------------------------------------------    A           = read_wrf(ncfile)    allskyfile='output_tb_allsky__'+allskyfile    print('Running for: '+ allskyfile)    WSM6_allsky = np.genfromtxt(outfolder+allskyfile)                                         # Select instrument configurations    #--------------------------------------------------------------------------    if 'MHS' in instrument:         nchan = 5    elif 'AMSR' in instrument:        nchan = 14               #------            ij_list = []    counter = 0    for i in range(390, 550):        for j in range(100, 410):            counter += 1            if counter not in skipProfs:                ij_list.append((i, j))  # This profile was used                 tb_asrttov = np.full((5, A['XLONG'].shape[0], A['XLONG'].shape[1]), np.nan)  # or whatever shape you need    for idx, (i, j) in enumerate(ij_list):        tb_asrttov[:, i, j] = WSM6_allsky[idx, :]  # transpose from [49499, 5] to [5, i, j]            lats = A['XLAT']    lons = A['XLONG']        cmaps = GMI_colormap()     cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values    fig = plt.figure(figsize=(8, 8))    plt.pcolormesh(lons,lats,tb_asrttov[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=70, vmax=300)    plt.colorbar()    fig.savefig(plotpath+'/domain1/'+allskyfile+'.png', dpi=300, transparent=False, bbox_inches='tight')       return#------------------------------------------------------------------------------def test_maps():        # Read allsky simulations snow (liu) + graupel (soft sphere) and plot maps as an example    for isnow in range(11):        expname = 'allsky_liusnow'+str(isnow)+'graupel_softsphere'         exp4title = f'rttov_as ({expname})'        d_as    = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_'+expname)        fig = make_simBTvar_maps(d_as['wrf_lon'], d_as['wrf_lat'], d_as['rttov_as'].data, 50, 300, 'BT [K]', exp4title)        #fig.savefig(plotpath+f'/oral/MHS_sims_rttov_as_{expname}.png', dpi=300, transparent=False, bbox_inches='tight')           d_as.close()            return#------------------------------------------------------------------------------def make_liugrausp_histograms(processedFolder, rttov_approach):    # Read arrays of rttov_sieron to make histograms    liugrausp, liugrausp_gaus                   = get_arrays_liu_grausp('', processedFolder, rttov_approach)     if 'sieron' in rttov_approach:        liugrausp_halfgrau, liugrausp_halfgrau_gaus = get_arrays_liu_grausp('halfgrau', processedFolder, rttov_approach)     # Make histograms    #------------------------------------------------------------------------------    expname = 'allsky_sliu_grausp'     #-----------    title = 'control_wrfgrid_'+expname    fig = make_hists_liugrausp(d_cs, liugrausp, title, binreso=5)    fig.savefig(plotpath+f'/histograms/loghist_{title}.png', dpi=300,transparent=False, bbox_inches='tight')        title = 'control_gaussian_'+expname    fig = make_hists_liugrausp(d_cs, liugrausp_gaus, title,  binreso=10)    fig.savefig(plotpath+f'/histograms/loghist_{title}.png', dpi=300,transparent=False, bbox_inches='tight')        if 'sieron' in rttov_approach:        expname = 'allsky_sliu_grausp_halfgrau'         #-----------        title = 'control_wrfgrid_'+expname        fig = make_hists_liugrausp(d_cs, liugrausp_halfgrau, title, binreso=5)        fig.savefig(plotpath+f'/histograms/loghist_rttovas_{title}.png', dpi=300,transparent=False, bbox_inches='tight')            title = 'control_gaussian_'+expname        fig = make_hists_liugrausp(d_cs, liugrausp_halfgrau, title,  binreso=10)        fig.savefig(plotpath+f'/histograms/{rttov_approach}/loghist_rttovas_{title}.png', dpi=300,transparent=False, bbox_inches='tight')                return#------------------------------------------------------------------------------def make_liuliu_grausp_histograms(processedFolder, rttov_approach):    # Read arrays of rttov_sieron to make histograms    liugrausp, liugrausp_gaus                   = get_arrays_liu_grausp('', processedFolder, rttov_approach)      liuliu, liuliu_gaus                   = get_arrays_liuliu('', processedFolder, rttov_approach)      if 'sieron' in rttov_approach:        liugrausp_halfgrau, liugrausp_halfgrau_gaus = get_arrays_liu_grausp('halfgrau', processedFolder, rttov_approach)         liuliu_halfgrau, liuliu_halfgrau_gaus = get_arrays_liuliu('halfgrau', processedFolder, rttov_approach)      # Make histograms: one figure per isnow combinations    #------------------------------------------------------------------------------    make_hists_liuliu_grausp_1fig_pershape(d_cs, liuliu, liugrausp, 'control_wrfgrid_',  rttov_approach, binreso=5)    make_hists_liuliu_grausp_1fig_pershape(d_cs, liuliu_gaus, liugrausp_gaus, 'control_gaussian_', rttov_approach, binreso=10)    if 'sieron' in rttov_approach:        make_hists_liuliu_grausp_1fig_pershape(d_cs, liuliu_halfgrau, liugrausp_halfgrau, 'control_wrfgrid_halfgrau_', rttov_approach, binreso=5)        make_hists_liuliu_grausp_1fig_pershape(d_cs, liuliu_halfgrau_gaus, liugrausp_halfgrau_gaus, 'control_gaussian_halfgrau_', rttov_approach, binreso=10)    # Make histograms: one figure per igrau     #------------------------------------------------------------------------------    make_hists_liuliu_grausp_1fig_perigrau(d_cs, liuliu, liugrausp, 'control_wrfgrid_', rttov_approach, binreso=5)    make_hists_liuliu_grausp_1fig_perigrau(d_cs, liuliu_gaus, liugrausp_gaus, 'control_gaussian_',  rttov_approach, binreso=10)    if 'sieron' in rttov_approach:        make_hists_liuliu_grausp_1fig_perigrau(d_cs, liuliu_halfgrau, liugrausp_halfgrau, 'control_wrfgrid_halfgrau_', rttov_approach, binreso=5)        make_hists_liuliu_grausp_1fig_perigrau(d_cs, liuliu_halfgrau_gaus, liugrausp_halfgrau_gaus, 'control_gaussian_halfgrau_', rttov_approach, binreso=10)        return#------------------------------------------------------------------------------def plot_oral_histograms(processedFolder, rttov_approach):    # Read arrays of rttov_sieron to make histograms    liugrausp, liugrausp_gaus = get_arrays_liu_grausp('', processedFolder, rttov_approach)      liuliu, liuliu_gaus       = get_arrays_liuliu('', processedFolder, rttov_approach)      # Make histograms: one figure per igrau     #------------------------------------------------------------------------------    make_hists_4oral(d_cs, liuliu, liugrausp, 'control_wrfgrid_', rttov_approach, binreso=5)        return#------------------------------------------------------------------------------def make_transects():         expname  = 'liusnow9'+'liugrau5'+''    d_sieron = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')    expname  = 'liusnow9'+'liugrau5'+'halfgrau'    d_sieron_half = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')    expname  = 'liusnow9'+'_liugrau5'+''    d_eqmass = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_eqmass_allsky_'+expname+'.nc')    expname  = 'liusnow9'+'_liugrau5'+''    d_iwcrescaling = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_iwcrescaling_allsky_'+expname+'.nc')            d_cs    = xr.open_dataset(processedFolder+'/'+'rttov_processed_clearsky.nc')    # Some basic info for paths      cmaps = T2P.GMI_colormap()                 if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    plotpath, folders = config_folders(server)        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)            #------- PLOT    fig = plt.figure(figsize=(8,8))     pcm = plt.pcolormesh(d_sieron['wrf_lon'], d_sieron['wrf_lat'], d_sieron['rttov_as'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=50, vmax=300)    cbar = plt.colorbar(pcm, orientation='vertical')    plt.xlim([-66,-61])    plt.ylim([-34,-32])        plt.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    plt.plot(prov[:,0],prov[:,1],color='r');     plt.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    plt.title(r'Sieron (89 GHz)')    plt.xlabel('Longitude')    plt.ylabel('Latitude')    fig.savefig(plotpath+'/domain1/sieron_ejemplo_s9g5.png', dpi=300, transparent=False, bbox_inches='tight')               fig = plt.figure(figsize=(8,8))     pcm = plt.pcolormesh(d_eqmass['wrf_lon'], d_eqmass['wrf_lat'], d_eqmass['rttov_as'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=50, vmax=300)    cbar = plt.colorbar(pcm, orientation='vertical')    plt.xlim([-66,-61])    plt.ylim([-34,-32])        plt.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    plt.plot(prov[:,0],prov[:,1],color='r');     plt.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    plt.title(r'Eqmass (89 GHz)')    plt.xlabel('Longitude')    plt.ylabel('Latitude')    fig.savefig(plotpath+'/domain1/eqmass_ejemplo_s9g5.png', dpi=300, transparent=False, bbox_inches='tight')           fig = plt.figure(figsize=(8,8))     pcm = plt.pcolormesh(d_iwcrescaling['wrf_lon'], d_iwcrescaling['wrf_lat'], d_iwcrescaling['rttov_as'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=50, vmax=300)    cbar = plt.colorbar(pcm, orientation='vertical')    plt.xlim([-66,-61])    plt.ylim([-34,-32])        plt.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    plt.plot(prov[:,0],prov[:,1],color='r');     plt.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    plt.title(r'iwc-rescaling (89 GHz)')    plt.xlabel('Longitude')    plt.ylabel('Latitude')    fig.savefig(plotpath+'/domain1/iwcrescaling_ejemplo_s9g5.png', dpi=300, transparent=False, bbox_inches='tight')       #------- PLOT    fig = plt.figure(figsize=(5,5))     pcm = plt.pcolormesh(d_sieron['wrf_lon'], d_sieron['wrf_lat'], d_sieron['rttov_as'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=50, vmax=300)    cbar = plt.colorbar(pcm, orientation='vertical')    plt.xlim([-66,-61])    plt.ylim([-34,-32])        plt.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    plt.plot(prov[:,0],prov[:,1],color='r');     plt.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    plt.title(r'Sieron (89 GHz)')    plt.xlabel('Longitude')    plt.ylabel('Latitude')    plt.axhline(y=-32.8, color='magenta', linestyle='-', linewidth=4)    fig.savefig(plotpath+'/domain1/sieron_ejemplo_s9g5_wtransect.png', dpi=300, transparent=False, bbox_inches='tight')               # fig = plt.figure(figsize=(12,6))    # gs = gridspec.GridSpec(4, 3,    #                        width_ratios=[1, 0.05, 2],   # col 0: square, col 2: wide, col 1: spacing    #                        height_ratios=[1, 0.05, 1, 0.05], wspace=0.27, hspace=0.4)     # # Square map plots (ax1, ax3) — taller    # ax1 = fig.add_subplot(gs[0, 0])    # ax3 = fig.add_subplot(gs[2, 0])    # # Rectangular transect plots (ax2, ax4) — wider and shorter    # ax2 = fig.add_subplot(gs[0, 2])    # ax4 = fig.add_subplot(gs[2, 2])    # # BT map     # pcm = ax1.pcolormesh(d_sieron['wrf_lon'], d_sieron['wrf_lat'], d_sieron['rttov_as'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=50, vmax=300)    # cbar = plt.colorbar(pcm, ax=ax1, orientation='vertical', label=r'[K]')    # ax1.set_xlim([-66,-60])    # ax1.set_ylim([-34,-31])        # ax1.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    # ax1.plot(prov[:,0],prov[:,1],color='r');     # ax1.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    # ax1.set_title(r'Sieron (89 GHz)')    # ax1.set_xlabel('Longitude')    # ax1.set_ylabel('Latitude')        # Transect calc    target_lat   = -32.8     lat_vals     = d_sieron['wrf_lat'].values    lat_diff     = np.abs(lat_vals - target_lat)    i_lat, i_lon = np.unravel_index(np.argmin(lat_diff), lat_diff.shape)    transect_sieron_BT      = d_sieron['rttov_as'].data[:, i_lat, :]   # shape: (nlev, 1099)    transect_sieron_BThalf  = d_sieron_half['rttov_as'].data[:, i_lat, :]   # shape: (nlev, 1099)    transect_lons           = d_sieron['wrf_lon'].values[i_lat, :]  # shape: (1099,)        # Transect plot    #    # Channel selections    ichan_title         = ['89', '157']    channels_indexplot  = [0,1]    colors              = ['darkred','darkblue']        base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]              isspname = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']        grau_dda = [2,5,8,9,10]        # Get other grau combinations    tb_as      = []     for igrau in [2, 5, 8, 9, 10]:        expname = 'liusnow'+str(9)+'liugrau'+str(igrau)        d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')        var      = d_as['rttov_as'].values        tb_as.append(var)        d_as.close()    tb_as      = np.array(tb_as)            # This is for snow sector + grau 6bullet, but show in gray the other combinations.     fig = plt.figure(figsize=(12,6))    gs = gridspec.GridSpec(nrows=3, ncols=1, height_ratios=[1,1.5,1.5], hspace=0.7)    ax1 = fig.add_subplot(gs[0])    ax2 = fig.add_subplot(gs[1])    ax3 = fig.add_subplot(gs[2])    axes = [ax1,ax2,ax3]        # legends    axes[0].plot([],[], linewidth=1.2, linestyle='-', color='k', label='MHS 89GHz')    axes[0].plot([],[], linewidth=1.2, linestyle='--', color='k', label='MHS 157GHz')    axes[0].plot([],[],color='darkred', label='swc')        axes[0].plot([],[],color='darkblue', label='swc/2')                          axes[0].fill_between([],[],[],color='gray', alpha=0.5, label='grau combinations')    handles, labels = axes[0].get_legend_handles_labels()    fig.legend(handles, labels, ncol=1, loc='center right', bbox_to_anchor=(1.2,0.75))          # add 2plot    for iter_i in [24]:        axes[0].plot(d_cs['MHS_lon'][:,iter_i], d_cs['MHs_domain_obs'][0,:,iter_i], color='k', linestyle='-', linewidth=1.2, label='89 GHz')        axes[0].plot(d_cs['MHS_lon'][:,iter_i], d_cs['MHs_domain_obs'][1,:,iter_i], color='k', linestyle='--', linewidth=1.2, label='157 GHz')    axes[0].set_ylim([50,300])    axes[0].set_xlim([-64,-60])    axes[0].grid(True)    axes[0].set_ylabel('BTs [K]')    axes[0].set_title('Reference observed BTs')    for index, i in enumerate(channels_indexplot):        axes[i+1].plot(transect_lons, transect_sieron_BT[i,:], color='darkred', linestyle='-', linewidth=1.2)        axes[i+1].plot(transect_lons, transect_sieron_BThalf[i,:], color='darkblue', linestyle='--', linewidth=1.2)        # loop over other options:        #for igrau in range(len([2, 5, 8, 9, 10])):        #    axes[i].plot(transect_lons, tb_as[igrau,i,i_lat,:], color='gray', linestyle='-', linewidth=1.2)        data = np.vstack([tb_as[0,i,i_lat,:], tb_as[1,i,i_lat,:],                           tb_as[2,i,i_lat,:], tb_as[3,i,i_lat,:], tb_as[4,i,i_lat,:]])        ymin=np.nanmin(data, axis=0)        ymax=np.nanmax(data, axis=0)        axes[i+1].fill_between(transect_lons,ymin,ymax,color='gray', alpha=0.5)        axes[i+1].set_xlim([-63.6,-62])        axes[i+1].set_ylim([50,300])        axes[i+1].grid(True)        axes[i+1].set_ylabel(f'{ichan_title[i]}GHz [K]')    axes[2].set_xlabel('Longitude')    axes[1].set_title('Simulated BTs')    fig.savefig(plotpath+'/oral/Transects_analysis1.png', dpi=300, transparent=False, bbox_inches='tight')           # SIMILAR FIGURE BUT W. DETAIL OF DDA SHAPES, NO IWC/2    # This is for snow sector + grau 6bullet, but show in gray the other combinations.     fig = plt.figure(figsize=(12,6))    gs = gridspec.GridSpec(nrows=3, ncols=1, height_ratios=[1,1.5,1.5], hspace=0.7)    ax1 = fig.add_subplot(gs[0])    ax2 = fig.add_subplot(gs[1])    ax3 = fig.add_subplot(gs[2])    axes = [ax1,ax2,ax3]        # legends    axes[0].plot([],[], linewidth=1.2, linestyle='-', color='k', label='MHS 89GHz')    axes[0].plot([],[], linewidth=1.2, linestyle='--', color='k', label='MHS 157GHz')    for igrau, indexgrau in enumerate([2, 5, 8, 9, 10]):        axes[0].plot([], [], color=base_colors[indexgrau], linestyle='-', linewidth=1.2, label=isspname[indexgrau])        axes[0].fill_between([],[],[],color='gray', alpha=0.5, label='grau combinations')    handles, labels = axes[0].get_legend_handles_labels()    fig.legend(handles, labels, ncol=1, loc='center right', bbox_to_anchor=(1.2,0.75))          # add 2plot    for iter_i in [24]:        axes[0].plot(d_cs['MHS_lon'][:,iter_i], d_cs['MHs_domain_obs'][0,:,iter_i], color='k', linestyle='-', linewidth=1.2, label='89 GHz')        axes[0].plot(d_cs['MHS_lon'][:,iter_i], d_cs['MHs_domain_obs'][1,:,iter_i], color='k', linestyle='--', linewidth=1.2, label='157 GHz')    axes[0].set_ylim([50,300])    axes[0].set_xlim([-64,-60])    axes[0].grid(True)    axes[0].set_ylabel('BTs [K]')    axes[0].set_title('Reference observed BTs')    for index, i in enumerate(channels_indexplot):        data = np.vstack([tb_as[0,i,i_lat,:], tb_as[1,i,i_lat,:],                           tb_as[2,i,i_lat,:], tb_as[3,i,i_lat,:], tb_as[4,i,i_lat,:]])        ymin=np.nanmin(data, axis=0)        ymax=np.nanmax(data, axis=0)        axes[i+1].fill_between(transect_lons,ymin,ymax,color='gray', alpha=0.5)        axes[i+1].set_xlim([-63.6,-62])        axes[i+1].set_ylim([50,300])        axes[i+1].grid(True)        axes[i+1].set_ylabel(f'{ichan_title[i]}GHz [K]')    axes[2].set_xlabel('Longitude')    axes[1].set_title('Simulated BTs')    for index, i in enumerate(channels_indexplot):        for igrau, indexgrau in enumerate([2, 5, 8, 9, 10]):            axes[i+1].plot(transect_lons, tb_as[igrau,i,i_lat,:], color=base_colors[indexgrau], linestyle='-', linewidth=1.2)    fig.savefig(plotpath+'/oral/Transects_analysis2.png', dpi=300, transparent=False, bbox_inches='tight')       return#------------------------------------------------------------------------------def make_transects_tests():         expname  = 'liusnow9'+'liugrau5'+''    d_sieron = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')    expname  = 'liusnow9'+'liugrau5'+'halfgrau'    d_sieron_half = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')    expname  = 'liusnow9'+'_liugrau5'+''    d_eqmass = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_eqmass_allsky_'+expname+'.nc')    expname  = 'liusnow9'+'_liugrau5'+''    d_iwcrescaling = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_iwcrescaling_allsky_'+expname+'.nc')            d_cs    = xr.open_dataset(processedFolder+'/'+'rttov_processed_clearsky.nc')    # also the two tests with aggregates:    expname  = 'liusnow9'+'gliu2'+'_aggregates8'    d_s9g2a8 = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky__'+expname+'.nc')    expname  = 'liusnow9'+'gliu5'+'_aggregates8'    d_s9g5a8 = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky__'+expname+'.nc')                    # also splitting by temperature    expname  = 'liusnow8'+'gliu2'+'_aggregates9'+'_2snowprofile_temp'    d_s8g2a9_temp = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky__'+expname+'.nc')    expname  = 'liusnow8'+'gliu5'+'_aggregates9'+'_2snowprofile_temp'    d_s8g5a9_temp = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky__'+expname+'.nc')            expname  = 'liusnow8'+'gliu8'+'_aggregates9'+'_2snowprofile_temp'    d_s8g8a9_temp = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky__'+expname+'.nc')            expname  = 'liusnow5'+'gliu5'+'_aggregates9'+'_2snowprofile_temp'    d_s5g5a9_temp = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky__'+expname+'.nc')            expname  = 'liusnow8'+'gliu5'+'_aggregates9'+'_2snowprofile_temp2'    d_s5g5a9_temp2 = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky__'+expname+'.nc')                                                                              # Some basic info for paths      cmaps = T2P.GMI_colormap()                 if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    plotpath, folders = config_folders(server)        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)            #------- PLOT    fig = plt.figure(figsize=(8,8))     pcm = plt.pcolormesh(d_s9g5a8['wrf_lon'], d_s9g5a8['wrf_lat'], d_s9g5a8['rttov_as'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=50, vmax=300)    cbar = plt.colorbar(pcm, orientation='vertical')    plt.xlim([-66,-61])    plt.ylim([-34,-32])        plt.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    plt.plot(prov[:,0],prov[:,1],color='r');     plt.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    plt.title(r'Sieron (89 GHz)')    plt.xlabel('Longitude')    plt.ylabel('Latitude')    fig.savefig(plotpath+'/domain1/sieron_ejemplo_aggregates_s9g5a8.png', dpi=300, transparent=False, bbox_inches='tight')               fig = plt.figure(figsize=(8,8))     pcm = plt.pcolormesh(d_s9g2a8['wrf_lon'], d_s9g2a8['wrf_lat'], d_eqmass['rttov_as'].data[0,:,:], cmap=cmaps['turbo_r'], shading='auto', vmin=50, vmax=300)    cbar = plt.colorbar(pcm, orientation='vertical')    plt.xlim([-66,-61])    plt.ylim([-34,-32])        plt.axhline(y=-32.8, color='magenta', linestyle='--', linewidth=2)    plt.plot(prov[:,0],prov[:,1],color='r');     plt.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    plt.title(r'Sieron (89 GHz)')    plt.xlabel('Longitude')    plt.ylabel('Latitude')    fig.savefig(plotpath+'/domain1/sieron_ejemplo_aggregates_s9g2a8.png', dpi=300, transparent=False, bbox_inches='tight')           # Transect calc    target_lat   = -32.8     lat_vals     = d_sieron['wrf_lat'].values    lat_diff     = np.abs(lat_vals - target_lat)    i_lat, i_lon = np.unravel_index(np.argmin(lat_diff), lat_diff.shape)    transect_sieron_BT      = d_sieron['rttov_as'].data[:, i_lat, :]   # shape: (nlev, 1099)    transect_sieron_BThalf  = d_sieron_half['rttov_as'].data[:, i_lat, :]   # shape: (nlev, 1099)    transect_lons           = d_sieron['wrf_lon'].values[i_lat, :]  # shape: (1099,)        # Transect plot    # Channel selections    ichan_title         = ['89', '157']    channels_indexplot  = [0,1]    colors              = ['darkred','darkblue']        base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]              isspname = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']        grau_dda = [2,5,8,9,10]        # Get other grau combinations    tb_as      = []     for igrau in [2, 5, 8, 9, 10]:        expname = 'liusnow'+str(9)+'liugrau'+str(igrau)        d_as     = xr.open_dataset(processedFolder+'/'+'rttov_processed_allsky_sieron_allsky_'+expname+'.nc')        var      = d_as['rttov_as'].values        tb_as.append(var)        d_as.close()    tb_as      = np.array(tb_as)                fig = plt.figure(figsize=(12,6))    gs = gridspec.GridSpec(nrows=3, ncols=1, height_ratios=[1,1.5,1.5], hspace=0.7)    ax1 = fig.add_subplot(gs[0])    ax2 = fig.add_subplot(gs[1])    ax3 = fig.add_subplot(gs[2])    axes = [ax1,ax2,ax3]        # legends    axes[0].plot([],[], linewidth=1.2, linestyle='-', color='k', label='MHS 89GHz')    axes[0].plot([],[], linewidth=1.2, linestyle='--', color='k', label='MHS 157GHz')    #for igrau, indexgrau in enumerate([2, 5, 8, 9, 10]):    #    axes[0].plot([], [], color=base_colors[indexgrau], linestyle='-', linewidth=1.2, label=isspname[indexgrau])    axes[0].plot([], [], color='k', linestyle='-', linewidth=1.2, label='grau: Block hex col. (swc split)')    axes[0].plot([], [], color='k', linestyle='--', linewidth=1.2, label='grau: 3b ros. (swc split)')    #axes[0].plot([], [], color='k', linestyle='-', linewidth=1.2, label='grau: Block hex col. (temp split)')    #axes[0].plot([], [], color='k', linestyle='--', linewidth=1.2, label='grau: 3b ros. (temp split)')        axes[0].fill_between([],[],[],color='gray', alpha=0.5, label='grau combinations')    handles, labels = axes[0].get_legend_handles_labels()    fig.legend(handles, labels, ncol=1, loc='center right', bbox_to_anchor=(1.2,0.75))          # add 2plot    for iter_i in [24]:        axes[0].plot(d_cs['MHS_lon'][:,iter_i], d_cs['MHs_domain_obs'][0,:,iter_i], color='k', linestyle='-', linewidth=1.2, label='89 GHz')        axes[0].plot(d_cs['MHS_lon'][:,iter_i], d_cs['MHs_domain_obs'][1,:,iter_i], color='k', linestyle='--', linewidth=1.2, label='157 GHz')    axes[0].set_ylim([50,300])    axes[0].set_xlim([-64,-60])    axes[0].grid(True)    axes[0].set_ylabel('BTs [K]')    axes[0].set_title('Reference observed BTs')    for index, i in enumerate(channels_indexplot):        axes[i+1].plot(transect_lons, d_s9g2a8['rttov_as'][i,i_lat,:], color='k', linestyle='-', linewidth=1.2)        axes[i+1].plot(transect_lons, d_s9g5a8['rttov_as'][i,i_lat,:], color='k', linestyle='--', linewidth=1.2)                axes[i+1].plot(transect_lons, d_s8g2a9_temp['rttov_as'][i,i_lat,:], color='r', linestyle='--', linewidth=1.2)        axes[i+1].plot(transect_lons, d_s8g5a9_temp['rttov_as'][i,i_lat,:], color='r', linestyle='--', linewidth=1.2)        axes[i+1].plot(transect_lons, d_s8g8a9_temp['rttov_as'][i,i_lat,:], color='b', linestyle='--', linewidth=1.2)        axes[i+1].plot(transect_lons, d_s5g5a9_temp['rttov_as'][i,i_lat,:], color='b', linestyle='--', linewidth=1.2)        axes[i+1].plot(transect_lons, d_s5g5a9_temp2['rttov_as'][i,i_lat,:], color='m', linestyle='--', linewidth=1.2)    for index, i in enumerate(channels_indexplot):        data = np.vstack([tb_as[0,i,i_lat,:], tb_as[1,i,i_lat,:],                           tb_as[2,i,i_lat,:], tb_as[3,i,i_lat,:], tb_as[4,i,i_lat,:]])        ymin=np.nanmin(data, axis=0)        ymax=np.nanmax(data, axis=0)        axes[i+1].fill_between(transect_lons,ymin,ymax,color='gray', alpha=0.5)        axes[i+1].set_xlim([-63.6,-62])        axes[i+1].set_ylim([50,300])        axes[i+1].grid(True)        axes[i+1].set_ylabel(f'{ichan_title[i]}GHz [K]')    axes[2].set_xlabel('Longitude')    axes[1].set_title('Simulated BTs with snow(sector) and aggregates(6b ros.))')    #for index, i in enumerate(channels_indexplot):    #    for igrau, indexgrau in enumerate([2, 5, 8, 9, 10]):    #        axes[i+1].plot(transect_lons, tb_as[igrau,i,i_lat,:], color=base_colors[indexgrau], linestyle='-', linewidth=1.2)    ##fig.savefig(plotpath+'/oral/Transects_analysis4.png', dpi=300, transparent=False, bbox_inches='tight')       return# =============================================================================# =============================================================================if __name__ == "__main__":#------------------------------------------------------------------------------#------------------------------------------------------------------------------        mp_physics = 'WRFWSM6_YSU12hr'    instrument = 'MHS'    server = 'yakaira'    if 'yakaira' in server:         upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        sys.path.insert(1,'/home/vito.galligani/datosmunin3/Work/Studies/HAILCASE_10112018/src')        processedFolder = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/Processed/'+mp_physics        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'        plotpath, folders = config_folders(server)          # Read rttov clearsky simulations and WRF inputs used    d_cs    = xr.open_dataset(processedFolder+'/'+'rttov_processed_clearsky.nc')    WRFvars = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            already_done = 1        if already_done == 0:         # Plot observations        fig = make_BTvar_maps(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data, 50, 300, 'BT [K]','OBS')        fig.savefig(plotpath+'/oral/MHS_realobservations.png', dpi=300, transparent=False, bbox_inches='tight')               # Read original WRF output        mp_physics = 'WRFWSM6_YSU12hr'        ncfolder   = upfolder+'WRFOUT_1domain/WSM6_1domaintest_12hrs_YSU/'            ncfile     = ncfolder+'wrfout_d01_2018-11-10_20:00:00'          A          = read_wrf(ncfile)            # Plot MHS grid versus WRFgrid         fig = footprint_WRF_maps(d_cs, A)        fig.savefig(plotpath+'/domain1/footprint.projected.over.wrfsnow.png', dpi=300, transparent=False, bbox_inches='tight')               # Plot profiles to simulate and vertical cut        fig = make_IWP_maps(WRFvars['wrf_lon'], WRFvars['wrf_lat'], WRFvars['WRF_intqs'], WRFvars['WRF_intqg'],                       WRFvars['WRF_qs'], WRFvars['WRF_qg'], WRFvars['wrf_zalt'], 0, 20, '')        fig.savefig(plotpath+'/domain1/Transects_WRFoutputsanalysis.png', dpi=300, transparent=False, bbox_inches='tight')                       #------ quick plot and process sky tests -------------        #    allskyfile=f'sliu{isnow}_gliu{igrau}dummy_2snowprofile_cirsgs_6nhydro_halfgrau'        #    quickProcessandPlot('MHS', '20:30', 6.1, 'yakaira', allskyfile)                #----------- SIERON        # grausp histograms for each liu         make_liugrausp_histograms(processedFolder,'rttov_sieron')        # histograms for individual combinations: isnow for all igrau, and igrau for all isnow + soft sphere graupel         make_liuliu_grausp_histograms(processedFolder,'rttov_sieron')        #----------- iwcrescaling        # grausp histograms for each liu         make_liugrausp_histograms(processedFolder,'rttov_iwcrescaling')        # histograms for individual combinations: isnow for all igrau, and igrau for all isnow + soft sphere graupel         make_liuliu_grausp_histograms(processedFolder,'rttov_iwcrescaling')        # Make 1st histograms general results        plot_oral_histograms(processedFolder,'rttov_sieron')        plot_oral_histograms(processedFolder,'rttov_iwcrescaling')        plot_oral_histograms(processedFolder,'rttov_eqMass')            # Transects        make_transects()        #----------- eqmass        # grausp histograms for each liu         make_liugrausp_histograms(processedFolder,'rttov_eqMass')        # histograms for individual combinations: isnow for all igrau, and igrau for all isnow + soft sphere graupel         make_liuliu_grausp_histograms(processedFolder,'rttov_eqMass')    # Transects of tests    make_transects_tests()                    #-----------     # Plot maps# fig = make_BTvar_maps(d_cs['wrf_lon'], d_cs['wrf_lat'], d_cs['rttov_cs'].data, 50, 300, 'BT [K]', 'rttov_cs')# fig.savefig(plotpath+'/oral/MHS_sims_rttov_cs.png', dpi=300, transparent=False, bbox_inches='tight')    #-----------# Sanity check:make sure 1snow profile == 2dummy profiles (isnow=4)# outfolder = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/WRFWSM6_YSU12hr/rttov_sieron/'# sanity_1  = 'output_tb_allsky__WSM6_rsgs_2snowhabits_sliu7_gliu9dummy_2snowprofiles2snowprofile_cirsgs_6nhydro'# sanity_2  = 'output_tb_allsky__WSM6_rsgs_2snowhabits_sliu7_gliu9dummy_2snowprofiles2snowprofile_cirssg_6nhydro'# WSM6_allsky_1 = np.genfromtxt(outfolder+sanity_1) # WSM6_allsky_2 = np.genfromtxt(outfolder+sanity_2)     # fig = plt.figure(figsize=(8,8))# plt.plot(WSM6_allsky_2[0:5000,0]-WSM6_allsky_1[0:5000,0]);    # fig.savefig(plotpath+'/oral/'+'testing.png', dpi=300,transparent=False)           #------------------------------------------------------------------------------------------