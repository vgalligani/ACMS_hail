from matplotlib.colors import ListedColormapimport matplotlib.pyplot as pltimport numpy as np#from gpm.utils.geospatial import get_continent_extent, get_country_extent, get_geographic_extent_around_point#import gpmimport h5pyimport netCDF4 as ncfrom scipy.interpolate import NearestNDInterpolator, RegularGridInterpolator, griddataimport gc from Tools2RunRTTOV import mhs_simplefootprintimport pandas as pd import xarray as xrimport seaborn as sns from matplotlib.path import Pathplt.matplotlib.rc('font', family='serif', size = 12)plt.rcParams['xtick.labelsize']=12plt.rcParams['ytick.labelsize']=12  #------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_list_slices_from_indices(indices):    """Return a list of slices from a list/array of integer indices.    Example: ``[0,1,2,4,5,8]`` --> ``[slices(0,3),slice(4,6), slice(8,9)]``    """    if isinstance(indices, (int, float)):        indices = [indices]    # Checks    if len(indices) == 0:        return []    indices = np.asarray(indices).astype(int)    indices = sorted(np.unique(indices))    if np.any(np.sign(indices) < 0):        raise ValueError("get_list_slices_from_indices expects only positive" " integer indices.")    if len(indices) == 1:        return [slice(indices[0], indices[0] + 1)]    # Retrieve slices    # idx_splits = np.where(np.diff(indices) > 1)[0]    # if len(idx_splits) == 0:    #     list_slices = [slice(min(indices), max(indices))]    # else:    #     list_idx = np.split(indices, idx_splits+1)    #     list_slices = [slice(x.min(), x.max()+1) for x in list_idx]    start = indices[0]    previous = indices[0]    list_slices = []    for idx in indices[1:]:        if idx - previous == 1:            previous = idx        else:            list_slices.append(slice(start, previous + 1))            start = idx            previous = idx    list_slices.append(slice(start, previous + 1))    return list_slices#------------------------------------------------------------------------------#------------------------------------------------------------------------------def GMI_colormap():         _turbo_colormap_data = [[0.18995,0.07176,0.23217],[0.19483,0.08339,0.26149],                        [0.19956,0.09498,0.29024],[0.20415,0.10652,0.31844],                        [0.20860,0.11802,0.34607],[0.21291,0.12947,0.37314],                        [0.21708,0.14087,0.39964],[0.22111,0.15223,0.42558],                        [0.22500,0.16354,0.45096],[0.22875,0.17481,0.47578],                        [0.23236,0.18603,0.50004],[0.23582,0.19720,0.52373],                        [0.23915,0.20833,0.54686],[0.24234,0.21941,0.56942],                        [0.24539,0.23044,0.59142],[0.24830,0.24143,0.61286],                        [0.25107,0.25237,0.63374],[0.25369,0.26327,0.65406],                        [0.25618,0.27412,0.67381],[0.25853,0.28492,0.69300],                        [0.26074,0.29568,0.71162],[0.26280,0.30639,0.72968],                        [0.26473,0.31706,0.74718],[0.26652,0.32768,0.76412],                        [0.26816,0.33825,0.78050],[0.26967,0.34878,0.79631],                        [0.27103,0.35926,0.81156],[0.27226,0.36970,0.82624],                        [0.27334,0.38008,0.84037],[0.27429,0.39043,0.85393],                        [0.27509,0.40072,0.86692],[0.27576,0.41097,0.87936],                        [0.27628,0.42118,0.89123],[0.27667,0.43134,0.90254],                        [0.27691,0.44145,0.91328],[0.27701,0.45152,0.92347],                        [0.27698,0.46153,0.93309],[0.27680,0.47151,0.94214],                        [0.27648,0.48144,0.95064],[0.27603,0.49132,0.95857],                        [0.27543,0.50115,0.96594],[0.27469,0.51094,0.97275],                        [0.27381,0.52069,0.97899],[0.27273,0.53040,0.98461],                        [0.27106,0.54015,0.98930],[0.26878,0.54995,0.99303],                        [0.26592,0.55979,0.99583],[0.26252,0.56967,0.99773],                        [0.25862,0.57958,0.99876],[0.25425,0.58950,0.99896],                        [0.24946,0.59943,0.99835],[0.24427,0.60937,0.99697],                        [0.23874,0.61931,0.99485],[0.23288,0.62923,0.99202],                        [0.22676,0.63913,0.98851],[0.22039,0.64901,0.98436],                        [0.21382,0.65886,0.97959],[0.20708,0.66866,0.97423],                        [0.20021,0.67842,0.96833],[0.19326,0.68812,0.96190],                        [0.18625,0.69775,0.95498],[0.17923,0.70732,0.94761],                        [0.17223,0.71680,0.93981],[0.16529,0.72620,0.93161],                        [0.15844,0.73551,0.92305],[0.15173,0.74472,0.91416],                        [0.14519,0.75381,0.90496],[0.13886,0.76279,0.89550],                        [0.13278,0.77165,0.88580],[0.12698,0.78037,0.87590],                        [0.12151,0.78896,0.86581],[0.11639,0.79740,0.85559],                        [0.11167,0.80569,0.84525],[0.10738,0.81381,0.83484],                        [0.10357,0.82177,0.82437],[0.10026,0.82955,0.81389],                        [0.09750,0.83714,0.80342],[0.09532,0.84455,0.79299],                        [0.09377,0.85175,0.78264],[0.09287,0.85875,0.77240],                        [0.09267,0.86554,0.76230],[0.09320,0.87211,0.75237],                        [0.09451,0.87844,0.74265],[0.09662,0.88454,0.73316],                        [0.09958,0.89040,0.72393],[0.10342,0.89600,0.71500],                        [0.10815,0.90142,0.70599],[0.11374,0.90673,0.69651],                        [0.12014,0.91193,0.68660],[0.12733,0.91701,0.67627],                        [0.13526,0.92197,0.66556],[0.14391,0.92680,0.65448],                        [0.15323,0.93151,0.64308],[0.16319,0.93609,0.63137],                        [0.17377,0.94053,0.61938],[0.18491,0.94484,0.60713],                        [0.19659,0.94901,0.59466],[0.20877,0.95304,0.58199],                        [0.22142,0.95692,0.56914],[0.23449,0.96065,0.55614],                        [0.24797,0.96423,0.54303],[0.26180,0.96765,0.52981],                        [0.27597,0.97092,0.51653],[0.29042,0.97403,0.50321],                        [0.30513,0.97697,0.48987],[0.32006,0.97974,0.47654],                        [0.33517,0.98234,0.46325],[0.35043,0.98477,0.45002],                        [0.36581,0.98702,0.43688],[0.38127,0.98909,0.42386],                        [0.39678,0.99098,0.41098],[0.41229,0.99268,0.39826],                        [0.42778,0.99419,0.38575],[0.44321,0.99551,0.37345],                        [0.45854,0.99663,0.36140],[0.47375,0.99755,0.34963],                        [0.48879,0.99828,0.33816],[0.50362,0.99879,0.32701],                        [0.51822,0.99910,0.31622],[0.53255,0.99919,0.30581],                        [0.54658,0.99907,0.29581],[0.56026,0.99873,0.28623],                        [0.57357,0.99817,0.27712],[0.58646,0.99739,0.26849],                        [0.59891,0.99638,0.26038],[0.61088,0.99514,0.25280],                        [0.62233,0.99366,0.24579],[0.63323,0.99195,0.23937],                        [0.64362,0.98999,0.23356],[0.65394,0.98775,0.22835],                        [0.66428,0.98524,0.22370],[0.67462,0.98246,0.21960],                        [0.68494,0.97941,0.21602],[0.69525,0.97610,0.21294],                        [0.70553,0.97255,0.21032],[0.71577,0.96875,0.20815],                        [0.72596,0.96470,0.20640],[0.73610,0.96043,0.20504],                        [0.74617,0.95593,0.20406],[0.75617,0.95121,0.20343],                        [0.76608,0.94627,0.20311],[0.77591,0.94113,0.20310],                        [0.78563,0.93579,0.20336],[0.79524,0.93025,0.20386],                        [0.80473,0.92452,0.20459],[0.81410,0.91861,0.20552],                        [0.82333,0.91253,0.20663],[0.83241,0.90627,0.20788],                        [0.84133,0.89986,0.20926],[0.85010,0.89328,0.21074],                        [0.85868,0.88655,0.21230],[0.86709,0.87968,0.21391],                        [0.87530,0.87267,0.21555],[0.88331,0.86553,0.21719],                        [0.89112,0.85826,0.21880],[0.89870,0.85087,0.22038],                        [0.90605,0.84337,0.22188],[0.91317,0.83576,0.22328],                        [0.92004,0.82806,0.22456],[0.92666,0.82025,0.22570],                        [0.93301,0.81236,0.22667],[0.93909,0.80439,0.22744],                        [0.94489,0.79634,0.22800],[0.95039,0.78823,0.22831],                        [0.95560,0.78005,0.22836],[0.96049,0.77181,0.22811],                        [0.96507,0.76352,0.22754],[0.96931,0.75519,0.22663],                        [0.97323,0.74682,0.22536],[0.97679,0.73842,0.22369],                        [0.98000,0.73000,0.22161],[0.98289,0.72140,0.21918],                        [0.98549,0.71250,0.21650],[0.98781,0.70330,0.21358],                        [0.98986,0.69382,0.21043],[0.99163,0.68408,0.20706],                        [0.99314,0.67408,0.20348],[0.99438,0.66386,0.19971],                        [0.99535,0.65341,0.19577],[0.99607,0.64277,0.19165],                        [0.99654,0.63193,0.18738],[0.99675,0.62093,0.18297],                        [0.99672,0.60977,0.17842],[0.99644,0.59846,0.17376],                        [0.99593,0.58703,0.16899],[0.99517,0.57549,0.16412],                        [0.99419,0.56386,0.15918],[0.99297,0.55214,0.15417],                        [0.99153,0.54036,0.14910],[0.98987,0.52854,0.14398],                        [0.98799,0.51667,0.13883],[0.98590,0.50479,0.13367],                        [0.98360,0.49291,0.12849],[0.98108,0.48104,0.12332],                        [0.97837,0.46920,0.11817],[0.97545,0.45740,0.11305],                        [0.97234,0.44565,0.10797],[0.96904,0.43399,0.10294],                        [0.96555,0.42241,0.09798],[0.96187,0.41093,0.09310],                        [0.95801,0.39958,0.08831],[0.95398,0.38836,0.08362],                        [0.94977,0.37729,0.07905],[0.94538,0.36638,0.07461],                        [0.94084,0.35566,0.07031],[0.93612,0.34513,0.06616],                        [0.93125,0.33482,0.06218],[0.92623,0.32473,0.05837],                        [0.92105,0.31489,0.05475],[0.91572,0.30530,0.05134],                        [0.91024,0.29599,0.04814],[0.90463,0.28696,0.04516],                        [0.89888,0.27824,0.04243],[0.89298,0.26981,0.03993],                        [0.88691,0.26152,0.03753],[0.88066,0.25334,0.03521],                        [0.87422,0.24526,0.03297],[0.86760,0.23730,0.03082],                        [0.86079,0.22945,0.02875],[0.85380,0.22170,0.02677],                        [0.84662,0.21407,0.02487],[0.83926,0.20654,0.02305],                        [0.83172,0.19912,0.02131],[0.82399,0.19182,0.01966],                        [0.81608,0.18462,0.01809],[0.80799,0.17753,0.01660],                        [0.79971,0.17055,0.01520],[0.79125,0.16368,0.01387],                        [0.78260,0.15693,0.01264],[0.77377,0.15028,0.01148],                        [0.76476,0.14374,0.01041],[0.75556,0.13731,0.00942],                        [0.74617,0.13098,0.00851],[0.73661,0.12477,0.00769],                        [0.72686,0.11867,0.00695],[0.71692,0.11268,0.00629],                        [0.70680,0.10680,0.00571],[0.69650,0.10102,0.00522],                        [0.68602,0.09536,0.00481],[0.67535,0.08980,0.00449],                        [0.66449,0.08436,0.00424],[0.65345,0.07902,0.00408],                        [0.64223,0.07380,0.00401],[0.63082,0.06868,0.00401],                        [0.61923,0.06367,0.00410],[0.60746,0.05878,0.00427],                        [0.59550,0.05399,0.00453],[0.58336,0.04931,0.00486],                        [0.57103,0.04474,0.00529],[0.55852,0.04028,0.00579],                        [0.54583,0.03593,0.00638],[0.53295,0.03169,0.00705],                        [0.51989,0.02756,0.00780],[0.50664,0.02354,0.00863],                        [0.49321,0.01963,0.00955],[0.47960,0.01583,0.01055]]    _turbo_colormap_data.reverse()    cmaps = {}    cmaps['turbo_r'] = ListedColormap(_turbo_colormap_data, name='turbo_r')        return cmaps#------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_simple_AMSR2_TEST(lons, lats, q, tb0, tb1, plotpath):     # Some basic info for colormaps             prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')    cmaps = GMI_colormap()     plt.matplotlib.rc('font', family='serif', size = 12)    plt.rcParams['xtick.labelsize']=12    plt.rcParams['ytick.labelsize']=12          cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values        fig, axes = plt.subplots(nrows=1, ncols=4, constrained_layout=True,figsize=[24,7])    pcm = axes[0].pcolormesh(lons, lats, np.sum(q, axis=0),  cmap=cmap, shading='auto')    axes[0].set_title('WRFOUT Qx sum for simulation')    cbar = plt.colorbar(pcm, ax=axes[0], shrink=1)        # V/H channels at 6.925, 7.30, 10.65, 18.7, 23.8, 36.5, 89.0    pcm = axes[1].pcolormesh(lons, lats, tb0[12,:,:],  cmap=cmaps['turbo_r'], shading='auto')    axes[1].set_title('RTTOV 89.0V GHz')    cbar = plt.colorbar(pcm, ax=axes[1], shrink=1)        pcm = axes[2].pcolormesh(lons, lats, tb1[12,:,:],  cmap=cmaps['turbo_r'], shading='auto')    axes[2].set_title('RTTOV (em. atlas) 89.0V GHz')    cbar = plt.colorbar(pcm, ax=axes[2], shrink=1)    pcm = axes[3].pcolormesh(lons, lats, tb1[12,:,:]-tb0[12,:,:],  cmap=cmaps['turbo_r'], vmin=-10, vmax=0, shading='auto')    axes[3].set_title('RTTOV diff (TELSEM-fixed) 89.0V GHz')    cbar = plt.colorbar(pcm, ax=axes[3], shrink=1)    for ii in range(4):        axes[ii].set_xlim([-68,-62]);         axes[ii].set_ylim([-36,-31])        axes[ii].plot(prov[:,0],prov[:,1],color='w');         plt.show()    fig.savefig(plotpath+'/RTTOV/RTTOV_init_tests.png', dpi=300,transparent=False)        return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_simple_AMSR2_comparison(lons, lats, q, tb0, tb1, plotpath, instrument):     # Some basic info for colormaps             prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')    cmaps = GMI_colormap()     plt.matplotlib.rc('font', family='serif', size = 12)    plt.rcParams['xtick.labelsize']=12    plt.rcParams['ytick.labelsize']=12          cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values        #------------------------------------------------------------------------------    # Plot Satellite MW data    #        if 'mhs' in instrument:         mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'        mhs_noaa19_file = mhs_noaa19_dir+'1C.NOAA19.MHS.XCAL2021-V.20181110-S201428-E215628.050287.V07A.HDF5'        # if 'cnrm' in server:    #   extent = get_continent_extent("South America")    #   extent_plot = (-70, -50, -40, -20)     #     ds = gpm.open_granule(mhs_noaa19_file)        #     da_89  = ds['Tc'].isel(pmw_frequency=0)    #     da_157 = ds['Tc'].isel(pmw_frequency=1)    #     list_isel_dict = da_89.gpm.get_crop_slices_by_extent(extent)    #     # - Plot the swath crossing the country    #     for isel_dict in list_isel_dict:    #         da_subset_89 = da_89.isel(isel_dict)    #         da_subset_157 = da_157.isel(isel_dict)    extent = [ -70, -50, -40, -20]            with h5py.File(mhs_noaa19_file, "r") as f:        Tc = f['/S1/Tc'][:]  # shape: [channel, y, x]        lat = f['/S1/Latitude'][:]  # shape: [y, x]        lon = f['/S1/Longitude'][:]  # shape: [y, x]    # Select channels    da_89  = Tc[0, :, :]   # Channel 1 (e.g., 89 GHz)    da_157 = Tc[1, :, :]   # Channel 2 (e.g., 157 GHz)    # Crop by extent    mask = (lon >= extent[0]) & (lon <= extent[1]) & (lat >= extent[2]) & (lat <= extent[3])    rows, cols = np.where(mask)        min_row, max_row = rows.min(), rows.max()    min_col, max_col = cols.min(), cols.max()        da_subset_89  = da_89[min_row:max_row+1, min_col:max_col+1]    da_subset_157 = da_157[min_row:max_row+1, min_col:max_col+1]            fig, axes = plt.subplots(nrows=2, ncols=3, constrained_layout=True,figsize=[24,14])    pcm = axes[0,0].pcolormesh(lons, lats, np.sum(q, axis=0),  cmap=cmap, shading='auto')    axes[0,0].set_title('WRFOUT Qx sum for simulation')    cbar = plt.colorbar(pcm, ax=axes[0,0], shrink=1)        pcm = axes[0,1].pcolormesh(lons, lats, tb1[12,:,:],  cmap=cmaps['turbo_r'], vmin=150, vmax=300, shading='auto')    axes[0,1].set_title('RTTOVcs-TELSEM 89.0V GHz')    cbar = plt.colorbar(pcm, ax=axes[0,1], shrink=1)        #pcm = axes[1,1].pcolormesh(lons, lats, tb1[12,:,:],  cmap=cmaps['turbo_r'], vmin=150, vmax=300, shading='auto')    #axes[1,1].set_title('RTTOV-TELSEM 157V GHz')    #cbar = plt.colorbar(pcm, ax=axes[1,1], shrink=1)            pcm = axes[0,2].pcolormesh(da_subset_89['lon'].data, da_subset_89['lat'].data,                              da_subset_89.data,  cmap=cmaps['turbo_r'], vmin=150, vmax=300, shading='auto')    axes[0,2].set_title('MHS NOAA19 obs. 89.0V GHz')    cbar = plt.colorbar(pcm, ax=axes[0,2], shrink=1)        pcm = axes[1,2].pcolormesh(da_subset_157['lon'].data, da_subset_157['lat'].data,                              da_subset_157.data,  cmap=cmaps['turbo_r'], vmin=150, vmax=300, shading='auto')    axes[1,2].set_title('MHS NOAA19 obs. 157V GHz')    cbar = plt.colorbar(pcm, ax=axes[1,2], shrink=1)        for ii in range(3):        for jj in range(2):            axes[jj,ii].set_xlim([-68,-62])            axes[jj,ii].set_ylim([-36,-31])            axes[jj,ii].plot(prov[:,0],prov[:,1],color='w');             plt.show()    fig.savefig(plotpath+'/RTTOV/RTTOV_init_tests_observations'+instrument+'.png', dpi=300,transparent=False)        return#------------------------------------------------------------------------------def plot_MHSstd(lonlon, latlat, tbtb, title, plotpath, server):        # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    cmaps = GMI_colormap()     cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        plt.matplotlib.rc('font', family='serif', size = 12)    plt.rcParams['xtick.labelsize']=12    plt.rcParams['ytick.labelsize']=12              fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])    ichan_title = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']    for i in range(5):        pcm = axes[i].pcolormesh(lonlon, latlat, tbtb[i,:,:],  cmap=cmaps['turbo_r'],                                  shading='auto')        ichan_title[i]        axes[i].set_title(title+' MHS('+ichan_title[i]+' GHz)')        cbar = plt.colorbar(pcm, ax=axes[i], shrink=1)        axes[i].set_xlim([-65.5,-62]) #[-68,-62]);         axes[i].set_ylim([-34.5,-31])   #[-36,-31])        axes[i].plot(prov[:,0],prov[:,1],color='w');         axes[i].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    axes[0].set_xlabel('Longitude')    axes[0].set_ylabel('Latitude')    plt.show()    fig.savefig(plotpath+'/RTTOV/'+title+'std_init_tests.png', dpi=300,transparent=False)       for i in range(5):        axes[i].set_xlim([-67.5,-60]) #[-68,-62]);         axes[i].set_ylim([-35,-28])   #[-36,-31])    fig.savefig(plotpath+'/RTTOV/'+title+'std_init_tests_zoomout.png', dpi=300,transparent=False)           return#------------------------------------------------------------------------------def plot_MHS(lonlon, latlat, tbtb, title, plotpath, server):        # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    cmaps = GMI_colormap()     cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        plt.matplotlib.rc('font', family='serif', size = 12)    plt.rcParams['xtick.labelsize']=12    plt.rcParams['ytick.labelsize']=12              fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])    ichan_title = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']    for i in range(5):        pcm = axes[i].pcolormesh(lonlon, latlat, tbtb[i,:,:],  cmap=cmaps['turbo_r'],                                  shading='auto', vmin=200, vmax=300)        ichan_title[i]        axes[i].set_title(title+' MHS('+ichan_title[i]+' GHz)')        cbar = plt.colorbar(pcm, ax=axes[i], shrink=1)        axes[i].set_xlim([-65.5,-62]) #[-68,-62]);         axes[i].set_ylim([-34.5,-31])   #[-36,-31])        axes[i].plot(prov[:,0],prov[:,1],color='w');         axes[i].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    axes[0].set_xlabel('Longitude')    axes[0].set_ylabel('Latitude')    plt.show()    fig.savefig(plotpath+'/RTTOV/'+title+'init_tests.png', dpi=300,transparent=False)       for i in range(5):        axes[i].set_xlim([-67.5,-60]) #[-68,-62]);         axes[i].set_ylim([-35,-28])   #[-36,-31])    fig.savefig(plotpath+'/RTTOV/'+title+'init_tests_zoomout.png', dpi=300,transparent=False)           return#------------------------------------------------------------------------------def plot_MHS_colorbarlims(lonlon, latlat, tbtb, title, vminn, vmaxx, plotpath, server, exp):        # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    cmaps = GMI_colormap()     cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        plt.matplotlib.rc('font', family='serif', size = 12)    plt.rcParams['xtick.labelsize']=12    plt.rcParams['ytick.labelsize']=12              fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])    ichan_title = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']    for i in range(5):        pcm = axes[i].pcolormesh(lonlon, latlat, tbtb[i,:,:],  cmap=cmaps['turbo_r'],                                  shading='auto', vmin=vminn, vmax=vmaxx)        ichan_title[i]        axes[i].set_title(title+' MHS('+ichan_title[i]+' GHz)')        cbar = plt.colorbar(pcm, ax=axes[i], shrink=1)        axes[i].set_xlim([-65.5,-62]) #[-68,-62]);         axes[i].set_ylim([-34.5,-31])   #[-36,-31])        axes[i].plot(prov[:,0],prov[:,1],color='w');         axes[i].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    axes[0].set_xlabel('Longitude')    axes[0].set_ylabel('Latitude')    plt.show()            #fig.savefig(plotpath+'/RTTOV/'+title+'init_tests.png', dpi=300,transparent=False)       for i in range(5):        axes[i].set_xlim([-67.5,-60]) #[-68,-62]);         axes[i].set_ylim([-35,-28])   #[-36,-31])    fig.savefig(plotpath+'/RTTOV/'+title+'init_tests_GaussianMean'+exp+'.png', dpi=300,transparent=False)           return#------------------------------------------------------------------------------def check_footprint_interpsMap(lons2, lats2, indices_2d, lonlon, latlat, tbtb,                                plotpath, server, ejemplo_index):     # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    cmaps = GMI_colormap()     cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        plt.matplotlib.rc('font', family='serif', size = 12)    plt.rcParams['xtick.labelsize']=12    plt.rcParams['ytick.labelsize']=12              # Plot figure of an example of the fooprint search     fig, axes = plt.subplots(nrows=1, ncols=1, constrained_layout=True,figsize=[8,8])        iindex = ejemplo_index    plt.pcolormesh(lonlon, latlat, tbtb[2,:,:],  cmap=cmaps['turbo_r'],                                  shading='auto', vmin=200, vmax=300,                                 edgecolors='gray')    plt.scatter(lons2[indices_2d[iindex][0], indices_2d[iindex][1]],             lats2[indices_2d[iindex][0], indices_2d[iindex][1]], s=1,              marker='o', alpha=0.3, color='magenta')    plt.plot(prov[:,0],prov[:,1],color='w');     plt.xlim([-70,-60])    #[-68,-62]);     plt.ylim([-36, -30])    # plt.ylim([-34.5,-31])          #plt.xlim([-65.8,-62])    #[-68,-62]);     #plt.ylim([-34.5,-33])    # plt.ylim([-34.5,-31])      #Agrego el cuadrado con el que grafica matplotlib?     plt.contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    plt.xlabel('Longitude')    plt.ylabel('Latitude')    plt.title('Nadir simple footprint: WRF profiles inside')    fig.savefig(plotpath+'/RTTOV/SimpleNadirFootprint.png', dpi=300,transparent=False)            return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_pointdataInterp(lats, lons, tb0, da_subset, Nrlimitswath):    from matplotlib.path import Path        # rttov simualted data: point data (interpolated)     #--------------------------------------------------------------------------        # Convert 2D lat/lon grids to 1D array    lat_flat = lats.ravel()    lon_flat = lons.ravel()    tb_flat  = tb0.reshape(5,-1)    # Target is my center of MHS footprint    nlon         = (da_subset['lon'].data[:Nrlimitswath,:]).shape[0]    nlat         = (da_subset['lon'].data[:Nrlimitswath,:]).shape[1]    grid_points  = np.column_stack(( da_subset['lon'].data[:Nrlimitswath,:].ravel(),                                 da_subset['lat'].data[:Nrlimitswath,:].ravel() ))  # 2D grid for interpolation        # Prepare the array    pointInterpTB = np.zeros((5,nlon,nlat))    for i in range(5):         print('Interpolating channel Nr. '+str(i) )        outputresult = griddata( (lon_flat,lat_flat), tb_flat[i,:], grid_points, method='nearest' )         pointInterpTB[i,:,:] = outputresult.reshape(nlon,nlat)        gc.collect()      return pointInterpTB def overGaussian(lats, lons, ds, varin):            indices_circle, distances2center = mhs_simplefootprint(ds['MHS_lon'].data.ravel(), ds['MHS_lat'].data.ravel(),                                          lons.ravel(), lats.ravel())    indices_2d = [np.unravel_index(idx, lons.shape) for idx in indices_circle]                # Loop over all indices and get an average rttov tb for each MHS pixel    nlon = ds['MHS_lon'].shape[0]    nlat = ds['MHS_lon'].shape[1]     var  = np.zeros((nlon*nlat));  var[:] = np.nan        # Apply Gaussian antenna pattern to the fooprint     #--------------------------------------------------------------------------    sigma = 6.5    for iindex in range(len(ds['MHS_lon'].data.ravel())):            if np.any(varin[indices_2d[iindex][0], indices_2d[iindex][1]]) == True:                weights_, var[iindex] = gaussian_weighted_average(                 varin[indices_2d[iindex][0], indices_2d[iindex][1]], distances2center[iindex], sigma)    var = var.reshape(nlon,nlat)    return var#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_footprintVals(lats, lons, tb0, da_subset, Nrlimitswath, domain_mhs_obs,                          plotpath, server, exp_name):         # rttov simualted data: average within footprint      #--------------------------------------------------------------------------    indices_circle, distances2center = mhs_simplefootprint(da_subset['lon'].data[:Nrlimitswath,:].ravel(),                         da_subset['lat'].data[:Nrlimitswath,:].ravel(),                         lons.ravel(), lats.ravel())    indices_2d = [np.unravel_index(idx, lons.shape) for idx in indices_circle]        # Target is my center of MHS footprint    nlon         = (da_subset['lon'].data[:Nrlimitswath,:]).shape[0]    nlat         = (da_subset['lon'].data[:Nrlimitswath,:]).shape[1]        # for iindex in range(1100):    #     if len(lons[indices_2d[iindex][0], indices_2d[iindex][1]])>0:    #         fig, axes = plt.subplots(nrows=1, ncols=1, constrained_layout=True,figsize=[8,8])        #         plt.scatter(lons[indices_2d[iindex][0], indices_2d[iindex][1]],    #                     lats[indices_2d[iindex][0], indices_2d[iindex][1]], s=50,     #                     marker='o', alpha=0.5, color='magenta')    #         plt.title(str(iindex))    #         plt.xlim([-65.5,-62])    #[-68,-62]);     #         plt.ylim([-34.5,-33])    # plt.ylim([-34.5,-31])      check_footprint_interpsMap(lons, lats, indices_2d, da_subset['lon'].data[:Nrlimitswath,:],                                da_subset['lat'].data[:Nrlimitswath,:], domain_mhs_obs,                                plotpath, server, 2046)  # w/ gpm-api cut i was using 518        # Loop over all indices and get an average rttov tb for each MHS pixel    tb_footprint_mean = np.zeros((5,nlon*nlat));  tb_footprint_mean[:] = np.nan    tb_footprint_std = np.zeros((5,nlon*nlat));   tb_footprint_std[:] = np.nan    for iindex in range(len(da_subset['lat'].data[:Nrlimitswath,:].ravel())):        for ifreq in range(5):            tb_footprint_mean[ifreq,iindex] = np.nanmean(tb0[ifreq,indices_2d[iindex][0], indices_2d[iindex][1]])            tb_footprint_std[ifreq,iindex]  = np.nanstd(tb0[ifreq,indices_2d[iindex][0], indices_2d[iindex][1]])    tb_footprint_mean =  tb_footprint_mean.reshape(5,nlon,nlat)    tb_footprint_std  =  tb_footprint_std.reshape(5,nlon,nlat)        # plt.pcolormesh(da_subset['lon'].data[:Nrlimitswath,:],da_subset['lat'].data[:Nrlimitswath,:],tb_footprint_mean[0,:,:])        # I algo want min/max values within footprint    tb_footprint_min = np.zeros((5,nlon*nlat));  tb_footprint_min[:] = np.nan    tb_footprint_max = np.zeros((5,nlon*nlat));  tb_footprint_max[:] = np.nan            for iindex in range(len(da_subset['lat'].data[:Nrlimitswath,:].ravel())):        for ifreq in range(5):            if np.any(tb0[ifreq,indices_2d[iindex][0], indices_2d[iindex][1]]) == True:                tb_footprint_min[ifreq,iindex] = np.nanmin(tb0[ifreq,indices_2d[iindex][0], indices_2d[iindex][1]])                tb_footprint_max[ifreq,iindex] = np.nanmax(tb0[ifreq,indices_2d[iindex][0], indices_2d[iindex][1]])    tb_footprint_min  =  tb_footprint_min.reshape(5,nlon,nlat)    tb_footprint_max  =  tb_footprint_max.reshape(5,nlon,nlat)                          # Apply Gaussian antenna pattern to the fooprint     #--------------------------------------------------------------------------    sigma = 6.5    #    tb_footprint_gaussian = np.zeros((5,nlon*nlat));   tb_footprint_gaussian[:] = np.nan    for iindex in range(len(da_subset['lat'].data[:Nrlimitswath,:].ravel())):        for ifreq in range(5):            if np.any(tb0[ifreq,indices_2d[iindex][0], indices_2d[iindex][1]]) == True:                weights_, tb_footprint_gaussian[ifreq,iindex] = gaussian_weighted_average(                 tb0[ifreq,indices_2d[iindex][0], indices_2d[iindex][1]], distances2center[iindex], sigma)    tb_footprint_gaussian = tb_footprint_gaussian.reshape(5,nlon,nlat)        #--------------------------- figure to exemplify gaussian vs. mean     #--------------------------------------------------------------------------    # check with example index    sigma = 6.5    exampleindex = 2046    weights_, footprint_gaussian_ = gaussian_weighted_average(         tb0[0,indices_2d[exampleindex][0], indices_2d[exampleindex][1]], distances2center[exampleindex], sigma)    #    cmaps = GMI_colormap()     cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values    fig, axes = plt.subplots(nrows=2, ncols=2, constrained_layout=True,figsize=[15,15])        axes[0,0].plot( tb0[0,indices_2d[exampleindex][0], indices_2d[exampleindex][1]], '-k', label='wrf resolution')    axes[0,0].hlines( np.nanmean(tb0[0,indices_2d[exampleindex][0], indices_2d[exampleindex][1]]), 0, 520, color='r', label='footprint average')    axes[0,0].hlines( footprint_gaussian_, 0, 520, color='darkblue', label='gaussian')    #    axes[0,0].legend()    axes[0,0].set_title('rttov inside footprint')    pcm = axes[1,0].scatter(lons[indices_2d[exampleindex][0], indices_2d[exampleindex][1]],             lats[indices_2d[exampleindex][0], indices_2d[exampleindex][1]],              c=tb0[0,indices_2d[exampleindex][0], indices_2d[exampleindex][1]], s=100, cmap=cmaps['turbo_r'])    plt.colorbar(pcm, ax=axes[1,0])    axes[1,0].set_title('CH1 rttov simulation (K)')    pcm = axes[0,1].scatter(lons[indices_2d[exampleindex][0], indices_2d[exampleindex][1]],             lats[indices_2d[exampleindex][0], indices_2d[exampleindex][1]],              c= distances2center[exampleindex], s=100, cmap=cmaps['turbo_r'])        plt.colorbar(pcm, ax=axes[0,1])    axes[0,1].set_title('Distance to footprint center (km)')    #    axes[1,1].scatter(lons[indices_2d[exampleindex][0], indices_2d[exampleindex][1]],             lats[indices_2d[exampleindex][0], indices_2d[exampleindex][1]],              c=weights_, s=100, cmap=cmaps['turbo_r'])        plt.colorbar(pcm, ax=axes[1,1])    axes[1,1].set_title('Weights for sigma: '+ str(sigma))    #    plt.suptitle('Single footprint example ('+exp_name+')')        fig.savefig(plotpath+'/RTTOV/GaussianApplyShow_examplefootprint_2046'+exp_name+'.png', dpi=300,transparent=False)    #plt.close()        return tb_footprint_mean, tb_footprint_std, tb_footprint_gaussian, tb_footprint_min, tb_footprint_max#------------------------------------------------------------------------------#------------------------------------------------------------------------------def MHS_cs_sims(lons, lats, q, tb0, plotpath, server):     # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    mhs_noaa19_file = mhs_noaa19_dir+'1C.NOAA19.MHS.XCAL2021-V.20181110-S201428-E215628.050287.V07A.HDF5'    extent = [ -70, -50, -40, -20]    #------------------------------------------------------------------------------    # Observed. Satellite MW data    #    #extent        = get_continent_extent("South America")    #-----    # for cnrm - cannot install gpm-api in yakaira:     #extent         = get_geographic_extent_around_point(lon=-64.2,lat=-31.4,distance=400_000)        #ds              = gpm.open_granule(mhs_noaa19_file)       #list_isel_dict  = ds.gpm.get_crop_slices_by_extent(extent)    #for isel_dict in list_isel_dict:    #    da_subset = ds.isel(isel_dict)    #Nrlimitswath   = 30    #domain_mhs_obs = (da_subset['Tc'].data).transpose(2,0,1)    #domain_mhs_obs = domain_mhs_obs[:,:Nrlimitswath,:].copy()    #-----    Nrlimitswath   = 30    with h5py.File(mhs_noaa19_file, "r") as f:        Tc = f['/S1/Tc'][:,:,:]  # shape: [channel, y, x]        lat = f['/S1/Latitude'][:,:]  # shape: [y, x]        lon = f['/S1/Longitude'][:,:]  # shape: [y, x]            # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)    # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[row_min:row_max+1, :, :]        lat_crop = lat[row_min:row_max+1, :]        lon_crop = lon[row_min:row_max+1, :]    else:        raise ValueError("No data points found within the specified extent.")        lat_cropt = lat_crop.T    lon_cropt = lon_crop.T    Tc_cropt  = Tc_crop.T    # Create labeled DataArray    da_subset = xr.DataArray(        Tc_cropt,        dims=("nchan","x", "y"),        coords={            "lat": (("x", "y"), lat_cropt),            "lon": (("x", "y"), lon_cropt),            },        name="Tc",        attrs={            "units": "K",            "description": "Brightness temperature at 89 GHz",            "source": "NOAA MHS"            })            #------------------------------------------------------------------------------    domain_mhs_obs = da_subset.data    domain_mhs_obs = domain_mhs_obs[:,:Nrlimitswath,:].copy()            # 1) MHS point output    #--------------------------------------------------------------------------    plot_MHS(lons, lats, tb0, 'RTTOV_cs_', plotpath, server)        # 2) MHS real observations    #--------------------------------------------------------------------------        plot_MHS(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                              domain_mhs_obs, 'MHS_realobs_', plotpath, server)        # 3) rttov simualted data: point data (interpolated)     #--------------------------------------------------------------------------    pointInterpTB = get_pointdataInterp(lats, lons, tb0, da_subset, Nrlimitswath)     plot_MHS(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                              pointInterpTB, 'rttov_cs_pointInterp', plotpath, server)        # 4) rttov simualted data: average within footprint and Gaussian antenna pattern    #--------------------------------------------------------------------------        tb_footprint_mean, tb_footprint_std, tb_footprint_gaussian, tb_footprint_min, tb_footprint_max = get_footprintVals(lats, lons, tb0, da_subset,                         Nrlimitswath, domain_mhs_obs, plotpath, server, 'cs')     plot_MHS(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                              tb_footprint_mean, 'rttov_cs_Footprintmean', plotpath, server)        plot_MHS(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                              tb_footprint_gaussian, 'rttov_cs_Gaussianantenna', plotpath, server)      # Test difference between gaussian and average?     # check this sigma value? does it make sense?     plot_MHS_colorbarlims(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                          tb_footprint_gaussian-tb_footprint_mean, 'rttov_gaussiandiffmean', -1, 1,                           plotpath, server, 'cs')                # Fix to keep the same domain for all pre-processing options:    for i in range(5):         test = pointInterpTB[i,:,:].copy()        outputresult4nan = tb_footprint_gaussian[i,:,:].copy()        test[np.isnan(outputresult4nan)] = np.nan        pointInterpTB[i,:,:] = test     tbound = np.column_stack( (lons[0,:], lats[0,:]) )    rbound = np.column_stack( (lons[:,-1], lats[:,-1]) )    bbound = np.column_stack( (lons[-1,::-1], lats[-1,::-1]) )    lbound = np.column_stack( (lons[::-1,0], lats[::-1, 0]) )    polygon_lonlat = np.concatenate([ tbound, rbound, bbound, lbound])    # Build path    wrf_path = Path(polygon_lonlat)    # Flatten grid    lons_mhs_obs = da_subset['lon'].data[:Nrlimitswath,:]    lats_mhs_obs = da_subset['lat'].data[:Nrlimitswath,:]    points       = np.column_stack( (lons_mhs_obs.ravel(), lats_mhs_obs.ravel() ) )    inside_      = wrf_path.contains_points(points).reshape(lons_mhs_obs.shape)     tb_mhs_obs_masked = np.where(inside_[None,:,:], domain_mhs_obs, np.nan )                     # Organizar todo en un dataframe:    ds = xr.Dataset(        {        "rttov_cs": (["rttov","lat","lon"], tb0),        "rttov_cs_footprintmean": (["rttov","lat2","lon2"], tb_footprint_mean),        "rttov_cs_footprintstd":  (["rttov","lat2","lon2"], tb_footprint_std),                "rttov_cs_footprintmin":  (["rttov","lat2","lon2"], tb_footprint_min),                "rttov_cs_footprintmax":  (["rttov","lat2","lon2"], tb_footprint_max),                "rttov_cs_pointInterpNearest":   (["rttov","lat2","lon2"], pointInterpTB),        "rttov_cs_Gaussianantennasigma_":   (["rttov","lat2","lon2"], tb_footprint_gaussian),        "wrf_lat":                (["lat","lon"], lats),        "wrf_lon":                (["lat","lon"], lons),         "MHs_domain_obs":         (["obs","lat2","lon2"], tb_mhs_obs_masked),         "MHS_lon":           (["lat2","lon2"], da_subset['lon'].data[:Nrlimitswath,:]),        "MHS_lat":           (["lat2","lon2"], da_subset['lat'].data[:Nrlimitswath,:])        })        return ds#------------------------------------------------------------------------------#------------------------------------------------------------------------------def MHS_as_sims(lons, lats, tb0, plotpath, server, expname):     # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'        mhs_noaa19_file = mhs_noaa19_dir+'1C.NOAA19.MHS.XCAL2021-V.20181110-S201428-E215628.050287.V07A.HDF5'    extent = [ -70, -50, -40, -20]    #------------------------------------------------------------------------------    # Observed. Satellite MW data    #    #extent        = get_continent_extent("South America")    #-----    # for cnrm - cannot install gpm-api in yakaira:     #extent         = get_geographic_extent_around_point(lon=-64.2,lat=-31.4,distance=400_000)        #ds              = gpm.open_granule(mhs_noaa19_file)       #list_isel_dict  = ds.gpm.get_crop_slices_by_extent(extent)    #for isel_dict in list_isel_dict:    #    da_subset = ds.isel(isel_dict)    #Nrlimitswath   = 30    #domain_mhs_obs = (da_subset['Tc'].data).transpose(2,0,1)    #domain_mhs_obs = domain_mhs_obs[:,:Nrlimitswath,:].copy()    #-----    Nrlimitswath   = 30    with h5py.File(mhs_noaa19_file, "r") as f:        Tc = f['/S1/Tc'][:,:,:]  # shape: [channel, y, x]        lat = f['/S1/Latitude'][:,:]  # shape: [y, x]        lon = f['/S1/Longitude'][:,:]  # shape: [y, x]            # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)    # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[row_min:row_max+1, :, :]        lat_crop = lat[row_min:row_max+1, :]        lon_crop = lon[row_min:row_max+1, :]    else:        raise ValueError("No data points found within the specified extent.")        lat_cropt = lat_crop.T    lon_cropt = lon_crop.T    Tc_cropt  = Tc_crop.T    # Create labeled DataArray    da_subset = xr.DataArray(        Tc_cropt,        dims=("nchan","x", "y"),        coords={            "lat": (("x", "y"), lat_cropt),            "lon": (("x", "y"), lon_cropt),            },        name="Tc",        attrs={            "units": "K",            "description": "Brightness temperature at 89 GHz",            "source": "NOAA MHS"            })            #-----------------------------------------------------------------------------    domain_mhs_obs = da_subset.data    domain_mhs_obs = domain_mhs_obs[:,:Nrlimitswath,:].copy()    # 1) MHS point output    #--------------------------------------------------------------------------    plot_MHS(lons, lats, tb0, 'RTTOV_as_'+expname, plotpath, server)        breakpoint()        # 3) rttov simualted data: point data (interpolated)     #--------------------------------------------------------------------------    pointInterpTB = get_pointdataInterp(lats, lons, tb0, da_subset, Nrlimitswath)     plot_MHS(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                              pointInterpTB, 'rttov_as_pointInterp', plotpath, server)        # 4) rttov simualted data: average within footprint and Gaussian antenna pattern    #--------------------------------------------------------------------------        tb_footprint_mean, tb_footprint_std, tb_footprint_gaussian,tb_footprint_min, tb_footprint_max = get_footprintVals(lats, lons, tb0, da_subset,                         Nrlimitswath, domain_mhs_obs, plotpath, server, 'as_test')     plot_MHS(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                              tb_footprint_mean, 'rttov_as_Footprintmean', plotpath, server)        plot_MHS(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                              tb_footprint_gaussian, 'rttov_as_Gaussianantenna', plotpath, server)      # Test difference between gaussian and average?     # check this sigma value? does it make sense?     plot_MHS_colorbarlims(da_subset['lon'].data[:Nrlimitswath,:], da_subset['lat'].data[:Nrlimitswath,:],                          tb_footprint_gaussian-tb_footprint_mean, 'rttov_gaussiandiffmean', -1, 1,                           plotpath, server, 'as')           # Fix to keep the same domain for all pre-processing options:    for i in range(5):         test = pointInterpTB[i,:,:].copy()        outputresult4nan = tb_footprint_gaussian[i,:,:].copy()        test[np.isnan(outputresult4nan)] = np.nan        pointInterpTB[i,:,:] = test     tbound = np.column_stack( (lons[0,:], lats[0,:]) )    rbound = np.column_stack( (lons[:,-1], lats[:,-1]) )    bbound = np.column_stack( (lons[-1,::-1], lats[-1,::-1]) )    lbound = np.column_stack( (lons[::-1,0], lats[::-1, 0]) )    polygon_lonlat = np.concatenate([ tbound, rbound, bbound, lbound])    # Build path    wrf_path = Path(polygon_lonlat)        # Flatten grid    lons_mhs_obs = da_subset['lon'].data[:Nrlimitswath,:]    lats_mhs_obs = da_subset['lat'].data[:Nrlimitswath,:]    points       = np.column_stack( (lons_mhs_obs.ravel(), lats_mhs_obs.ravel() ) )    inside_      = wrf_path.contains_points(points).reshape(lons_mhs_obs.shape)     tb_mhs_obs_masked = np.where(inside_[None,:,:], domain_mhs_obs, np.nan )         # Organizar todo en un dataframe:    ds = xr.Dataset(        {        "rttov_as": (["rttov","lat","lon"], tb0),        "rttov_as_footprintmean": (["rttov","lat2","lon2"], tb_footprint_mean),        "rttov_as_footprintstd":  (["rttov","lat2","lon2"], tb_footprint_std),                "rttov_as_footprintmin":  (["rttov","lat2","lon2"], tb_footprint_min),                "rttov_as_footprintmax":  (["rttov","lat2","lon2"], tb_footprint_max),                "rttov_as_pointInterpNearest":   (["rttov","lat2","lon2"], pointInterpTB),        "rttov_as_Gaussianantennasigma_":   (["rttov","lat2","lon2"], tb_footprint_gaussian),        "wrf_lat":                (["lat","lon"], lats),        "wrf_lon":                (["lat","lon"], lons),         "MHs_domain_obs":         (["obs","lat2","lon2"], tb_mhs_obs_masked),         "MHS_lon":           (["lat2","lon2"], da_subset['lon'].data[:Nrlimitswath,:]),        "MHS_lat":           (["lat2","lon2"], da_subset['lat'].data[:Nrlimitswath,:])        })        return ds#------------------------------------------------------------------------------#------------------------------------------------------------------------------   def regrid2D_toMHSgrid(lats, lons, ds, VAR):        # Interp. WRF variables to the MHS lat/lon grid     lat_flat    = lats.ravel()    lon_flat    = lons.ravel()    grid_points = np.column_stack(( ds['MHS_lon'].data.ravel(), ds['MHS_lat'].data.ravel() ))  # 2D grid for interpolation                interpVAR   = griddata( (lon_flat,lat_flat), VAR, grid_points, method='nearest' )                     nlon         = (ds['MHS_lon']).shape[0]    nlat         = (ds['MHS_lon']).shape[1]        return interpVAR.reshape(nlon,nlat)#------------------------------------------------------------------------------#------------------------------------------------------------------------------   def average_over_footprint(lats, lons, ds, varin):    indices_circle, _ = mhs_simplefootprint(ds['MHS_lon'].data.ravel(), ds['MHS_lat'].data.ravel(),                                          lons.ravel(), lats.ravel())    indices_2d = [np.unravel_index(idx, lons.shape) for idx in indices_circle]            # Loop over all indices and get an average rttov tb for each MHS pixel    nlon = ds['MHS_lon'].shape[0]    nlat = ds['MHS_lon'].shape[1]     var  = np.zeros((nlon*nlat));  var[:] = np.nan    varmin  = np.zeros((nlon*nlat));  varmin[:] = np.nan    varmax  = np.zeros((nlon*nlat));  varmax[:] = np.nan    varstd  = np.zeros((nlon*nlat));  varstd[:] = np.nan            for iindex in range(len(ds['MHS_lon'].data.ravel())):        var[iindex]    = np.nanmean(varin[indices_2d[iindex][0], indices_2d[iindex][1]])        varstd[iindex] = np.nanstd(varin[indices_2d[iindex][0], indices_2d[iindex][1]])        if np.any(varin[indices_2d[iindex][0], indices_2d[iindex][1]]) == True:            varmin[iindex] = np.nanmin(varin[indices_2d[iindex][0], indices_2d[iindex][1]])            varmax[iindex] = np.nanmax(varin[indices_2d[iindex][0], indices_2d[iindex][1]])    return var.reshape(nlon,nlat), varmin.reshape(nlon,nlat), varmax.reshape(nlon,nlat), varstd.reshape(nlon,nlat)#------------------------------------------------------------------------------#------------------------------------------------------------------------------ def plot_test_qxints(dwrf, ds, lats, lons):              prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')        # 1) Point lat/lon     var = np.ma.masked_less_equal(dwrf['WRF_intTot'], 1)     fig, axes = plt.subplots(nrows=1, ncols=1, constrained_layout=True,figsize=[8,8])        plt.pcolormesh(lons, lats, var,  cmap=plt.cm.viridis, shading='auto'); plt.colorbar()    plt.xlim([-65.5,-62]) #[-68,-62]);     plt.ylim([-34.5,-31])   #[-36,-31])    plt.plot(prov[:,0],prov[:,1],color='w')    # 2) Average    var = np.ma.masked_less_equal(dwrf['MHS_intTot'], 1)     fig, axes = plt.subplots(nrows=1, ncols=1, constrained_layout=True,figsize=[8,8])        plt.pcolormesh(ds['MHS_lon'], ds['MHS_lat'], var,  cmap=plt.cm.viridis, shading='auto'); plt.colorbar()    plt.xlim([-65.5,-62]) #[-68,-62]);     plt.ylim([-34.5,-31])   #[-36,-31])    plt.plot(prov[:,0],prov[:,1],color='w')            # 3) Footprint mean    var = np.ma.masked_less_equal(dwrf['MHSfootprintmean_intTot'], 1)     fig, axes = plt.subplots(nrows=1, ncols=1, constrained_layout=True,figsize=[8,8])        plt.pcolormesh(ds['MHS_lon'], ds['MHS_lat'], var,  cmap=plt.cm.viridis, shading='auto'); plt.colorbar()    plt.xlim([-65.5,-62]) #[-68,-62]);     plt.ylim([-34.5,-31])   #[-36,-31])    plt.plot(prov[:,0],prov[:,1],color='w')              return#------------------------------------------------------------------------------#------------------------------------------------------------------------------ def gaussian_weighted_average(values, distances, sigma):        # Remove nans?    valid_mask = ~np.isnan(values)    values     = values[valid_mask]    distances  = distances[valid_mask]        # Compute gaussian weights    weights = np.exp(- (distances**2) / (2*sigma**2))        # Normalize    weights /= np.sum(weights)        # Compute weighted sum    weighted_average = np.sum(values*weights)        return weights, weighted_average    #------------------------------------------------------------------------------#------------------------------------------------------------------------------ def simple_histograms(data_nc, title, filename, plotpath):            #----- SIMPLE PLOTS for stats (ALL)        #titles_axes = ['89.0', '157.0', '183.311$\pm$3', '183.311$\pm$1', '190.311']        titles_axes = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']                kwargs  = dict({'element':'step', 'stat':"probability", 'bins':np.arange(200,320,2), 'alpha':0.5})        #kwargs  = dict({'kde':"True",  'element':'step', 'stat':"percent", 'bins':np.arange(200,320,1), 'alpha':0.5})        kde_kws = dict({'bw_adjust': 0.1})                 fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])            for i in range(5):            sns.histplot( data=data_nc['MHs_domain_obs'][i,:,:].data.flatten(), ax=axes[i],                            color='darkblue', label='MHS', kde_kws=kde_kws, **kwargs)             sns.histplot( data=data_nc['rttov_cs_footprintmean'][i,:,:].data.flatten(), ax=axes[i],                            color='darkred', label='rttov_cs (footprint mean)', kde_kws=kde_kws, **kwargs)             sns.histplot( data=data_nc['rttov_cs'][i,:,:].data.flatten(), ax=axes[i],                            color='red', label='rttov_cs (point model grid)', kde_kws=kde_kws, **kwargs)            sns.histplot( data=data_nc['rttov_cs_pointInterpNearest'][i,:,:].data.flatten(), ax=axes[i],                            color='magenta', label='rttov_cs (interp obs grid)',  kde_kws=kde_kws, **kwargs)            sns.histplot( data=data_nc['rttov_cs_Gaussianantennasigma_'][i,:,:].data.flatten(), ax=axes[i],                            color='darkgreen', label='rttov_cs (Gaussian antenna pattern)',  kde_kws=kde_kws, **kwargs)            axes[i].set_title(titles_axes[i]+' GHz')            axes[i].set_xlim([200,320])        axes[0].legend(loc='upper left')        axes[0].set_xlabel('Brightness Temperature (K)')        plt.suptitle('All pixels: ' + title )        #plt.close()        fig.savefig(plotpath+'/RTTOV/'+filename+'.png', dpi=300,transparent=False)                     return#------------------------------------------------------------------------------#------------------------------------------------------------------------------ def simple_histograms_as(data_nc, title, filename, plotpath):            #----- SIMPLE PLOTS for stats (ALL)        #titles_axes = ['89.0', '157.0', '183.311$\pm$3', '183.311$\pm$1', '190.311']        titles_axes = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']                kwargs  = dict({'element':'step', 'stat':"probability", 'bins':np.arange(50,320,2), 'alpha':0.5})        #kwargs  = dict({'kde':"True",  'element':'step', 'stat':"percent", 'bins':np.arange(200,320,1), 'alpha':0.5})        kde_kws = dict({'bw_adjust': 0.1})                 fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])            for i in range(5):            sns.histplot( data=data_nc['MHs_domain_obs'][i,:,:].data.flatten(), ax=axes[i],                            color='darkblue', label='MHS', kde_kws=kde_kws, **kwargs)             sns.histplot( data=data_nc['rttov_as_footprintmean'][i,:,:].data.flatten(), ax=axes[i],                            color='darkred', label='rttov_as (footprint mean)', kde_kws=kde_kws, **kwargs)             sns.histplot( data=data_nc['rttov_as'][i,:,:].data.flatten(), ax=axes[i],                            color='red', label='rttov_as (point model grid)', kde_kws=kde_kws, **kwargs)            sns.histplot( data=data_nc['rttov_as_pointInterpNearest'][i,:,:].data.flatten(), ax=axes[i],                            color='magenta', label='rttov_as (interp obs grid)',  kde_kws=kde_kws, **kwargs)            sns.histplot( data=data_nc['rttov_as_Gaussianantennasigma_'][i,:,:].data.flatten(), ax=axes[i],                            color='darkgreen', label='rttov_as (Gaussian antenna pattern)',  kde_kws=kde_kws, **kwargs)            axes[i].set_title(titles_axes[i]+' GHz')            axes[i].set_xlim([50,320])        axes[0].legend(loc='upper left')        axes[0].set_xlabel('Brightness Temperature (K)')        plt.suptitle('All pixels: ' + title )        #plt.close()        fig.savefig(plotpath+'/RTTOV/'+filename+'.png', dpi=300,transparent=False)                     return    #------------------------------------------------------------------------------#------------------------------------------------------------------------------ def simple_footprint_Std_histograms(data_nc, title, filename, plotpath):            #----- SIMPLE PLOTS for stats (ALL)        #titles_axes = ['89.0', '157.0', '183.311$\pm$3', '183.311$\pm$1', '190.311']        titles_axes = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']                kwargs  = dict({'bins':np.arange(0,10,1)})        #kwargs  = dict({'kde':"True",  'element':'step', 'stat':"percent", 'bins':np.arange(200,320,1), 'alpha':0.5})        #kde_kws = dict({'bw_adjust': 0.1})                 fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])            for i in range(5):            sns.histplot( data=data_nc['rttov_cs_footprintstd'][i,:,:].data.flatten(), ax=axes[i],                            color='darkblue',   **kwargs)             axes[i].set_title(titles_axes[i]+' GHz')            #axes[i].set_xlim([200,320])        #axes[0].legend(loc='upper left')        axes[0].set_xlabel('Footprint std')        plt.suptitle('All pixels: ' + title )        #plt.close()        #fig.savefig(plotpath+'/RTTOV/'+filename+'.png', dpi=300,transparent=False)                     return                           #------------------------------------------------------------------------------#------------------------------------------------------------------------------ def simple_footprint_allsky_Std_histograms(data_nc, title, filename, plotpath):            #----- SIMPLE PLOTS for stats (ALL)        #titles_axes = ['89.0', '157.0', '183.311$\pm$3', '183.311$\pm$1', '190.311']        titles_axes = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']                kwargs  = dict({'bins':np.arange(0,30,1)})        #kwargs  = dict({'kde':"True",  'element':'step', 'stat':"percent", 'bins':np.arange(200,320,1), 'alpha':0.5})        #kde_kws = dict({'bw_adjust': 0.1})                 fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])            for i in range(5):            sns.histplot( data=data_nc['rttov_as_footprintstd'][i,:,:].data.flatten(), ax=axes[i],                            color='darkblue',   **kwargs)             axes[i].set_title(titles_axes[i]+' GHz')            #axes[i].set_xlim([200,320])        #axes[0].legend(loc='upper left')        axes[0].set_xlabel('Footprint std')        plt.suptitle('All pixels: ' + title )        #plt.close()        #fig.savefig(plotpath+'/RTTOV/'+filename+'.png', dpi=300,transparent=False)                     return     #------------------------------------------------------------------------------#------------------------------------------------------------------------------def calcStats(data, nchan, mask):    dsmean = []    dsmin = []    dsmax = []    dsstd = []            for i in np.arange(nchan):        dsmean.append( np.nanmean(np.ma.array( data[i,:,:], mask=mask.mask )))        dsmin.append( np.nanmin(np.ma.array( data[i,:,:], mask=mask.mask )))        dsmax.append( np.nanmax(np.ma.array( data[i,:,:], mask=mask.mask )))        dsstd.append( np.nanstd(np.ma.array( data[i,:,:], mask=mask.mask )))    return dsmean, dsstd, dsmin, dsmax#------------------------------------------------------------------------------#------------------------------------------------------------------------------def calcStats_nomask(data, nchan):    dsmean = []    dsmin = []    dsmax = []    dsstd = []            for i in np.arange(nchan):        dsmean.append( np.nanmean(np.ma.array( data[i,:,:])))        dsmin.append( np.nanmin(np.ma.array( data[i,:,:])))        dsmax.append( np.nanmax(np.ma.array( data[i,:,:])))        dsstd.append( np.nanstd(np.ma.array( data[i,:,:])))    return dsmean, dsstd, dsmin, dsmax#------------------------------------------------------------------------------#------------------------------------------------------------------------------ def simple_histograms_cloudmasks(data_nc, cloudmasks, title, filename, plotpath):            #----- SIMPLE PLOTS for stats (ALL)        titles_axes = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']        kwargs  = dict({'element':'step', 'stat':"probability", 'bins':np.arange(200,320,2), 'alpha':0.5})        #kwargs  = dict({'kde':"True",  'element':'step', 'stat':"percent", 'bins':np.arange(200,320,1), 'alpha':0.5})        kde_kws = dict({'bw_adjust': 0.1})                 fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])            for i in range(5):            var = np.ma.array( data_nc['MHs_domain_obs'][i,:,:].data, mask=cloudmasks['roughOBS'].mask)             sns.histplot( data=var.flatten(), ax=axes[i],                            color='darkblue', label='MHS', kde_kws=kde_kws, **kwargs)             #            var = np.ma.array( data_nc['rttov_cs_footprintmean'][i,:,:].data, mask=cloudmasks['footprintmean'].mask)             sns.histplot( data=var.flatten(), ax=axes[i],                            color='darkred', label='rttov_cs (footprint mean)', kde_kws=kde_kws, **kwargs)             #            var = np.ma.array( data_nc['rttov_cs'][i,:,:].data, mask=cloudmasks['WRFgrid'].mask)                         sns.histplot( data=var.flatten(), ax=axes[i],                            color='red', label='rttov_cs (point model grid)', kde_kws=kde_kws, **kwargs)            #            var = np.ma.array( data_nc['rttov_cs_pointInterpNearest'][i,:,:].data, mask=cloudmasks['MHSinterp'].mask)                         sns.histplot( data=var.flatten(), ax=axes[i],                            color='magenta', label='rttov_cs (interp obs grid)',  kde_kws=kde_kws, **kwargs)            #            var = np.ma.array( data_nc['rttov_cs_Gaussianantennasigma_'][i,:,:].data, mask=cloudmasks['footprintGaussian'].mask)                         sns.histplot( data=var.flatten(), ax=axes[i],                            color='darkgreen', label='rttov_cs (Gaussian antenna pattern)',  kde_kws=kde_kws, **kwargs)            axes[i].set_title(titles_axes[i]+' GHz')            axes[i].set_xlim([200,320])                axes[0].legend(loc='upper left')        axes[0].set_xlabel('Brightness Temperature (K)')        plt.suptitle('All pixels: ' + title )        #plt.close()        fig.savefig(plotpath+'/RTTOV/'+filename+'.png', dpi=300,transparent=False)                     return    #------------------------------------------------------------------------------#------------------------------------------------------------------------------def normalized_dThistograms(d_cs, d_asTest, title, filename, plotpath):        #----- SIMPLE PLOTS for stats (ALL)    #titles_axes = ['89.0', '157.0', '183.311$\pm$3', '183.311$\pm$1', '190.311']    titles_axes = ['89.0', '157.0', '183.311$\pm$1', '183.311$\pm$3', '190.311']            kwargs  = dict({'element':'step','stat':'perecent' , 'bins':np.arange(5,320,5),                     'fill':False, 'log_scale':(False,True), 'common_norm':True})        fig, axes = plt.subplots(nrows=1, ncols=5, constrained_layout=True,figsize=[30,7])        for i in range(5):        sns.histplot( data=d_asTest['MHs_domain_obs'][i,:,:].data.flatten(), ax=axes[i],                        color='darkblue', label='MHS',  **kwargs)         sns.histplot( data=d_asTest['rttov_as_footprintmean'][i,:,:].data.flatten(), ax=axes[i],                        color='darkred', label='rttov_as (footprint mean)', **kwargs)         sns.histplot( data=d_asTest['rttov_as'][i,:,:].data.flatten(), ax=axes[i],                        color='red', label='rttov_as (point model grid)',  **kwargs)        sns.histplot( data=d_asTest['rttov_as_pointInterpNearest'][i,:,:].data.flatten(), ax=axes[i],                        color='magenta', label='rttov_as (interp obs grid)',   **kwargs)        sns.histplot( data=d_asTest['rttov_as_Gaussianantennasigma_'][i,:,:].data.flatten(), ax=axes[i],                        color='darkgreen', label='rttov_as (Gaussian antenna pattern)',  **kwargs)        axes[i].set_title(titles_axes[i]+' GHz')        #axes[i].set_xlim([200,320])    axes[0].legend(loc='upper left')    axes[0].set_xlabel('Brightness Temperature (K)')    #plt.suptitle('All pixels: ' + title )    #plt.close()    #fig.savefig(plotpath+'/RTTOV/'+filename+'.png', dpi=300,transparent=False)             return#------------------------------------------------------------------------------#------------------------------------------------------------------------------ def plot1ststats_cs(EXPsLabel, d_cs, cldmasks, nchan, colorExp, plotpath, filename):        dsmean = np.zeros( (nchan, nchan) )    dsstd  = np.zeros( (nchan, nchan) )    dsmin  = np.zeros( (nchan, nchan) )    dsmax  = np.zeros( (nchan, nchan) )        xlabel   = ['89.0 GHz', '157.0 GHz', '183.311$\pm$1 GHz', '183.311$\pm$3 GHz', '190.311 GHz']    EXPs     = ['MHs_domain_obs', 'rttov_cs_footprintmean', 'rttov_cs', 'rttov_cs_pointInterpNearest', 'rttov_cs_Gaussianantennasigma_']    ii = 0    for EXP in EXPs:            dsmean[ii,:], dsstd[ii,:], dsmin[ii,:], dsmax[ii,:] = calcStats(d_cs[EXP], nchan, cldmasks[ii])         ii=ii+1            fig, axes = plt.subplots(nrows=3, ncols=1, constrained_layout=True,figsize=[7,12])        ii = 0            for EXP in EXPs:           axes[0].plot(np.nan, np.nan, linestyle='-', marker='o', color=colorExp[ii], label=EXPsLabel[ii])        ii=ii+1    axes[0].legend(loc='lower left')        ii=0    for EXP in EXPs:           axes[0].plot(np.arange(1,6,1), dsmean[ii], linestyle='-', marker='o', color=colorExp[ii], linewidth=1.2, label='mean')        axes[1].plot(np.arange(1,6,1), dsmin[ii], linestyle='-', marker='x', color=colorExp[ii], linewidth=1.2, label='min')        axes[1].plot(np.arange(1,6,1), dsmax[ii], linestyle='-', marker='x', color=colorExp[ii], linewidth=1.2, label='max')        axes[2].plot(np.arange(1,6,1), dsstd[ii], linestyle='-', marker='o', color=colorExp[ii], linewidth=1.2, label='std')                    ii=ii+1        axes[0].set_xticks(np.arange(1,6,1), [])    axes[1].set_xticks(np.arange(1,6,1), [])    axes[2].set_xticks(np.arange(1,6,1), xlabel, rotation=30)    axes[0].set_title('Mean')    axes[1].set_title('Min/Max')    axes[2].set_title('Std.')    axes[0].grid(True)    axes[1].grid(True)    axes[2].grid(True)    plt.suptitle('rttov clearsky w/ cloudmask')        fig.savefig(plotpath+'/RTTOV/'+filename+'.png', dpi=300,transparent=False)             return