import Tools2Plot as T2Pimport seaborn as sns import numpy as npimport xarray as xrfrom config import config_foldersimport sysimport matplotlib.pyplot as pltimport netCDF4 as ncplt.matplotlib.rc('font', family='serif', size = 16)plt.rcParams['xtick.labelsize']=16plt.rcParams['ytick.labelsize']=16  #------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain(extent, d_cs, Tc):        lon = d_cs['wrf_lon'].data    lat = d_cs['wrf_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[:, row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")            return Tc_crop#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain2d(extent, d_cs, var2d):        lon = d_cs['wrf_lon'].data    lat = d_cs['wrf_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        var2d_crop = var2d[row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")        return var2d_crop#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain2d_gaussian(extent, d_cs, var2d):        lon = d_cs['MHS_lon'].data    lat = d_cs['MHS_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        var2d_crop = var2d[row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")    return var2d_crop[2:,:]#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_2snowsample(extent, isnow_ranges, d_cs, tb_rttov):        var_cut    = []    for isnow in range(isnow_ranges):        var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,0,:,:,:])        var_cut.append(var_cut1)          var_cut = np.array(var_cut)                return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain_gaussian(extent, d_cs, Tc):        lon = d_cs['MHS_lon'].data    lat = d_cs['MHS_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[:, row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")        return Tc_crop[:,2:,:]#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu_partial(extent, d_cs, tb_rttov):        # use extent to limit     var_cut    = []    for isnow in range(2):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu_gaus_partial(extent, d_cs, tb_rttov):        var_cut    = []    for isnow in range(2):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain_gaussian(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu(extent, d_cs, tb_rttov):        # use extent to limit     var_cut    = []    for isnow in range(11):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu_gaus(extent, d_cs, tb_rttov):        var_cut    = []    for isnow in range(11):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain_gaussian(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_grau(extent, d_cs, tb_rttov):        isnow_ranges = 11    tb_rttov = np.expand_dims(tb_rttov, axis=1)    var_cut    = []    for isnow in range(isnow_ranges):        var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,0,:,:,:])        var_cut.append(var_cut1)          var_cut = np.array(var_cut)                return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_graugaus(extent, d_cs, tb_rttov):        tb_rttov = np.expand_dims(tb_rttov, axis=1)        isnow_ranges = 11        var_cut    = []    for isnow in range(isnow_ranges):        var_cut1 = get_maskedDomain_gaussian(extent, d_cs,  tb_rttov[isnow,0,:,:,:])        var_cut.append(var_cut1)          var_cut = np.array(var_cut)                return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liu_grausp_experiments_andcut(experiment, processedFolder):            #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for i in range(11):        expname     = experiment+str(i)+'grausp'+'.nc'        d_grausp    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        tb_as.append( d_grausp['rttov_as'].values )        tb_as_gaus.append( d_grausp['rttov_as_Gaussianantennasigma_'].values )        tb_as_mean.append( d_grausp['rttov_as_footprintmean'].values )        tb_as_interp.append( d_grausp['rttov_as_pointInterpNearest'].values )        dtb_as.append( (d_grausp['rttov_as'].values) - tb_cs )              dtb_as_gaus.append( (d_grausp['rttov_as_Gaussianantennasigma_'].values)-tb_cs_gaus)        dtb_as_mean.append( (d_grausp['rttov_as_footprintmean'].values)-tb_cs_mean)        dtb_as_interp.append( (d_grausp['rttov_as_pointInterpNearest'].values)-tb_cs_interp)          tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            #WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     #cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)             rttov_as =dict({'rttov_as':          cut_extent_grau(extent, d_cs, tb_as),                     'rttov_as_Gaussian': cut_extent_graugaus(extent, d_cs, tb_as_gaus),                     'rttov_as_mean':     cut_extent_graugaus(extent, d_cs, tb_as_mean),                    'rttov_as_Interp':   cut_extent_graugaus(extent, d_cs, tb_as_interp),                    'delta_rttov_as':    cut_extent_grau(extent, d_cs, dtb_as),                    'delta_Gaussianan':  cut_extent_graugaus(extent, d_cs, dtb_as_gaus),                     'delta_mean':        cut_extent_graugaus(extent, d_cs, dtb_as_mean),                     'delta_Interp':      cut_extent_graugaus(extent, d_cs, dtb_as_interp) })             return rttov_as#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liuliu_experiments_andcut(experiment, processedFolder):        #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for i in range(11):        rowi  = []; rowig  = []; rowim  = []; rowiN  = []        drowi = []; drowig = []; drowim = []; drowiN = []                for  j in range(11):            expname     = experiment+str(i)+'g'+str(j)+'.nc'            d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)            var         = d_liuliu['rttov_as'].values            var_gaus    = d_liuliu['rttov_as_Gaussianantennasigma_'].values            var_mean    = d_liuliu['rttov_as_footprintmean'].values            var_interp  = d_liuliu['rttov_as_pointInterpNearest'].values                        rowi.append(var)            rowig.append(var_gaus)            rowim.append(var_mean)            rowiN.append(var_interp)            drowi.append(var-tb_cs)            drowig.append(var_gaus-tb_cs_gaus)            drowim.append(var_mean-tb_cs_mean)            drowiN.append(var_interp-tb_cs_interp)                    tb_as.append(rowi)        tb_as_gaus.append(rowig)        tb_as_mean.append(rowi)        tb_as_interp.append(rowiN)        dtb_as.append(drowi)        dtb_as_gaus.append(drowig)        dtb_as_mean.append(drowim)        dtb_as_interp.append(drowiN)            tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            #WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     #cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)     rttov_as =dict({'rttov_as':          cut_extent_liuliu(extent, d_cs, tb_as),                     'rttov_as_Gaussian': cut_extent_liuliu_gaus(extent, d_cs, tb_as_gaus),                     'rttov_as_mean':     cut_extent_liuliu_gaus(extent, d_cs, tb_as_mean),                    'rttov_as_Interp':   cut_extent_liuliu_gaus(extent, d_cs, tb_as_interp),                    'delta_rttov_as':    cut_extent_liuliu(extent, d_cs, dtb_as),                    'delta_Gaussianan':  cut_extent_liuliu_gaus(extent, d_cs, dtb_as_gaus),                     'delta_mean':        cut_extent_liuliu_gaus(extent, d_cs, dtb_as_mean),                     'delta_Interp':      cut_extent_liuliu_gaus(extent, d_cs, dtb_as_interp) })             return rttov_as#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liuliu_sieron_experiments_andcut(experiment, processedFolder):        #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for isnow in range(11):        rowi  = []; rowig  = []; rowim  = []; rowiN  = []        drowi = []; drowig = []; drowim = []; drowiN = []                        for  j in range(11):            expname     = experiment+str(isnow)+'g'+str(j)+'.nc'            d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_allsky_'+instrument+'sieron_sliu'+str(isnow)+'gliu'+str(j)+expname)    ##output_tb_allsky_MHSsieron_sliu9gliu9            var         = d_liuliu['rttov_as'].values            var_gaus    = d_liuliu['rttov_as_Gaussianantennasigma_'].values            var_mean    = d_liuliu['rttov_as_footprintmean'].values            var_interp  = d_liuliu['rttov_as_pointInterpNearest'].values                        rowi.append(var)            rowig.append(var_gaus)            rowim.append(var_mean)            rowiN.append(var_interp)            drowi.append(var-tb_cs)            drowig.append(var_gaus-tb_cs_gaus)            drowim.append(var_mean-tb_cs_mean)            drowiN.append(var_interp-tb_cs_interp)                    tb_as.append(rowi)        tb_as_gaus.append(rowig)        tb_as_mean.append(rowim)        tb_as_interp.append(rowiN)        dtb_as.append(drowi)        dtb_as_gaus.append(drowig)        dtb_as_mean.append(drowim)        dtb_as_interp.append(drowiN)            tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            #WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     #cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)     rttov_as =dict({'rttov_as':          cut_extent_liuliu(extent, d_cs, tb_as),                     'rttov_as_Gaussian': cut_extent_liuliu_gaus(extent, d_cs, tb_as_gaus),                     'rttov_as_mean':     cut_extent_liuliu_gaus(extent, d_cs, tb_as_mean),                    'rttov_as_Interp':   cut_extent_liuliu_gaus(extent, d_cs, tb_as_interp),                    'delta_rttov_as':    cut_extent_liuliu(extent, d_cs, dtb_as),                    'delta_Gaussianan':  cut_extent_liuliu_gaus(extent, d_cs, dtb_as_gaus),                     'delta_mean':        cut_extent_liuliu_gaus(extent, d_cs, dtb_as_mean),                     'delta_Interp':      cut_extent_liuliu_gaus(extent, d_cs, dtb_as_interp) })             return rttov_as#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liuliu_experiments_NOcut(experiment, processedFolder):        instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for i in range(11):        rowi  = []; rowig  = []; rowim  = []; rowiN  = []        drowi = []; drowig = []; drowim = []; drowiN = []                for  j in range(11):            expname     = experiment+str(i)+'g'+str(j)+'.nc'            d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)            var         = d_liuliu['rttov_as'].values            var_gaus    = d_liuliu['rttov_as_Gaussianantennasigma_'].values            var_mean    = d_liuliu['rttov_as_footprintmean'].values            var_interp  = d_liuliu['rttov_as_pointInterpNearest'].values                        rowi.append(var)            rowig.append(var_gaus)            rowim.append(var_mean)            rowiN.append(var_interp)            drowi.append(var-tb_cs)            drowig.append(var_gaus-tb_cs_gaus)            drowim.append(var_mean-tb_cs_mean)            drowiN.append(var_interp-tb_cs_interp)                    tb_as.append(rowi)        tb_as_gaus.append(rowig)        tb_as_mean.append(rowim)        tb_as_interp.append(rowiN)        dtb_as.append(drowi)        dtb_as_gaus.append(drowig)        dtb_as_mean.append(drowim)        dtb_as_interp.append(drowiN)            tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            #WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     #cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)         rttov_as_nocut =dict({'rttov_as':    tb_as,                     'rttov_as_Gaussian': tb_as_gaus,                     'rttov_as_mean':     tb_as_mean,                    'rttov_as_Interp':   tb_as_interp,                    'delta_rttov_as':    dtb_as,                    'delta_Gaussianan':  dtb_as_gaus,                     'delta_mean':        dtb_as_mean,                     'delta_Interp':      dtb_as_interp })             return rttov_as_nocut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liuliu_sieron_experiments_NOcut(experiment, processedFolder):        instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for i in range(11):        rowi  = []; rowig  = []; rowim  = []; rowiN  = []        drowi = []; drowig = []; drowim = []; drowiN = []                for  j in range(11):            expname     = experiment+str(i)+'g'+str(j)+'.nc'            d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_allsky_'+instrument+'sieron_sliu'+str(i)+'gliu'+str(j)+expname)    ##output_tb_allsky_MHSsieron_sliu9gliu9            var         = d_liuliu['rttov_as'].values            var_gaus    = d_liuliu['rttov_as_Gaussianantennasigma_'].values            var_mean    = d_liuliu['rttov_as_footprintmean'].values            var_interp  = d_liuliu['rttov_as_pointInterpNearest'].values                        rowi.append(var)            rowig.append(var_gaus)            rowim.append(var_mean)            rowiN.append(var_interp)            drowi.append(var-tb_cs)            drowig.append(var_gaus-tb_cs_gaus)            drowim.append(var_mean-tb_cs_mean)            drowiN.append(var_interp-tb_cs_interp)                    tb_as.append(rowi)        tb_as_gaus.append(rowig)        tb_as_mean.append(rowim)        tb_as_interp.append(rowiN)        dtb_as.append(drowi)        dtb_as_gaus.append(drowig)        dtb_as_mean.append(drowim)        dtb_as_interp.append(drowiN)            tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            #WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     #cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)         rttov_as_nocut =dict({'rttov_as':    tb_as,                     'rttov_as_Gaussian': tb_as_gaus,                     'rttov_as_mean':     tb_as_mean,                    'rttov_as_Interp':   tb_as_interp,                    'delta_rttov_as':    dtb_as,                    'delta_Gaussianan':  dtb_as_gaus,                     'delta_mean':        dtb_as_mean,                     'delta_Interp':      dtb_as_interp })             return rttov_as_nocut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_iwc_experiments_andcut(processedFolder):        #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]    instrument = 'MHS'    outfile    = 'output_tb_'+instrument    # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        WRFvars    = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            WRF_intqs_cut  = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intqs'].data)     WRF_intqg_cut  = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intqg'].data)     WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)         interp_intqs_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSinterp_intqs'].data)     interp_intqg_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSinterp_intqg'].data)     interp_intTot_cut = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSinterp_intTot'].data)     mean_intqs_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSfootprintmean_intqs'].data)     mean_intqg_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSfootprintmean_intqg'].data)     mean_intTot_cut = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSfootprintmean_intTot'].data)     gaus_intqs_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSGaussian_intqs'].data)     gaus_intqg_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSGaussian_intqg'].data)     gaus_intTot_cut = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSGaussian_intTot'].data)                     iwcontents = dict({'WRF_intTot_cut': WRF_intTot_cut,                         'WRF_intqg_cut':  WRF_intqg_cut,                       'WRF_intqs_cut':  WRF_intqs_cut,                        'interp_intqs_cut':  interp_intqs_cut,                        'interp_intqg_cut':  interp_intqg_cut,                         'interp_intTot_cut': interp_intTot_cut,                        'mean_intqs_cut':  mean_intqs_cut,                        'mean_intTot_cut': mean_intTot_cut,                       'mean_intqg_cut':  mean_intqg_cut,                        'gaus_intqs_cut':  gaus_intqs_cut,                        'gaus_intqg_cut':  gaus_intqg_cut,                        'gaus_intTot_cut': gaus_intTot_cut})                 return iwcontents#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_iwc_experiment_andcut(experiment_1, processedFolder):        #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]        # rttov clearsky simulations    instrument = 'MHS'    outfile   = 'output_tb_'+instrument    d_cs      = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # 1st Read nc files     #------------------------------------------------------------------------------------------    # WRF data     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')    WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)     lonlon    = WRFvars['wrf_lon'].data    latlat    = WRFvars['wrf_lat'].data    nx,ny=np.shape(lonlon)        tb_liuliu_snowhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_snowhalfiwc[:]=np.nan    tb_liuliu_grauhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_grauhalfiwc[:]=np.nan    tb_liuliu_grausnowhalfiwc = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_grausnowhalfiwc[:]=np.nan    tb_liuliu_rainhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_rainhalfiwc[:]=np.nan    tb_liuliu_noiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_noiwc[:]=np.nan    tb_liuliu_onlysnow  = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlysnow[:]=np.nan    tb_liuliu_onlygrau  = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlygrau[:]=np.nan    tb_liuliu_onlyrain  = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlyrain[:]=np.nan    tb_liuliu_onlyice   = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlyice[:]=np.nan        tb_liugrausp_onlygrau  = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liugrausp_onlygrau[:]=np.nan        tb_as_liuliu    = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_as_liuliu[:]=np.nan        liuopts = [3,9]    counter = 0    for i in liuopts:                expname     = experiment_1+str(i)+'g'+str(i)+'.nc'        d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var         = d_liuliu['rttov_as'].values        tb_as_liuliu[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'grau_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_grauhalfiwc[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'snow_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_snowhalfiwc[counter,0,:,:,:] = var                         expname = experiment_1+str(i)+'g'+str(i)+'rain_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_rainhalfiwc[counter,0,:,:,:] = var                          expname = experiment_1+str(i)+'g'+str(i)+'grausnow_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_grausnowhalfiwc[counter,0,:,:,:] = var          expname = experiment_1+str(i)+'g'+str(i)+'noiwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_noiwc[counter,0,:,:,:] = var                  expname = experiment_1+str(i)+'g'+str(i)+'onlygrau'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_onlygrau[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'onlysnow'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_onlysnow[counter,0,:,:,:] = var              counter = counter+1        i = 9    expname = experiment_1+str(i)+'g'+str(i)+'onlyrain'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liuliu_onlyrain[0,0,:,:,:] = var                      expname = experiment_1+str(i)+'g'+str(i)+'onlyice'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liuliu_onlyice[0,0,:,:,:] = var          # add only grau with soft sphere    expname = experiment_1+'3grausp'+'onlygrau'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liugrausp_onlygrau[0,0,:,:,:] = var                    rttov_as =dict({'control':      cut_extent_2snowsample(extent, 2, d_cs, tb_as_liuliu),                     'halfgrau':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_grauhalfiwc),                     'halfsnow':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_snowhalfiwc),                    'halfrain':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_rainhalfiwc),                    'halfgrausnow': cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_grausnowhalfiwc),                    'noiwc':        cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_noiwc),                     'onlysnow':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_onlysnow),                     'onlygrau':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_onlygrau),                     'onlyrain':     cut_extent_2snowsample(extent, 1, d_cs, tb_liuliu_onlyrain),                    'onlyice':      cut_extent_2snowsample(extent, 1, d_cs, tb_liuliu_onlyice),                    'onlygrau_softsphere': cut_extent_2snowsample(extent, 1, d_cs, tb_liugrausp_onlygrau) })                         # how do i add also the liu3 + gp and liu9+graupel            return rttov_as, cloudmask_WRF#------------------------------------------------------------------------------def histogram_iwc_impacts(rttov_as, suptitle, cloudmask_WRF, plotpath):        # can also plot them in semilogy using add_hists_2fig_simple_2rowslog         maskdo = 0    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]        #---------------- 1st for Liu=3    fig, axes = plt.subplots(nrows=2, ncols=4, constrained_layout=True,figsize=[20,10])         axes[0,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[0,0].plot([],[], linewidth=1.2, color='darkred', label='onlysnow')    axes[0,0].plot([],[], linewidth=1.2, color='darkblue', label='onlygrau')    axes[0,0].plot([],[], linewidth=1.2, color='blue', label='onlygrau (softsphere)')    axes[0,0].plot([],[], linewidth=1.2, color='darkgreen', label='noiwc')     axes[0,0].plot([],[], linewidth=1.2, color='magenta', label='half_rain')    axes[0,0].plot([],[], linewidth=1.2, color='gray', label='onlyice')    #axes[0,0].legend(loc='upper left',ncol=6)    fig.legend(loc='lower left', ncol=7, bbox_to_anchor=(0.2,-0.05))    axes[1,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[1,0].plot([],[], linewidth=1.2, color=base_colors[0], label='halfsnow')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[1], label='halfgrau')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[2], label='halfgrausnow')     axes[1,0].plot([],[], linewidth=1.2, color='gray', label='halfrain')    axes[1,0].legend(loc='upper left')    #fig.legend(loc='lower left', ncol=5, bbox_to_anchor=(0.2,-0.14))    axes[1,0].set_ylabel('Counts')    axes[1,0].set_xlabel('BT [K]')    # --- FIGURE 1: BASIC    T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][0,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 0)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlysnow'][0,:,:,:], cloudmask_WRF, 'darkred', axes, 'onlysnow', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau'][0,:,:,:], cloudmask_WRF, 'darkblue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau_softsphere'][0,:,:,:], cloudmask_WRF, 'blue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['noiwc'][0,:,:,:], cloudmask_WRF, 'darkgreen', axes, 'noiwc', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyrain'][0,:,:,:], cloudmask_WRF, 'magenta', axes, 'half_rain', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyice'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'onlyice', '-', maskdo, 0)        # --- FIGURE 2: half contents impact     T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][0,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 1)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfsnow'][0,:,:,:], cloudmask_WRF, base_colors[0], axes, 'half_snow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrau'][0,:,:,:], cloudmask_WRF, base_colors[1], axes, 'half_grau', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrausnow'][0,:,:,:], cloudmask_WRF, base_colors[2], axes, 'half_grausnow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfrain'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 1)      plt.suptitle(suptitle+' (liu:3)')    fig.savefig(plotpath+'/poster/'+'testhistlog_iwcimpact_liu3'+suptitle+'.png', dpi=300,transparent=False, bbox_inches='tight')         plt.show()    #---------------- 2nd for Liu=9    fig, axes = plt.subplots(nrows=2, ncols=4, constrained_layout=True,figsize=[20,10])         # add dummy labels    axes[0,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[0,0].plot([],[], linewidth=1.2, color='darkred', label='onlysnow')    axes[0,0].plot([],[], linewidth=1.2, color='darkblue', label='onlygrau')    axes[0,0].plot([],[], linewidth=1.2, color='blue', label='onlygrau (softsphere)')    axes[0,0].plot([],[], linewidth=1.2, color='darkgreen', label='noiwc')     axes[0,0].plot([],[], linewidth=1.2, color='magenta', label='half_rain')    axes[0,0].plot([],[], linewidth=1.2, color='gray', label='onlyice')    #axes[0,0].legend(loc='upper left',ncol=6)    fig.legend(loc='lower left', ncol=7, bbox_to_anchor=(0.2,-0.05))    axes[1,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[1,0].plot([],[], linewidth=1.2, color=base_colors[0], label='halfsnow')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[1], label='halfgrau')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[2], label='halfgrausnow')     axes[1,0].plot([],[], linewidth=1.2, color='gray', label='halfrain')    axes[1,0].legend(loc='upper left')    #fig.legend(loc='lower left', ncol=5, bbox_to_anchor=(0.2,-0.14))    axes[1,0].set_ylabel('Counts')    axes[1,0].set_xlabel('BT [K]')    # --- FIGURE 1: BASIC    T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][1,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 0)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlysnow'][1,:,:,:], cloudmask_WRF, 'darkred', axes, 'onlysnow', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau'][1,:,:,:], cloudmask_WRF, 'darkblue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau_softsphere'][0,:,:,:], cloudmask_WRF, 'blue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['noiwc'][1,:,:,:], cloudmask_WRF, 'darkgreen', axes, 'noiwc', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyrain'][0,:,:,:], cloudmask_WRF, 'magenta', axes, 'half_rain', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyice'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 0)     T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][1,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 1)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfsnow'][1,:,:,:], cloudmask_WRF, base_colors[0], axes, 'half_snow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrau'][1,:,:,:], cloudmask_WRF, base_colors[1], axes, 'half_grau', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrausnow'][1,:,:,:], cloudmask_WRF, base_colors[2], axes, 'half_grausnow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfrain'][1,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 1)        plt.suptitle(suptitle+' (liu:9)')    fig.savefig(plotpath+'/poster/'+'testhistlog_iwcimpact_liu9'+suptitle+'.png', dpi=300,transparent=False, bbox_inches='tight')       plt.show()    return#------------------------------------------------------------------------------def make_histogram_iwc_impacts(server, processedFolder):        plotpath, folders = config_folders(server)        #---- READ DATA    #------------------------------------------------------------------------------------------    rttov_as_iwc_eqMass, _             = get_iwc_experiment_andcut( 'rttov_processed_allsky_eqMass_rsg_s', processedFolder)    rttov_as_iwc_WSM6, cloudmask_WRF   = get_iwc_experiment_andcut( 'rttov_processed_allsky_rsg_s', processedFolder)    #---- DO THE PLOTS: 1) impact of IWC sensitivities (note graupel soft sphere similar to liu3)     #------------------------------------------------------------------------------------------        # eqMass-WSM6 and WSM6    histogram_iwc_impacts(rttov_as_iwc_eqMass, 'eqMass_WSM6', cloudmask_WRF, plotpath)    histogram_iwc_impacts(rttov_as_iwc_WSM6, 'WSM6', cloudmask_WRF, plotpath)        return#------------------------------------------------------------------------------def make_barplots_liuliu_poster(experiment_grid, rttov_eqMass, rttov_WSM6, rttov_sieron, server):            # check = rttov_eqMass['rttov_as'][0,0,0,:,:].copy()    # masked_arr = np.where(check <= 250, check, np.nan)    # plt.pcolor(masked_arr); plt.colorbar()    # plt.pcolor(rttov_eqMass['rttov_as'][0,0,0,:,:]); plt.colorbar()        import matplotlib.patches as mpatches  # Add this at the top of your script        plotpath, folders = config_folders(server)    ichan_title     = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx       = [0] #,1,3,4]    base_colors     = sns.color_palette('Paired')             all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)                categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']             var_wrfgrid_eqMass   = rttov_eqMass['delta_rttov_as'].copy()    var_wrfgrid          = rttov_WSM6['delta_rttov_as'].copy()    var_wrfgrid_sieron   = rttov_sieron['delta_rttov_as'].copy()                # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=3, ncols=4,  figsize=[20,16])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.9)    for index, i in enumerate(chan_indx):        axes[1,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)                        axes[1,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[1,index].grid(True)        axes[1,index].set_ylim([-600,10])        axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')    #axes[0,index].legend(loc='center left', title='Graupel', bbox_to_anchor=(1,0.5))            legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'{categories[i]}') for i in range(11) ]    fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')        for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)            axes[0,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[0,index].set_ylim([-600,10])        axes[0,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[0,index].grid(True)    axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')    for index, i in enumerate(chan_indx):        axes[2,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid_sieron[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_sieron[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)            axes[2,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[2,index].set_ylim([-600,10])        axes[2,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[2,index].grid(True)    axes[2,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            #fig.text(0.5, 0.3, r'$\Delta$BT (rttov_as - rttov_cl) Sieron'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    #fig.text(0.5, 0.6, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    #fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.21, 0.92, r'iwc rescaling', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.21, 0.61, r'equalMass', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.21, 0.3, r'M(D) Sieron et al. (2018)', ha='center', va='center', fontsize=16,fontweight='bold')    fig.savefig(plotpath+'/poster/'+'stack_liuliu_barplots_poster.png', dpi=300,transparent=False, bbox_inches='tight')       plt.show()        return    #------------------------------------------------------------------------------def make_barplots_liuliu_poster_BTs(experiment_grid, rttov_eqMass, rttov_WSM6, rttov_sieron, server):            # check = rttov_eqMass['rttov_as'][0,0,0,:,:].copy()    # masked_arr = np.where(check <= 250, check, np.nan)    # plt.pcolor(masked_arr); plt.colorbar()    # plt.pcolor(rttov_eqMass['rttov_as'][0,0,0,:,:]); plt.colorbar()        import matplotlib.patches as mpatches  # Add this at the top of your script        plotpath, folders = config_folders(server)    ichan_title     = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx       = [0] #,1,3,4]    base_colors     = sns.color_palette('Paired')             all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)                categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']             var_wrfgrid_eqMass   = rttov_eqMass['rttov_as'].copy()    var_wrfgrid          = rttov_WSM6['rttov_as'].copy()    var_wrfgrid_sieron   = rttov_sieron['rttov_as'].copy()                # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=3, ncols=4,  figsize=[20,16])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.9)    for index, i in enumerate(chan_indx):        axes[1,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                #masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                #masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(var.flatten())                        axes[1,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[1,index].grid(True)        #axes[1,index].set_ylim([-600,10])        axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')    #axes[0,index].legend(loc='center left', title='Graupel', bbox_to_anchor=(1,0.5))            legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'{categories[i]}') for i in range(11) ]    fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')        for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                #masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                #masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(var.flatten())            axes[0,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         #axes[0,index].set_ylim([-600,10])        axes[0,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[0,index].grid(True)    axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')    for index, i in enumerate(chan_indx):        axes[2,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid_sieron[isnow,igrau,i,:,:]                #masked_var = np.where( (var_wrfgrid_sieron[isnow,igrau,0,:,:]) <= 250, var, np.nan)                #masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(var.flatten())            axes[2,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         #axes[2,index].set_ylim([-600,10])        axes[2,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[2,index].grid(True)    axes[2,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            #fig.text(0.5, 0.3, r'$\Delta$BT (rttov_as - rttov_cl) Sieron'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    #fig.text(0.5, 0.6, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    #fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.21, 0.92, r'iwc rescaling', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.21, 0.61, r'equalMass', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.21, 0.3, r'M(D) Sieron et al. (2018)', ha='center', va='center', fontsize=16,fontweight='bold')    fig.savefig(plotpath+'/poster/'+'stackBTs_liuliu_barplots_poster.png', dpi=300,transparent=False, bbox_inches='tight')       plt.show()    #----------------------------        # One for aach i snow    # mean dTB (rttov_as - rttov_cs) below 240K    for isnow in range(11):                fig, axes = plt.subplots(nrows=3, ncols=4,  figsize=[20,16])    #constrained_layout=True,        fig.subplots_adjust(hspace=0.9)                for index, i in enumerate(chan_indx):            axes[0,index].set_title(ichan_title[index]+' GHz')                wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                #masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                #masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(var.flatten()) )            axes[0,index].bar(categories, wrfgridmean, color=base_colors)            #xaes[0,index].set_ylim([-50,10])            axes[0,index].grid(True)            axes[0,index].set_xticklabels(axes[0,index].get_xticklabels(), rotation=45, ha='right')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')                legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'{categories[i]}') for i in range(11) ]        fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        for index, i in enumerate(chan_indx):            wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                #masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                #masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(var.flatten()) )            axes[1,index].bar(categories, wrfgridmean, color=base_colors)            #axes[1,index].set_ylim([-50,10])            axes[1,index].grid(True)            axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[1,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                        fig.text(0.5, 0.6, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        for index, i in enumerate(chan_indx):            wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid_sieron[isnow,igrau,i,:,:]                #masked_var = np.where( (var_wrfgrid_sieron[isnow,igrau,0,:,:]) <= 250, var, np.nan)                #masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(var.flatten()) )            axes[2,index].bar(categories, wrfgridmean, color=base_colors)            #xes[2,index].set_ylim([-50,10])            axes[2,index].grid(True)            axes[2,index].set_xticklabels(axes[2,index].get_xticklabels(), rotation=45, ha='right')        axes[2,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                        fig.text(0.5, 0.3, r'$\Delta$BT (rttov_as - rttov_cl) Sieron'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        fig.savefig(plotpath+'/poster/'+f'BTS_singleisnow_{isnow}_liuliu_barplots.png', dpi=300,transparent=False, bbox_inches='tight')           plt.show()                                    return        #------------------------------------------------------------------------------def make_barplots_liuliu(experiment_grid, rttov_eqMass, rttov_WSM6, rttov_sieron, server):            # check = rttov_eqMass['rttov_as'][0,0,0,:,:].copy()    # masked_arr = np.where(check <= 250, check, np.nan)    # plt.pcolor(masked_arr); plt.colorbar()    # plt.pcolor(rttov_eqMass['rttov_as'][0,0,0,:,:]); plt.colorbar()        import matplotlib.patches as mpatches  # Add this at the top of your script        plotpath, folders = config_folders(server)    ichan_title     = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx       = [0,1,3,4]    base_colors     = sns.color_palette('Paired')             all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)                categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']             var_wrfgrid_eqMass   = rttov_eqMass['delta_rttov_as'].copy()    var_wrfgrid          = rttov_WSM6['delta_rttov_as'].copy()    var_wrfgrid_sieron   = rttov_sieron['delta_rttov_as'].copy()                # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=3, ncols=4,  figsize=[20,16])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.9)    for index, i in enumerate(chan_indx):        axes[1,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)                        axes[1,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[1,index].grid(True)        axes[1,index].set_ylim([-600,10])        axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')    #axes[0,index].legend(loc='center left', title='Graupel', bbox_to_anchor=(1,0.5))            legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'{categories[i]}') for i in range(11) ]    fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')        for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)            axes[0,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[0,index].set_ylim([-600,10])        axes[0,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[0,index].grid(True)    axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')    for index, i in enumerate(chan_indx):        axes[2,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid_sieron[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_sieron[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)            axes[2,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[2,index].set_ylim([-600,10])        axes[2,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[2,index].grid(True)    axes[2,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            #fig.text(0.5, 0.3, r'$\Delta$BT (rttov_as - rttov_cl) Sieron'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    #fig.text(0.5, 0.6, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    #fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.5, 0.3, r'iwc rescaling', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.5, 0.6, r'equalMass', ha='center', va='center', fontsize=16,fontweight='bold')    fig.text(0.5, 0.95, r'M(D) Sieron et al. (2018)', ha='center', va='center', fontsize=16,fontweight='bold')    fig.savefig(plotpath+'/poster/'+'stack_liuliu_barplots_poster.png', dpi=300,transparent=False, bbox_inches='tight')       plt.show()    #----------------------------        # One for aach i snow    # mean dTB (rttov_as - rttov_cs) below 240K    for isnow in range(11):                fig, axes = plt.subplots(nrows=3, ncols=4,  figsize=[20,16])    #constrained_layout=True,        fig.subplots_adjust(hspace=0.9)                for index, i in enumerate(chan_indx):            axes[0,index].set_title(ichan_title[index]+' GHz')                wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(masked_var) )            axes[0,index].bar(categories, wrfgridmean, color=base_colors)            axes[0,index].set_ylim([-50,10])            axes[0,index].grid(True)            axes[0,index].set_xticklabels(axes[0,index].get_xticklabels(), rotation=45, ha='right')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')                legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'{categories[i]}') for i in range(11) ]        fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        for index, i in enumerate(chan_indx):            wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(masked_var) )            axes[1,index].bar(categories, wrfgridmean, color=base_colors)            axes[1,index].set_ylim([-50,10])            axes[1,index].grid(True)            axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[1,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                        fig.text(0.5, 0.6, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        for index, i in enumerate(chan_indx):            wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid_sieron[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_sieron[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(masked_var) )            axes[2,index].bar(categories, wrfgridmean, color=base_colors)            axes[2,index].set_ylim([-50,10])            axes[2,index].grid(True)            axes[2,index].set_xticklabels(axes[2,index].get_xticklabels(), rotation=45, ha='right')        axes[2,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                        fig.text(0.5, 0.3, r'$\Delta$BT (rttov_as - rttov_cl) Sieron'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        fig.savefig(plotpath+'/poster/'+f'singleisnow_{isnow}_liuliu_barplots.png', dpi=300,transparent=False, bbox_inches='tight')           plt.show()            return#------------------------------------------------------------------------------def return_data4stats_inputs(rttov):         values     = rttov['delta_rttov_as']        var        = values[0,0,0,:,:]    nlon,nlat = var.shape        values     = rttov['delta_Gaussianan']    var        = values[0,0,0,:,:]    nlon_obs,nlat_obs = var.shape    delta_rttov  = np.zeros((11,11,5,nlon,nlat)); delta_rttov[:] = np.nan     delta_gaus   = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_gaus[:]  = np.nan     delta_mean   = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_mean[:]  = np.nan     delta_interp = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_interp[:] = np.nan         for isnow in range(11):        for igrau in range(11):            for ifreq in range(5):                values     = rttov['delta_rttov_as']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_rttov[isnow,igrau,ifreq,:,:] = masked_var                values     = rttov['delta_Gaussianan']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_gaus[isnow,igrau,ifreq,:,:] = masked_var                                values     = rttov['delta_mean']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_mean[isnow,igrau,ifreq,:,:] = masked_var                                values     = rttov['delta_Interp']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_interp[isnow,igrau,ifreq,:,:] = masked_var                    ifreq = 0    data_array_0 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 1    data_array_1 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 2    data_array_2 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 3    data_array_3 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 4    data_array_4 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }        return data_array_0, data_array_1, data_array_2, data_array_3, data_array_4#------------------------------------------------------------------------------def return_barplot_inputs(rttov):     means_delta_rttov  = np.zeros((11,11,5)); means_delta_rttov[:] = np.nan     means_delta_gaus   = np.zeros((11,11,5)); means_delta_gaus[:]  = np.nan     means_delta_mean   = np.zeros((11,11,5)); means_delta_mean[:]  = np.nan     means_delta_interp = np.zeros((11,11,5)); means_delta_interp[:] = np.nan         for isnow in range(11):        for igrau in range(11):            for ifreq in range(5):                values     = rttov['delta_rttov_as']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_rttov[isnow,igrau,ifreq] = np.nanmean(masked_var)                values     = rttov['delta_Gaussianan']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_gaus[isnow,igrau,ifreq] = np.nanmean(masked_var)                                values     = rttov['delta_mean']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_mean[isnow,igrau,ifreq] = np.nanmean(masked_var)                                values     = rttov['delta_Interp']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_interp[isnow,igrau,ifreq] = np.nanmean(masked_var)                    ifreq = 0    data_array_0 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 1    data_array_1 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 2    data_array_2 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 3    data_array_3 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 4    data_array_4 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }        return data_array_0, data_array_1, data_array_2, data_array_3, data_array_4#------------------------------------------------------------------------------def make_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server):        import matplotlib.patches as mpatches  # Add this at the top of your script    plotpath, folders = config_folders(server)        #- for the plot:    categories = ['Thick hex col','Sector']         category_positions = np.arange(len(categories))  # Numeric positions for categories    experiments = ['wrf grid', 'gaussian', 'mean', 'nearest' ]    colors_     = ['k','darkblue','darkred','darkgreen']    x           = np.arange(4)  # the label locations    width       = 0.2    # the width of the bars    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.5)        #- get data for the first row        data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_barplot_inputs(rttov_eqMass)    row = 0    #- frequency 89GHz    axes[row,0].bar( x, data_array_0['wrf_grid'], width, color='k')    axes[row,0].bar( x+0.2, data_array_0['gaussian'], width, color='darkblue')    axes[row,0].bar( x+0.4, data_array_0['delta_mean'], width, color='darkred')    axes[row,0].bar( x+0.6, data_array_0['delta_Interp'], width, color='darkgreen')    axes[row,0].set_title('89.0 GHz')        #- frequency 157GHz    axes[row,1].bar( x, data_array_1['wrf_grid'], width, color='k')    axes[row,1].bar( x+0.2, data_array_1['gaussian'], width, color='darkblue')    axes[row,1].bar( x+0.4, data_array_1['delta_mean'], width, color='darkred')    axes[row,1].bar( x+0.6, data_array_1['delta_Interp'], width, color='darkgreen')    axes[row,1].set_title('157 GHz')                #- frequency 157GHz    axes[row,2].bar( x, data_array_3['wrf_grid'], width, color='k')    axes[row,2].bar( x+0.2, data_array_3['gaussian'], width, color='darkblue')    axes[row,2].bar( x+0.4, data_array_3['delta_mean'], width, color='darkred')    axes[row,2].bar( x+0.6, data_array_3['delta_Interp'], width, color='darkgreen')    axes[row,2].set_title('183.311$\pm$3 GHz')                    #- frequency 190GHz    axes[row,3].bar( x, data_array_4['wrf_grid'], width, color='k')    axes[row,3].bar( x+0.2, data_array_4['gaussian'], width, color='darkblue')    axes[row,3].bar( x+0.4, data_array_4['delta_mean'], width, color='darkred')    axes[row,3].bar( x+0.6, data_array_4['delta_Interp'], width, color='darkgreen')    axes[row,3].set_title('190.311 GHz')                    for i in range(4):        axes[row,i].set_xticks(x + width, ['s3g3','s3g9','s9g3','s9g9'])        axes[row,i].set_ylim([-50,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')                legend_elements = [ mpatches.Patch(facecolor=colors_[i], label=f'{experiments[i]}') for i in range(4) ]    fig.legend(        handles=legend_elements,         loc='center left',         bbox_to_anchor=(0.93, 0.5),        title='Footprint')        axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                        #- get data for the first row        data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_barplot_inputs(rttov_WSM6)    row = 1    #- frequency 89GHz    axes[row,0].bar( x, data_array_0['wrf_grid'], width, color='k')    axes[row,0].bar( x+0.2, data_array_0['gaussian'], width, color='darkblue')    axes[row,0].bar( x+0.4, data_array_0['delta_mean'], width, color='darkred')    axes[row,0].bar( x+0.6, data_array_0['delta_Interp'], width, color='darkgreen')    axes[row,0].set_title('89.0 GHz')        #- frequency 157GHz    axes[row,1].bar( x, data_array_1['wrf_grid'], width, color='k')    axes[row,1].bar( x+0.2, data_array_1['gaussian'], width, color='darkblue')    axes[row,1].bar( x+0.4, data_array_1['delta_mean'], width, color='darkred')    axes[row,1].bar( x+0.6, data_array_1['delta_Interp'], width, color='darkgreen')    axes[row,1].set_title('157 GHz')                #- frequency 157GHz    axes[row,2].bar( x, data_array_3['wrf_grid'], width, color='k')    axes[row,2].bar( x+0.2, data_array_3['gaussian'], width, color='darkblue')    axes[row,2].bar( x+0.4, data_array_3['delta_mean'], width, color='darkred')    axes[row,2].bar( x+0.6, data_array_3['delta_Interp'], width, color='darkgreen')    axes[row,2].set_title('183.311$\pm$3 GHz')                    #- frequency 190GHz    axes[row,3].bar( x, data_array_4['wrf_grid'], width, color='k')    axes[row,3].bar( x+0.2, data_array_4['gaussian'], width, color='darkblue')    axes[row,3].bar( x+0.4, data_array_4['delta_mean'], width, color='darkred')    axes[row,3].bar( x+0.6, data_array_4['delta_Interp'], width, color='darkgreen')    axes[row,3].set_title('190.311 GHz')                    for i in range(4):        axes[row,i].set_xticks(x + width, ['s3g3','s3g9','s9g3','s9g9'])        axes[row,i].set_ylim([-50,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')                 axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.48, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    fig.savefig(plotpath+'/poster/'+f'sampleexperment_4footprintmodel_barplots.png', dpi=300,transparent=False, bbox_inches='tight')       plt.show()        return#------------------------------------------------------------------------------def get_diffin_15percentiles(percentile, data_array_0, data_array_1, data_array_4, experiment):             p89 = []    p157 = []    p190 = []        #output deltaBT between footprint model and rttov_as for s9g9 y s9g3. meaning [3] y [4]    for ii in ([2,3]):         p89.append(  np.round( np.nanpercentile( data_array_0['wrf_grid'][ii], percentile)  - np.nanpercentile( data_array_0[experiment][ii], percentile), 2) )        p157.append(  np.round( np.nanpercentile( data_array_1['wrf_grid'][ii], percentile) - np.nanpercentile( data_array_0[experiment][ii], percentile), 2) )        p190.append(  np.round( np.nanpercentile( data_array_4['wrf_grid'][ii], percentile) - np.nanpercentile( data_array_0[experiment][ii], percentile), 2) )        #p25_89.append( np.nanpercentile( data_array_0['wrf_grid'][ii], 25) - np.nanpercentile( data_array_0[experiment][ii], 25) )        #p25_157.append( np.nanpercentile( data_array_1['wrf_grid'][ii], 25) - np.nanpercentile( data_array_0[experiment][ii], 25) )        #p25_190.append( np.nanpercentile( data_array_4['wrf_grid'][ii], 25) - np.nanpercentile( data_array_0[experiment][ii], 25) )    print('-------- difference between wrf-grid and '+experiment)    print(f'{p89[0]} and {p89[1]}')    print(f'{p157[0]} and {p157[1]}')    print(f'{p190[0]} and {p190[1]}')        return  p89, p157, p190#------------------------------------------------------------------------------def do_whiskers(row, col_index, axes, x, data, color_in, width):        offset = [0, 10, 20, 30]    for i in range(len(data)):        p15 = np.nanpercentile(data[i], 15)        p25 = np.nanpercentile(data[i], 25)        p75 = np.nanpercentile(data[i], 75)        p95 = np.nanpercentile(data[i], 95)                mean_ = np.nanmean(data[i])        # Draw the box from 25th to 75th        axes[row,col_index].vlines(x+offset[i], ymin=p25, ymax=p75, color=color_in, linewidth=10)        axes[row,col_index].vlines(x+offset[i], ymin=p15, ymax=p95, color=color_in, linewidth=2)        # Draw the mean as a bold vertical line        x1 = x+offset[i]        axes[row,col_index].hlines(y=mean_, xmin=x1-(width/2), xmax=x1+(width/2), color='k', linewidth=3)    return axes #------------------------------------------------------------------------------def make_distrib_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server):        import matplotlib.patches as mpatches  # Add this at the top of your script    plotpath, folders = config_folders(server)        #- for the plot:    categories = ['Thick hex col','Sector']         category_positions = np.arange(len(categories))  # Numeric positions for categories    experiments = ['wrf grid', 'gaussian', 'mean', 'nearest' ]    colors_     = ['k','darkblue','darkred','darkgreen']    x           = [0, 2, 4, 6] # the label locations    width       = 1    # the width of the bars    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.5)    #------     #- get data for the first row      row = 0    data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_eqMass)    #- frequency 89GHz    axes = do_whiskers(row, 0, axes, x[0], data_array_0['wrf_grid'], 'k', width)    axes = do_whiskers(row, 0, axes, x[1], data_array_0['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 0, axes, x[2], data_array_0['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 0, axes, x[3], data_array_0['delta_Interp'], 'darkgreen', width)    axes[row,0].set_title('89.0 GHz')            #- frequency 157    axes = do_whiskers(row, 1, axes, x[0], data_array_1['wrf_grid'], 'k', width)    axes = do_whiskers(row, 1, axes, x[1], data_array_1['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 1, axes, x[2], data_array_1['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 1, axes, x[3], data_array_1['delta_Interp'], 'darkgreen', width)    axes[row,1].set_title('157 GHz')                #- frequency 183    axes = do_whiskers(row, 2, axes, x[0], data_array_3['wrf_grid'], 'k', width)    axes = do_whiskers(row, 2, axes, x[1], data_array_3['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 2, axes, x[2], data_array_3['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 2, axes, x[3], data_array_3['delta_Interp'], 'darkgreen', width)    axes[row,2].set_title('183.311$\pm$3 GHz')            #- frequency 190    axes = do_whiskers(row, 3, axes, x[0], data_array_4['wrf_grid'], 'k', width)    axes = do_whiskers(row, 3, axes, x[1], data_array_4['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 3, axes, x[2], data_array_4['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 3, axes, x[3], data_array_4['delta_Interp'], 'darkgreen', width)    axes[row,3].set_title('190.311 GHz')                   for i in range(4):        axes[row,i].set_xticks( [5,15,25,35], ['s3g3','s3g9','s9g3','s9g9'])        #axes[row,i].set_ylim([-,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')              legend_elements = [ mpatches.Patch(facecolor=colors_[i], label=f'{experiments[i]}') for i in range(4) ]    fig.legend(        handles=legend_elements,         loc='center left',         bbox_to_anchor=(0.93, 0.5),        title='Footprint')        axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) sieron'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    #------     #- get data for the first row      row = 1    data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_WSM6)    #- frequency 89GHz    axes = do_whiskers(row, 0, axes, x[0], data_array_0['wrf_grid'], 'k', width)    axes = do_whiskers(row, 0, axes, x[1], data_array_0['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 0, axes, x[2], data_array_0['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 0, axes, x[3], data_array_0['delta_Interp'], 'darkgreen', width)    axes[row,0].set_title('89.0 GHz')            #- frequency 157    axes = do_whiskers(row, 1, axes, x[0], data_array_1['wrf_grid'], 'k', width)    axes = do_whiskers(row, 1, axes, x[1], data_array_1['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 1, axes, x[2], data_array_1['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 1, axes, x[3], data_array_1['delta_Interp'], 'darkgreen', width)    axes[row,1].set_title('157 GHz')                #- frequency 183    axes = do_whiskers(row, 2, axes, x[0], data_array_3['wrf_grid'], 'k', width)    axes = do_whiskers(row, 2, axes, x[1], data_array_3['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 2, axes, x[2], data_array_3['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 2, axes, x[3], data_array_3['delta_Interp'], 'darkgreen', width)    axes[row,2].set_title('183.311$\pm$3 GHz')            #- frequency 190    axes = do_whiskers(row, 3, axes, x[0], data_array_4['wrf_grid'], 'k', width)    axes = do_whiskers(row, 3, axes, x[1], data_array_4['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 3, axes, x[2], data_array_4['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 3, axes, x[3], data_array_4['delta_Interp'], 'darkgreen', width)    axes[row,3].set_title('190.311 GHz')                   for i in range(4):        axes[row,i].set_xticks( [5,15,25,35], ['s3g3','s3g9','s9g3','s9g9'])        #axes[row,i].set_ylim([-,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')              axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.48, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    fig.savefig(plotpath+'/poster/'+f'sampleexperment_4footprintmodel_barplots_whiskers.png', dpi=300,transparent=False, bbox_inches='tight')       plt.show()            return #------------------------------------------------------------------------------------------#------------------------------------------------------------------------------------------def get_mean_deltaBT(iwc, varBT):        x_bins = np.arange(0,20,2)    x_bin_centers = (x_bins[:-1] + x_bins[1:]) / 2            x1   = iwc.flatten()    var1 = varBT.flatten()    mask1 = ~np.isnan(x1) & ~np.isnan(var1)                # Prepare an array to store the means    mean_y_per_bin = []    x1_valid = x1[mask1]    y1_valid = var1[mask1]            # For each x-bin, compute the mean y-value    for i in range(len(x_bins)-1):        mask = (x1_valid >= x_bins[i]) & (x1_valid < x_bins[i+1])        if np.any(mask):            mean_y = np.nanmean(y1_valid[mask])        else:            mean_y = np.nan  # if no data in bin        mean_y_per_bin.append(mean_y)        return x_bin_centers, mean_y_per_bin    #------------------------------------------------------------------------------#------------------------------------------------------------------------------def analysis_function_iwc(iwcontents, rttov_eqMass, rttov_WSM6, experiment, server):    import matplotlib.colors as colors    plotpath, folders = config_folders(server)    var_wrfgrid_eqMass   = rttov_eqMass[experiment].copy()    var_wrfgrid          = rttov_WSM6[experiment].copy()                 #- for the plot:    categories  = ['Thick hex col','Sector']             ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')           all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.4)    # dummy legends    for isnow in [3,9]:        for igrau in [3,9]:                        axes[0,0].plot([],[], linewidth=1.2, color=all_shades[isnow][igrau], label=f's{str(isnow)}g{str(igrau)}')    fig.legend(loc='lower left', ncol=4, bbox_to_anchor=(0.2,-0.02))    for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')                for snow_index, isnow in enumerate([3,9]):            for igrau in [3,9]:                x_bins, mean_y_per_bin = get_mean_deltaBT(iwcontents, var_wrfgrid_eqMass[isnow,igrau,i,:,:])                axes[0,index].plot(x_bins, mean_y_per_bin, linewidth=1.2, color=all_shades[isnow][igrau])        axes[0,index].grid(True)        axes[0,index].set_ylim([-250,0])    fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment})', ha='center', va='center', fontsize=16,fontweight='bold')    for index, i in enumerate(chan_indx):        axes[1,index].set_title(ichan_title[index]+' GHz')                for snow_index, isnow in enumerate([3,9]):            for igrau in [3,9]:                x_bins, mean_y_per_bin = get_mean_deltaBT(iwcontents, var_wrfgrid[isnow,igrau,i,:,:])                axes[1,index].plot(x_bins, mean_y_per_bin, linewidth=1.2, color=all_shades[isnow][igrau])        axes[1,index].grid(True)        axes[1,index].set_ylim([-250,0])            axes[0,0].set_ylabel(r'$\Delta$BT [K] for eqMass')    axes[1,0].set_ylabel(r'$\Delta$BT [K] for WSM6')    axes[1,0].set_xlabel(r'model int. iwc(tot)')    fig.text(0.5, 0.5, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment})', ha='center', va='center', fontsize=16,fontweight='bold')    fig.savefig(plotpath+'/poster/'+f'meanBTper_iwc_forexp{experiment}.png', dpi=300,transparent=False, bbox_inches='tight')       plt.show()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_maps(rttov_as, isnow, igrau, experiment):        experiment = experiment+f's{isnow}g{igrau}'        plotpath, folders = config_folders(server)        instrument = 'MHS'    outfile    = 'output_tb_'+instrument    d_cs       = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        #extent = [ -64, -50, -40, -20]        extent = [ -65, -50, -40, -20]        #lonlon = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lon'].data)     #latlat = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lat'].data)         #lon_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lon'])    #lat_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lat'])    lonlon = d_cs['wrf_lon'].data     latlat = d_cs['wrf_lat'].data    lon_obs_cut = d_cs['MHS_lon']    lat_obs_cut = d_cs['MHS_lat']    fig, axes = plt.subplots(nrows=5, ncols=4, constrained_layout=True,figsize=[15,20])    axes = T2P.plot_MHS_row_WRFgrid_largeobs(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data, server, axes, 0, 'OBS')            for ii in range(4):        axes[0, ii].set_xlim([-64.3,-61.5])  #[-68,-62]);         axes[0, ii].set_ylim([-34.5,-31])   #[-36,-31])            T2P.plot_MHS_row_WRFgrid_large(lonlon, latlat, rttov_as['rttov_as'][isnow,igrau,:,:,:], server, axes, 1, 'EqMass_WSM6 (s3g3)')            T2P.plot_MHS_row_WRFgrid_large(lon_obs_cut, lat_obs_cut, rttov_as['rttov_as_Gaussian'][isnow,igrau,:,:,:], server, axes, 2, 'EqMass WSM6 (s9g9)')           T2P.plot_MHS_row_WRFgrid_large(lon_obs_cut, lat_obs_cut, rttov_as['rttov_as_mean'][isnow,igrau,:,:,:], server, axes, 3, 'WSM6 (s3g3)')            axes,pcm = T2P.plot_MHS_row_WRFgrid_large(lon_obs_cut, lat_obs_cut, rttov_as['rttov_as_Interp'][isnow,igrau,:,:,:], server, axes, 4, 'WSM6 (s9g9)')           for i in [1,2,3,4]:        for ii in range(4):            axes[i, ii].set_xlim([-64.2,-61.6])  #[-68,-62]);             axes[i, ii].set_ylim([-34.5,-31])   #[-36,-31])    axes[0,0].set_ylabel('wrf grid', fontweight='bold', fontsize=14)    axes[0,1].set_ylabel('gaussian', fontweight='bold', fontsize=14)    axes[0,2].set_ylabel('mean', fontweight='bold', fontsize=14)    axes[0,3].set_ylabel('interp.', fontweight='bold', fontsize=14)        cbar = fig.colorbar(pcm, ax=axes,orientation='vertical',fraction=0.2, pad=0.04)        plt.suptitle( f'{experiment}', fontweight='bold')    fig.savefig(plotpath+'/poster/'+f'{experiment}_allfootprintCs_maps_zoomout.png', dpi=300,transparent=False)       plt.show()    #plt.close()        return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_only_obs_maps(server):        plotpath, folders = config_folders(server)    # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'laptop' in server:        prov = np.genfromtxt("/Users/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/Users/vito.galligani/Work/Tools/etopo1_bedrock.nc'           mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    cmaps = T2P.GMI_colormap()     cmap = plt.cm.viridis  # Colormap    cmap.set_bad(color='gray')  # Color for NaN values        instrument = 'MHS'    outfile    = 'output_tb_'+instrument    d_cs       = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)        ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    channels_indexplot = [0,1,3,4]    fig, axes = plt.subplots(nrows=1, ncols=4, constrained_layout=True,figsize=[20,6])    for index, i in enumerate(channels_indexplot):        pcm = axes[index].pcolormesh(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data[i,:,:],  cmap=cmaps['turbo_r'],                                  shading='auto', vmin=50, vmax=300)        axes[index].set_title('MHS ('+ichan_title[index]+' GHz)')        axes[index].set_xlim([-65.5,-60]) #[-68,-62]);         axes[index].set_ylim([-34.5,-31])   #[-36,-31])        axes[index].plot(prov[:,0],prov[:,1],color='w');         axes[index].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)    cbar = fig.colorbar(pcm, ax=axes,orientation='vertical',fraction=0.2, pad=0.04)        #plt.suptitle( f'{experiment}', fontweight='bold')    fig.savefig(plotpath+'/poster/'+f'observationMHS_maps_zoomout.png', dpi=300,transparent=False)       plt.show()            return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_deltamaps(rttov_as, isnow, igrau, experiment):        experiment = experiment+f's{isnow}g{igrau}'        plotpath, folders = config_folders(server)        instrument = 'MHS'    outfile    = 'output_tb_'+instrument    d_cs       = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        #extent = [ -64, -50, -40, -20]        extent = [ -65, -50, -40, -20]        #lonlon = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lon'].data)     #latlat = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lat'].data)         #lon_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lon'])    #lat_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lat'])    lonlon = d_cs['wrf_lon'].data     latlat = d_cs['wrf_lat'].data    lon_obs_cut = d_cs['MHS_lon']    lat_obs_cut = d_cs['MHS_lat']    fig, axes = plt.subplots(nrows=5, ncols=4, constrained_layout=True,figsize=[15,20])    axes = T2P.plot_MHS_row_WRFgrid_largeobs(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data, server, axes, 0, 'OBS')            for ii in range(4):        axes[0, ii].set_xlim([-64.3,-61.5])  #[-68,-62]);         axes[0, ii].set_ylim([-34.5,-31])   #[-36,-31])            T2P.plot_MHS_row_WRFgrid_deltalarge(lonlon, latlat, rttov_as['delta_rttov_as'][isnow,igrau,:,:,:], server, axes, 1, 'EqMass_WSM6 (s3g3)')            T2P.plot_MHS_row_WRFgrid_deltalarge(lon_obs_cut, lat_obs_cut, rttov_as['delta_Gaussianan'][isnow,igrau,:,:,:], server, axes, 2, 'EqMass WSM6 (s9g9)')           T2P.plot_MHS_row_WRFgrid_deltalarge(lon_obs_cut, lat_obs_cut, rttov_as['delta_mean'][isnow,igrau,:,:,:], server, axes, 3, 'WSM6 (s3g3)')            axes,pcm = T2P.plot_MHS_row_WRFgrid_deltalarge(lon_obs_cut, lat_obs_cut, rttov_as['delta_Interp'][isnow,igrau,:,:,:], server, axes, 4, 'WSM6 (s9g9)')           for i in [1,2,3,4]:        for ii in range(4):            axes[i, ii].set_xlim([-64.2,-61.6])  #[-68,-62]);             axes[i, ii].set_ylim([-34.5,-31])   #[-36,-31])    axes[0,0].set_ylabel('wrf grid', fontweight='bold', fontsize=14)    axes[0,1].set_ylabel('gaussian', fontweight='bold', fontsize=14)    axes[0,2].set_ylabel('mean', fontweight='bold', fontsize=14)    axes[0,3].set_ylabel('interp.', fontweight='bold', fontsize=14)        cbar = fig.colorbar(pcm, ax=axes,orientation='vertical',fraction=0.2, pad=0.04)        plt.suptitle( r'$\Delta$BT [K] (BT(89clear)<250K) for'+f'{experiment}', fontweight='bold')    fig.savefig(plotpath+'/poster/'+f'{experiment}_delta_allfootprints_maps_zoomout.png', dpi=300,transparent=False)       #plt.close()    plt.show()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_iwc_row_(lonlon, latlat, iwc_snow, iwc_grau, iwc_tot, server, axes, col, experiment_name):        # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'       elif 'laptop' in server:        prov = np.genfromtxt("/Users/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/Users/vito.galligani/Work/Tools/etopo1_bedrock.nc'       # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)           pcm = axes[col, 0].pcolormesh(lonlon, latlat, iwc_snow,  cmap='viridis', vmin=0, vmax=20)    pcm = axes[col, 1].pcolormesh(lonlon, latlat, iwc_grau,  cmap='viridis', vmin=0, vmax=20)    pcm = axes[col, 2].pcolormesh(lonlon, latlat, iwc_tot,  cmap='viridis', vmin=0, vmax=20)    for ii in range(3):        axes[col, ii].set_xlim([-64.3,-61.5])  #[-68,-62]);         axes[col, ii].set_ylim([-34.5,-31])   #[-36,-31])              axes[col, ii].plot(prov[:,0],prov[:,1],color='w');         axes[col, ii].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)        axes[col, ii].set_xticklabels([])        axes[col, ii].set_yticklabels([])        axes[col,0].set_ylabel(experiment_name)        return axes, pcm#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_iwc_maps(iwc_data):            plotpath, folders = config_folders(server)        instrument = 'MHS'    outfile    = 'output_tb_'+instrument    d_cs       = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        extent = [ -65, -50, -40, -20]        lonlon = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lon'].data)     latlat = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lat'].data)         lonlon_ = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lon'])    latlat_ = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lat'])        fig, axes = plt.subplots(nrows=4, ncols=3, constrained_layout=True,figsize=[15,15])    plot_iwc_row_(lonlon, latlat, iwcontents['WRF_intqs_cut'], iwcontents['WRF_intqg_cut'], iwcontents['WRF_intTot_cut'], server, axes, 0, 'wrf grid')    plot_iwc_row_(lonlon_, latlat_, iwcontents['gaus_intqs_cut'], iwcontents['gaus_intqg_cut'], iwcontents['gaus_intTot_cut'], server, axes, 1, 'gaussian')    plot_iwc_row_(lonlon_, latlat_, iwcontents['mean_intqs_cut'], iwcontents['mean_intqg_cut'], iwcontents['mean_intTot_cut'], server, axes, 2, 'mean')    axes, pcm = plot_iwc_row_(lonlon_, latlat_, iwcontents['interp_intqs_cut'], iwcontents['interp_intqg_cut'], iwcontents['interp_intTot_cut'], server, axes, 3, 'interp')          cbar = fig.colorbar(pcm, ax=axes,orientation='vertical',fraction=0.2, pad=0.04)            axes[0,0].set_title('int. snow')    axes[0,1].set_title('int. grau')    axes[0,2].set_title('int. tot')        plt.suptitle( 'Footprint model on int. iwc', fontweight='bold')    fig.savefig(plotpath+'/RTTOV/'+f'footprint_intiiwc_maps_zoomout.png', dpi=300,transparent=False)       plt.show()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def check_hist2d(iwcontents, rttov_eqMass, rttov_WSM6):        import matplotlib.colors as colors        experiment = 'delta_Interp'    igrau = 3    isnow = 3         var_wrfgrid_eqMass   = rttov_eqMass[experiment].copy()    var_wrfgrid          = rttov_WSM6[experiment].copy()            #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    #For log hist2d:     x_bins = np.arange(0,20,2)    y_bins = np.arange(-250, -5, 5)    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')                x1   = iwcontents.flatten()        var1 = var_wrfgrid_eqMass[isnow,igrau,i,:,:].flatten()        mask1 = ~np.isnan(x1) & ~np.isnan(var1)        h = axes[0,index].hist2d(x1[mask1], var1[mask1], bins=[x_bins, y_bins], cmap='viridis', norm=colors.LogNorm())        fig.colorbar(h[3], ax=axes[0, index])       plt.show()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_hists_liu_Perisnow_grausp_simple(var_cut_liu, var_cut_grausp, experiment, title):     plotpath, folders = config_folders(server)    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']          # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # OJO QUE PARA HISTOGRAMS RECORTO LAS OBSERVACIONES!!!!     # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    #------------------------------------------------------    #---- One figure per isnow.     for isnow in range(11):        fig, axes = plt.subplots(nrows=2, ncols=2, constrained_layout=True, figsize=[8,8])         axes = axes.flatten()        # dummy legends        axes[0].plot([],[],linewidth=1.2, linestyle='-', color='k', label='Obs.')        for igrau in range(11):             axes[0].plot([],[],linewidth=1.2,linestyle='-', color=all_shades[isnow][igrau], label=f'{categories[igrau]}')        axes[0].plot([],[],linewidth=1.2,linestyle='-', color='gray', label=f'liu: softsphere')        fig.legend(loc='lower left', ncol=4, bbox_to_anchor=(0.03,-0.2), title='Graupel combination')        for index, i in enumerate(chan_indx):                    varobs2 =  d_cs['MHs_domain_obs'].data[i,:,:]            varobs2 = varobs2.flatten()                    for igrau in range(11):                 varliu  = var_cut_liu[experiment][isnow, igrau,i,:,:]                varliu  = varliu.flatten()                 counts, bin_edges = np.histogram(varliu, bins=np.arange(10,300,10),density=True)                bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2                axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color=all_shades[isnow][igrau])                #sns.kdeplot( data = varliu, color=all_shades[isnow][igrau], ax=axes[index], label=f's{isnow}g{igrau}', bw_adjust=0.1)#**kde_kws)                     counts, _ = np.histogram(varobs2, bins=np.arange(10,300,10), density=True)            axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='k', label='Obs')                 varliu  =  var_cut_grausp[experiment][isnow,i,:,:]            varliu  = varliu.flatten()             counts, _ = np.histogram(varliu, bins=np.arange(10,300,10), density=True)            axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='gray', label=f's{isnow}grausp')            axes[index].set_xlim([20,310])            axes[index].set_ylim([1e-4,0.1])               axes[index].grid(True)            axes[index].set_title(f'{ichan_title[index]}GHz')                #handles, labels = axes[0].get_legend_handles_labels()        #fig.legend(handles, labels,ncol=4, loc='lower right', bbox_to_anchor=(0.65,-0.15))        fig.suptitle(title+f' ({experiment}): snow ({categories[isnow]}) + grau combinations', fontweight='bold')        axes[index-1].set_xlabel('BT [K]')        axes[index-1].set_ylabel('Count')                #plt.show()        fig.savefig(plotpath+f'/poster/loghist_cloudy_rttov_histogram_s{str(isnow)}'+title+f'{experiment}.png', dpi=300,transparent=False,  bbox_inches='tight')           plt.close()        plt.show()    returndef get_counts(var):        var  = var.flatten()     counts, bin_edges = np.histogram(var, bins=np.arange(10,300,10),density=True)    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2        return counts, bin_centers#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_hists_liu_footprint_impact_4poster(var_cut_liu, isnow, igrau, title):     plotpath, folders = config_folders(server)    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']          # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    experiments = ['obs', 'wrf grid', 'gaussian', 'mean', 'nearest' ]    colors_     = ['k','k','darkblue','darkred','darkgreen']    #------------------------------------------------------    #---- One figure per isnow.     fig, axes = plt.subplots(nrows=1, ncols=4, figsize=[24,6])  #constrained_layout=True,     fig.subplots_adjust(hspace=0.2)    # # dummy legends    axes[0].plot([],[],linewidth=1.2, linestyle='--', color='k', label='Obs.')    for i in np.arange(1,5,1):        axes[0].plot([],[],linewidth=1.2, linestyle='-', color=colors_[i], label=experiments[i])    axes[0].legend(loc='upper left')            for index, i in enumerate(chan_indx):                varobs2 =  d_cs['MHs_domain_obs'].data[i,:,:]        varobs2 = varobs2.flatten()        counts, bin_edges= np.histogram(varobs2, bins=np.arange(10,300,10), density=True)        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2        axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='--', color='k', label='Obs')                counts, bin_center = get_counts(var_cut_liu['rttov_as'][isnow, igrau,i,:,:])        axes[index].semilogy(bin_center, counts, linewidth=1.3,linestyle='-', color=colors_[1], label='wrf grid')        counts, bin_center = get_counts(var_cut_liu['rttov_as_Gaussian'][isnow, igrau,i,:,:])        axes[index].semilogy(bin_center, counts, linewidth=1.2,linestyle='-', marker='o', color=colors_[2], label='gaussian')        counts, bin_center = get_counts(var_cut_liu['rttov_as_mean'][isnow, igrau,i,:,:])        axes[index].semilogy(bin_center, counts, linewidth=1.2,linestyle='-', marker='o', color=colors_[3], label='mean')                counts, bin_center = get_counts(var_cut_liu['rttov_as_Interp'][isnow, igrau,i,:,:])        axes[index].semilogy(bin_center, counts, linewidth=1.2,linestyle='-',marker='o', color=colors_[4], label='nearest')               axes[index].set_xlim([20,310])        #axes[index].set_ylim([1e-4,0.1])           axes[index].grid(True)        axes[index].set_title(f'{ichan_title[index]}GHz')            fig.suptitle(title+f'Impact of Footprint model on distribution of BTs for {title}', fontweight='bold')    axes[0].set_xlabel('BT [K]')    axes[0].set_ylabel('Count')            plt.show()    fig.savefig(plotpath+f'/poster/plot_FootprintimpactonDistrib_'+title+'.png', dpi=300,transparent=False,  bbox_inches='tight')       #plt.close()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_hists_liu_footprint_impact_4poster_v2(var_cut_liu, isnow, igrau, title):     plotpath, folders = config_folders(server)    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']          # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    experiments = ['obs', 'wrf grid', 'gaussian', 'nearest' ]    colors_     = ['k','k','darkred','darkgreen']    #------------------------------------------------------    #---- One figure per isnow.     fig, axes = plt.subplots(nrows=1, ncols=4, figsize=[24,6])  #constrained_layout=True,     fig.subplots_adjust(hspace=0.2)    # # dummy legends    axes[0].plot([],[],linewidth=1.2, linestyle='--', color='k', label='Obs.')    for i in np.arange(1,4,1):        axes[0].plot([],[],linewidth=1.2, linestyle='-', color=colors_[i], label=experiments[i])    axes[0].legend(loc='upper left')            for index, i in enumerate(chan_indx):                varobs2 =  d_cs['MHs_domain_obs'].data[i,:,:]        varobs2 = varobs2.flatten()        counts, bin_edges= np.histogram(varobs2, bins=np.arange(10,300,10), density=True)        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2        axes[index].plot(bin_centers, counts, linewidth=1.2,linestyle='--', color='k', label='Obs')                counts, bin_center = get_counts(var_cut_liu['rttov_as'][isnow, igrau,i,:,:])        axes[index].plot(bin_center, counts, linewidth=1.3,linestyle='-', color=colors_[1], label='wrf grid')        counts, bin_center = get_counts(var_cut_liu['rttov_as_Gaussian'][isnow, igrau,i,:,:])        axes[index].plot(bin_center, counts, linewidth=1.2,linestyle='-', color=colors_[2], label='gaussian')        counts, bin_center = get_counts(var_cut_liu['rttov_as_Interp'][isnow, igrau,i,:,:])        axes[index].plot(bin_center, counts, linewidth=1.2,linestyle='-', color=colors_[3], label='nearest')               axes[index].set_xlim([20,310])        #axes[index].set_ylim([1e-4,0.1])           axes[index].grid(True)        axes[index].set_title(f'{ichan_title[index]}GHz')            fig.suptitle(title+f'Impact of Footprint model on distribution of BTs for {title}', fontweight='bold')    axes[0].set_xlabel('BT [K]')    axes[0].set_ylabel('Count')            plt.show()    fig.savefig(plotpath+f'/poster/plot_simple_FootprintimpactonDistrib_'+title+'.png', dpi=300,transparent=False,  bbox_inches='tight')       #plt.close()    #------------------------------------------------------    #---- One figure per isnow.     fig, axes = plt.subplots(nrows=1, ncols=4, figsize=[24,6])  #constrained_layout=True,     fig.subplots_adjust(hspace=0.2)    # # dummy legends    axes[0].plot([],[],linewidth=1.2, linestyle='--', color='k', label='Obs.')    for i in np.arange(1,4,1):        axes[0].plot([],[],linewidth=1.2, linestyle='-', color=colors_[i], label=experiments[i])    axes[0].legend(loc='upper left')            for index, i in enumerate(chan_indx):                varobs2 =  d_cs['MHs_domain_obs'].data[i,:,:]        varobs2 = varobs2.flatten()        counts, bin_edges= np.histogram(varobs2, bins=np.arange(10,300,10), density=True)        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2        axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='--', color='k', label='Obs')                counts, bin_center = get_counts(var_cut_liu['rttov_as'][isnow, igrau,i,:,:])        axes[index].semilogy(bin_center, counts, linewidth=1.3,linestyle='-', color=colors_[1], label='wrf grid')        counts, bin_center = get_counts(var_cut_liu['rttov_as_Gaussian'][isnow, igrau,i,:,:])        axes[index].semilogy(bin_center, counts, linewidth=1.2,linestyle='-', color=colors_[2], label='gaussian')        counts, bin_center = get_counts(var_cut_liu['rttov_as_Interp'][isnow, igrau,i,:,:])        axes[index].semilogy(bin_center, counts, linewidth=1.2,linestyle='-', color=colors_[3], label='nearest')               axes[index].set_xlim([20,310])        #axes[index].set_ylim([1e-4,0.1])           axes[index].grid(True)        axes[index].set_title(f'{ichan_title[index]}GHz')            fig.suptitle(title+f'Impact of Footprint model on distribution of BTs for {title}', fontweight='bold')    axes[0].set_xlabel('BT [K]')    axes[0].set_ylabel('Count')            plt.show()    fig.savefig(plotpath+f'/poster/plot_log_FootprintimpactonDistrib_'+title+'.png', dpi=300,transparent=False,  bbox_inches='tight')       #plt.close()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_hists_liu_Perisnow_grausp_4poster(var_cut_liu, var_cut_grausp, experiment, title):     plotpath, folders = config_folders(server)    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']          # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # OJO QUE PARA HISTOGRAMS RECORTO LAS OBSERVACIONES!!!!     # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    #------------------------------------------------------    #---- One figure per isnow.     fig, axes = plt.subplots(nrows=1, ncols=4, figsize=[24,6])  #constrained_layout=True,     fig.subplots_adjust(hspace=0.2)    # dummy legends    axes[0].plot([],[],linewidth=1.2, linestyle='-', color='k', label='Obs.')    for igrau in range(11):         axes[0].plot([],[],linewidth=1.2,linestyle='-', color=all_shades[3][igrau], label=f'{categories[igrau]}')    axes[0].plot([],[],linewidth=1.2,linestyle='-', color='gray', label=f'softsphere')        axes[0].legend(loc='lower left', ncol=6, bbox_to_anchor=(-0.05,-0.5), title='Snow(Block hex col.) + graupel combinations')    #fig.legend(loc='lower left', ncol=4, bbox_to_anchor=(0.03,-0.2), title='Snow(Block hex col.) + graupel combinations')    for igrau in range(11):         axes[1].plot([],[],linewidth=1.2,linestyle='-', color=all_shades[9][igrau], label=f'{categories[igrau]}')    axes[1].plot([],[],linewidth=1.2,linestyle='-', color='darkgray', label=f'softsphere')    axes[1].legend(loc='lower left', ncol=6, bbox_to_anchor=(-1.25,-0.75), title='Snow(sector) + graupel combinations')    #fig.legend(loc='lower left', ncol=6, bbox_to_anchor=(0.4,-0.2), title='Combinations')            for index, i in enumerate(chan_indx):                varobs2 =  d_cs['MHs_domain_obs'].data[i,:,:]        varobs2 = varobs2.flatten()                for igrau in range(11):             varliu  = var_cut_liu[experiment][3, igrau,i,:,:]            varliu  = varliu.flatten()             counts, bin_edges = np.histogram(varliu, bins=np.arange(10,300,10),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color=all_shades[3][igrau])        for igrau in range(11):             varliu  = var_cut_liu[experiment][9, igrau,i,:,:]            varliu  = varliu.flatten()             counts, bin_edges = np.histogram(varliu, bins=np.arange(10,300,10),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color=all_shades[9][igrau])        counts, _ = np.histogram(varobs2, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='k', label='Obs')             varliu  =  var_cut_grausp[experiment][3,i,:,:]        varliu  = varliu.flatten()         counts, _ = np.histogram(varliu, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='gray')        varliu  =  var_cut_grausp[experiment][9,i,:,:]        varliu  = varliu.flatten()         counts, _ = np.histogram(varliu, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=1.2,linestyle='-', color='darkgray')                axes[index].set_xlim([20,310])        axes[index].set_ylim([1e-4,0.1])           axes[index].grid(True)        axes[index].set_title(f'{ichan_title[index]}GHz')            fig.suptitle(title+f' ({experiment}): snow + grau combinations', fontweight='bold')    axes[0].set_xlabel('BT [K]')    axes[0].set_ylabel('Count')            plt.show()    fig.savefig(plotpath+f'/poster/loghist_cloudy_rttov_histogram_s3y9_4poster'+title+f'{experiment}.png',                 dpi=300,transparent=False,  bbox_inches='tight')       #plt.close()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_hists_liu_Perisnow_grausp_4poster_othercolors(var_cut_liu, var_cut_grausp, experiment, title):     plt.matplotlib.rc('font', family='serif', size = 16)    plt.rcParams['xtick.labelsize']=16    plt.rcParams['ytick.labelsize']=16          plotpath, folders = config_folders(server)    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']      do_thisSSPs = [2,5,8, 9,10]        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # OJO QUE PARA HISTOGRAMS RECORTO LAS OBSERVACIONES!!!!     # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0', '190.311'] #'183.311$\pm$3',    chan_indx   = [0,1,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    #------------------------------------------------------    #---- One figure per isnow.     fig, axes = plt.subplots(nrows=1, ncols=3, figsize=[24,5])  #constrained_layout=True,     fig.subplots_adjust(hspace=0.6)    # dummy legends    axes[0].plot([],[],linewidth=1.2, linestyle='-', color='k', label='Obs.')    for igrau in do_thisSSPs:        axes[0].plot([],[],linewidth=1.2,linestyle='-', color=base_colors[igrau], label=f'{categories[igrau]}')    axes[0].plot([],[],linewidth=1.2,linestyle='-', color='gray', label=f'softsphere')        axes[0].legend(loc='lower left', ncol=7, bbox_to_anchor=(-0.05,-0.4), title='Graupel combinations')    #fig.legend(loc='lower left', ncol=4, bbox_to_anchor=(0.03,-0.2), title='Snow(Block hex col.) + graupel combinations')    axes[1].plot([],[],linewidth=1.2,linestyle='-', color='k', label=f'Snow(Block hex col.) combinations')    axes[1].plot([],[],linewidth=1.2,linestyle='--', color='k', label=f'Snow(sector) combinations')    axes[1].legend(loc='lower left', ncol=6, bbox_to_anchor=(-1.25,-0.55))    #fig.legend(loc='lower left', ncol=6, bbox_to_anchor=(0.4,-0.2), title='Combinations')            for index, i in enumerate(chan_indx):                varobs2 =  d_cs['MHs_domain_obs'].data[i,:,:]        varobs2 = varobs2.flatten()                for igrau in do_thisSSPs:             varliu  = var_cut_liu[experiment][3, igrau,i,:,:]            varliu  = varliu.flatten()             counts, bin_edges = np.histogram(varliu, bins=np.arange(10,300,10),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color=base_colors[igrau])        for igrau in do_thisSSPs:             varliu  = var_cut_liu[experiment][9, igrau,i,:,:]            varliu  = varliu.flatten()             counts, bin_edges = np.histogram(varliu, bins=np.arange(10,300,10),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='--', color=base_colors[igrau])        counts, _ = np.histogram(varobs2, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color='k', label='Obs')             varliu  =  var_cut_grausp[experiment][3,i,:,:]        varliu  = varliu.flatten()         counts, _ = np.histogram(varliu, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color='gray')        varliu  =  var_cut_grausp[experiment][9,i,:,:]        varliu  = varliu.flatten()         counts, _ = np.histogram(varliu, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color='darkgray')                axes[index].set_xlim([20,290])        axes[index].set_ylim([1e-4,0.1])           axes[index].grid(True)        axes[index].set_title(f'{ichan_title[index]}GHz')            if 'Mass' in title:        fig.suptitle(f'eqMass approach: snow + grau combinations', fontweight='bold',y=1.02)    else:        fig.suptitle(f'iwc rescaling approach: snow + grau combinations', fontweight='bold',y=1.02)            axes[0].set_xlabel('BT [K]')    axes[0].set_ylabel('Count')            plt.show()    fig.savefig(plotpath+f'/poster/loghist_cloudy_rttov_histogram_s3y9_4poster_v2'+title+f'{experiment}.png',                 dpi=300,transparent=False,  bbox_inches='tight')       #plt.close()    return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_hists_liu_Perisnow_grausp_4poster_othercolors_sieron(var_cut_liu, experiment, title):         # Sieron for now has 0-9graupel species for isnow=3 and isnow=9    plt.matplotlib.rc('font', family='serif', size = 16)    plt.rcParams['xtick.labelsize']=16    plt.rcParams['ytick.labelsize']=16          plotpath, folders = config_folders(server)    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']          do_thisSSPs = [2,5,8, 9,10]    # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # OJO QUE PARA HISTOGRAMS RECORTO LAS OBSERVACIONES!!!!     # Histoplot params    #------------------------------------------------------    ichan_title = ['89.0', '157.0',  '190.311'] #    chan_indx   = [0,1,4]    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]          all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    #------------------------------------------------------    #---- One figure per isnow.     fig, axes = plt.subplots(nrows=1, ncols=3, figsize=[24,5])  #constrained_layout=True,     fig.subplots_adjust(hspace=0.2)    # dummy legends    axes[0].plot([],[],linewidth=1.2, linestyle='-', color='k', label='Obs.')    for igrau in do_thisSSPs:         axes[0].plot([],[],linewidth=1.2,linestyle='-', color=base_colors[igrau], label=f'{categories[igrau]}')    #axes[0].plot([],[],linewidth=1.2,linestyle='-', color='gray', label=f'softsphere')        axes[0].legend(loc='lower left', ncol=7, bbox_to_anchor=(-0.05,-0.4), title='Graupel combinations')    #fig.legend(loc='lower left', ncol=4, bbox_to_anchor=(0.03,-0.2), title='Snow(Block hex col.) + graupel combinations')    axes[1].plot([],[],linewidth=1.2,linestyle='-', color='k', label=f'Snow(Block hex col.) combinations')    axes[1].plot([],[],linewidth=1.2,linestyle='--', color='k', label=f'Snow(sector) combinations')    axes[1].legend(loc='lower left', ncol=6, bbox_to_anchor=(-1.25,-0.55))    #fig.legend(loc='lower left', ncol=6, bbox_to_anchor=(0.4,-0.2), title='Combinations')            for index, i in enumerate(chan_indx):                varobs2 =  d_cs['MHs_domain_obs'].data[i,:,:]        varobs2 = varobs2.flatten()                for igrau in do_thisSSPs:             varliu  = var_cut_liu[experiment][2,igrau,i,:,:]            varliu  = varliu.flatten()             counts, bin_edges = np.histogram(varliu, bins=np.arange(10,300,10),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color=base_colors[igrau])        for igrau in do_thisSSPs:             varliu  = var_cut_liu[experiment][9, igrau,i,:,:]            varliu  = varliu.flatten()             counts, bin_edges = np.histogram(varliu, bins=np.arange(10,300,10),density=True)            bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2            axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='--', color=base_colors[igrau])        counts, _ = np.histogram(varobs2, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color='k', label='Obs')             varliu  = varliu.flatten()         counts, _ = np.histogram(varliu, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color='gray')        varliu  = varliu.flatten()         counts, _ = np.histogram(varliu, bins=np.arange(10,300,10), density=True)        axes[index].semilogy(bin_centers, counts, linewidth=2,linestyle='-', color='darkgray')                axes[index].set_xlim([20,290])        axes[index].set_ylim([1e-4,0.1])           axes[index].grid(True)        axes[index].set_title(f'{ichan_title[index]}GHz')            fig.suptitle(f'M(D) Sieron et al. 2018 approach: snow + grau combinations', fontweight='bold', y=1.02)    axes[0].set_xlabel('BT [K]')    axes[0].set_ylabel('Count')            plt.show()    fig.savefig(plotpath+f'/poster/loghist_cloudy_sieron_rttov_histogram_s3y9_4poster_v2'+title+f'{experiment}.png',                 dpi=300,transparent=False,  bbox_inches='tight')       #plt.close()    return#------------------------------------------------------------------------------------------ # calculate the difference between half-grau and half-rain for s3g3 y s9g5. def iwc_impactbarplot(rttov,iparticle, title):    import matplotlib.patches as mpatches  # Add this at the top of your script    plotpath, folders = config_folders(server)    # Define bin edges    bin_edges = np.array([50, 100, 150, 200, 250])    # Prepare to store results    differences_halfs = np.zeros((5,4)); differences_halfs[:]=np.nan    differences_halfg = np.zeros((5,4)); differences_halfg[:]=np.nan    differences_halfsg = np.zeros((5,4)); differences_halfsg[:]=np.nan                    for ii in range(5):        # Loop over each bin        for i in range(len(bin_edges) - 1):            low = bin_edges[i]            high = bin_edges[i+1]                        exp_Control   = rttov['control'][iparticle,ii,:,:].flatten()            exp_halfsnow  = rttov['halfsnow'][iparticle,ii,:,:].flatten()            exp_halfgrau  = rttov['halfgrau'][iparticle,ii,:,:].flatten()            exp_halfgrausnow  = rttov['halfgrausnow'][iparticle,ii,:,:].flatten()                        # Mask where exp_Control is within the bin            mask = (exp_Control >= low) & (exp_Control < high)                        # Calculate difference only in that bin            diff_in_bin = exp_Control[mask] - exp_halfsnow[mask]            differences_halfs[ii,i] = np.nanmean(diff_in_bin)                # Calculate difference only in that bin            diff_in_bin = exp_Control[mask] - exp_halfgrau[mask]            differences_halfg[ii,i] = np.nanmean(diff_in_bin)            # Calculate difference only in that bin            diff_in_bin = exp_Control[mask] - exp_halfgrausnow[mask]            differences_halfsg[ii,i] = np.nanmean(diff_in_bin)                ichan_title     = ['89.0', '157.0', '183.311$\pm$3', '190.311']    experiments = ['half snow', 'half grau', 'halfsnowandgrau']    colors_     = ['darkblue','darkred','darkgreen']    x           = np.arange(2)  # the label locations    width       = 10        # the width of the bars    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2  # (length 4)    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=1, ncols=4,  figsize=[16,4])    #constrained_layout=True,    axes[0].bar( bin_centers, differences_halfg[0,:].flatten(), width, color='darkblue')    axes[0].bar( bin_centers+10, differences_halfs[0,:], width, color='darkred')    axes[0].bar( bin_centers+20, differences_halfsg[0,:], width, color='darkgreen')    axes[0].set_title(ichan_title[0]+' GHz')    axes[1].bar( bin_centers, differences_halfg[1,:].flatten(), width, color='darkblue')    axes[1].bar( bin_centers+10, differences_halfs[1,:], width, color='darkred')    axes[1].bar( bin_centers+20, differences_halfsg[1,:], width, color='darkgreen')    axes[1].set_title(ichan_title[1]+' GHz')    axes[2].bar( bin_centers, differences_halfg[3,:].flatten(), width, color='darkblue')    axes[2].bar( bin_centers+10, differences_halfs[3,:], width, color='darkred')    axes[2].bar( bin_centers+20, differences_halfsg[3,:], width, color='darkgreen')    axes[2].set_title(ichan_title[2]+' GHz')            axes[3].bar( bin_centers, differences_halfg[4,:].flatten(), width, color='darkblue')    axes[3].bar( bin_centers+10, differences_halfs[4,:], width, color='darkred')    axes[3].bar( bin_centers+20, differences_halfsg[4,:], width, color='darkgreen')    axes[3].set_title(ichan_title[3]+' GHz')    for i in range(4):        axes[i].set_xticks(bin_centers)        axes[i].grid(True)        axes[i].set_ylim([-60,10])        # axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')            axes[0].set_xlabel('BT [K]')    axes[0].set_ylabel(r'$\Delta$BT (due to iwc change) [K]')        legend_elements = [ mpatches.Patch(facecolor=colors_[i], label=f'{experiments[i]}') for i in range(3) ]    fig.legend(        handles=legend_elements, ncol=3,         loc='lower left',bbox_to_anchor=(0.2, -0.12))    #axes[0].set_title(title, fontweight='bold')    fig.text(0.5, 0.98, title, ha='center', va='center', fontsize=16,fontweight='bold')    plt.show()    fig.savefig(plotpath+f'/poster/iwc_barplot_impact'+title+'.png',                 dpi=300,transparent=False,  bbox_inches='tight')          return # cd datosmunin3/Work/Studies/HAILCASE_10112018/src/rttov_call/#------------------------------------------------------------------------------------------#------------------------------------------------------------------------------------------server = 'laptop'mp_physics = 'WRF-WSM6'run_get_values_percentilesdiff = 0already_run_final = 0# Select server and folder locations#--------------------------------------------------------------------------if 'yakaira' in server:     upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'    sys.path.insert(1,'/home/vito.galligani/datosmunin3/Work/Studies/HAILCASE_10112018/src')    processedFolder = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/Processed/'+mp_physics    mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'            elif 'cnrm' in server:    upfolder    = '/home/galliganiv/'       sys.path.insert(1,'/home/galliganiv/ACMS_hail/src')    processedFolder = '/home/galliganiv/Work/HAILCASE_10112018/RTTOVinout/Processed/'+mp_physics    mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'elif 'laptop' in server:    sys.path.insert(1,'/Users/vito.galligani/Work/Studies/HAIL_20181110/src')    processedFolder = '/Users/vito.galligani/Work/Studies/HAIL_20181110/RTTOVout/Processed/'+mp_physics        rttov_sieron     = get_liuliu_sieron_experiments_andcut('rttov_processed_allsky_sieron_rsg_s', processedFolder)rttov_eqMass     = get_liuliu_experiments_andcut('rttov_processed_allsky_eqMass_rsg_s', processedFolder)rttov_WSM6       = get_liuliu_experiments_andcut('rttov_processed_allsky_rsg_s', processedFolder)rttov_eqMass_graupsp = get_liu_grausp_experiments_andcut('rttov_processed_allsky_eqMass_rsg_s', processedFolder)rttov_WSM6_graupsp   = get_liu_grausp_experiments_andcut('rttov_processed_allsky_rsg_s', processedFolder)if run_get_values_percentilesdiff == 1:    make_barplots_liuliu_poster('wrf grid', rttov_eqMass, rttov_WSM6, rttov_sieron, server)    make_barplots_liuliu_poster_BTs('wrf grid', rttov_eqMass, rttov_WSM6, rttov_sieron, server)    #------------------------------------------------------------------------------if run_get_values_percentilesdiff == 1:        #------------------------------------------------------------------------------------------    rttov_eqMass           = get_liuliu_experiments_andcut('rttov_processed_allsky_eqMass_rsg_s', processedFolder)    data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_eqMass)    p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'gaussian')     p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'delta_mean')     p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'delta_Interp')     rttov_WSM6             = get_liuliu_experiments_andcut('rttov_processed_allsky_rsg_s', processedFolder)        data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_WSM6)    p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'gaussian')     p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'delta_mean')     p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'delta_Interp')     data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_sieron)    p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'gaussian')     p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'delta_mean')     p89, p157, p190 = get_diffin_15percentiles(15, data_array_0, data_array_1, data_array_4, 'delta_Interp') #------------------------------------------------------------------------------------------# Lots of experiments now. I want to # 1) Look at histograms for experiiments on iwc#------------------------------------------------------------------------------------------if already_run_final == 1:    make_histogram_iwc_impacts(server, processedFolder) # 2) Barplots of the impact of the different liuliu combinations #------------------------------------------------------------------------------------------if already_run_final == 1:                                                   make_barplots_liuliu('wrf grid', rttov_eqMass, rttov_WSM6, rttov_sieron, server)# 3) Barplots of the impact of the different lantenna resolutions? for liu3 ad liu9 (w/ whiskers)#------------------------------------------------------------------------------------------if already_run_final == 1:    make_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server)    make_distrib_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server)# 4) impact of IWC sensitivities depending on footprint model#------------------------------------------------------------------------------------------ iwcontents = get_iwc_experiments_andcut(processedFolder)if already_run_final == 1:    analysis_function_iwc(iwcontents['WRF_intTot_cut'],   rttov_eqMass, rttov_WSM6, 'delta_rttov_as', server)    analysis_function_iwc(iwcontents['interp_intTot_cut'], rttov_eqMass, rttov_WSM6, 'delta_Interp', server )    analysis_function_iwc(iwcontents['mean_intTot_cut'],  rttov_eqMass, rttov_WSM6, 'delta_mean', server)    analysis_function_iwc(iwcontents['gaus_intTot_cut'],  rttov_eqMass, rttov_WSM6, 'delta_Gaussianan', server)    #check_hist2d(iwcontents['interp_intTot_cut'], rttov_eqMass, rttov_WSM6)    # 5) General maps for the different footprints#------------------------------------------------------------------------------------------ rttov_eqMass_full = get_liuliu_experiments_NOcut('rttov_processed_allsky_eqMass_rsg_s', processedFolder)rttov_WSM6_full = get_liuliu_experiments_NOcut('rttov_processed_allsky_rsg_s', processedFolder)if already_run_final == 1:    make_maps(rttov_eqMass_full, 3, 3, 'eqMass_WSM6')    make_maps(rttov_eqMass_full, 9, 9, 'eqMass_WSM6')    make_maps(rttov_WSM6_full, 3, 3, 'WSM6')    make_maps(rttov_WSM6_full, 9, 9, 'WSM6')        make_deltamaps(rttov_eqMass_full, 3, 3, 'eqMass_WSM6')    make_deltamaps(rttov_eqMass_full, 9, 9, 'eqMass_WSM6')    make_deltamaps(rttov_WSM6_full, 3, 3, 'WSM6')    make_deltamaps(rttov_WSM6_full, 9, 9, 'WSM6')           # 6) IWC footprint impact if already_run_final == 1:    make_iwc_maps(iwcontents)# 7) Main histograms for poster#------------------------------------------------------------------------------------------ if already_run_final == 1:                                                   make_hists_liu_Perisnow_grausp_4poster_othercolors(rttov_eqMass, rttov_eqMass_graupsp, 'rttov_as','eqMass_WSM6')     make_hists_liu_Perisnow_grausp_4poster_othercolors(rttov_WSM6, rttov_WSM6_graupsp, 'rttov_as','WSM6')     make_hists_liu_Perisnow_grausp_4poster_othercolors_sieron(rttov_sieron, 'rttov_as','sieron')if already_run_final == 1:    make_hists_liu_Perisnow_grausp_simple(rttov_eqMass, rttov_eqMass_graupsp, 'rttov_as','eqMass_WSM6')     make_hists_liu_Perisnow_grausp_simple(rttov_WSM6, rttov_WSM6_graupsp, 'rttov_as','WSM6')     make_hists_liu_Perisnow_grausp_simple(rttov_eqMass, rttov_eqMass_graupsp, 'rttov_as_Gaussian','eqMass_WSM6')     make_hists_liu_Perisnow_grausp_simple(rttov_WSM6, rttov_WSM6_graupsp, 'rttov_as_Gaussian','WSM6')     make_hists_liu_Perisnow_grausp_simple(rttov_eqMass, rttov_eqMass_graupsp, 'rttov_as_mean','eqMass_WSM6')     make_hists_liu_Perisnow_grausp_simple(rttov_WSM6, rttov_WSM6_graupsp, 'rttov_as_mean','WSM6')     make_hists_liu_Perisnow_grausp_simple(rttov_eqMass, rttov_eqMass_graupsp, 'rttov_as_Interp','eqMass_WSM6')     make_hists_liu_Perisnow_grausp_simple(rttov_WSM6, rttov_WSM6_graupsp, 'rttov_as_Interp','WSM6')         make_hists_liu_Perisnow_grausp_4poster(rttov_eqMass, rttov_eqMass_graupsp, 'rttov_as','eqMass_WSM6')     make_hists_liu_Perisnow_grausp_4poster(rttov_WSM6, rttov_WSM6_graupsp, 'rttov_as','WSM6')     #- sieron    rttov_sieron_full = get_liuliu_sieron_experiments_NOcut('rttov_processed_allsky_sieron_rsg_s', processedFolder)    make_maps(rttov_sieron_full, 1, 5, 'sieron')     #  the one here == 9# 8) Only obserbations map#------------------------------------------------------------------------------------------ if already_run_final == 1:    make_only_obs_maps('laptop')  # 50-300  # 9) Need to explain 1) where in the distribuion of BTs the most impact of the foorprint? deepconvectionno. rather most startiform? #------------------------------------------------------------------------------------------ if already_run_final == 1:    make_hists_liu_footprint_impact_4poster(rttov_eqMass, 9, 9,'eqMass_s9g9')    make_hists_liu_footprint_impact_4poster(rttov_eqMass, 3, 3,'eqMass_s3g3')    make_hists_liu_footprint_impact_4poster(rttov_WSM6_full, 9, 9,'WSM6_s9g9')    make_hists_liu_footprint_impact_4poster(rttov_WSM6_full, 3, 3,'WSM6_s3g3')    make_hists_liu_footprint_impact_4poster(rttov_eqMass, 9, 5,'eqMass_s9g5')    #make_hists_liu_footprint_impact_4poster_notlog(rttov_eqMass, 9, 3,'sieron_s9g3')    #make_hists_liu_footprint_impact_4poster_notlog(rttov_eqMass, 9, 9,'sieron_s9g9')if already_run_final == 1:    # Looking at distributions, looks like combinations s9g and 3b ros. == s9g5 loooks ok     #categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',    #               '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']      make_maps(rttov_WSM6_full, 9, 5, 'WSM6')        make_maps(rttov_eqMass_full, 9, 5, 'eqMass_WSM6')        make_maps(rttov_WSM6_full, 9, 9, 'sieron')        make_maps(rttov_WSM6_full, 9, 5, 'sieron')    #------------------------------------------------------------------------------------------if already_run_final == 1:    rttov_as_iwc_eqMass, _             = get_iwc_experiment_andcut( 'rttov_processed_allsky_eqMass_rsg_s', processedFolder)    rttov_as_iwc_WSM6, cloudmask_WRF   = get_iwc_experiment_andcut( 'rttov_processed_allsky_rsg_s', processedFolder)               # ESTOS SOLO CALCULE S3G3 Y S9G9     iwc_impactbarplot(rttov_as_iwc_eqMass, 0, 'eqMass_WSM6_s3g3')    iwc_impactbarplot(rttov_as_iwc_eqMass, 1, 'eqMass_WSM6_s9g9')    iwc_impactbarplot(rttov_as_iwc_WSM6, 0, 'WSM6_s3g3')    iwc_impactbarplot(rttov_as_iwc_WSM6, 1, 'WSM6_s9g9')#------------------------------------------------------------------------------------------        