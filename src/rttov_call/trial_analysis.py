import Tools2Plot as T2Pimport seaborn as sns import numpy as npimport xarray as xrfrom config import config_foldersimport sysimport matplotlib.pyplot as pltimport netCDF4 as ncplt.matplotlib.rc('font', family='serif', size = 16)plt.rcParams['xtick.labelsize']=16plt.rcParams['ytick.labelsize']=16  #------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain(extent, d_cs, Tc):        lon = d_cs['wrf_lon'].data    lat = d_cs['wrf_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[:, row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")            return Tc_crop#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain2d(extent, d_cs, var2d):        lon = d_cs['wrf_lon'].data    lat = d_cs['wrf_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        var2d_crop = var2d[row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")        return var2d_crop#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain2d_gaussian(extent, d_cs, var2d):        lon = d_cs['MHS_lon'].data    lat = d_cs['MHS_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        var2d_crop = var2d[row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")    return var2d_crop[2:,:]#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_2snowsample(extent, isnow_ranges, d_cs, tb_rttov):        var_cut    = []    for isnow in range(isnow_ranges):        var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,0,:,:,:])        var_cut.append(var_cut1)          var_cut = np.array(var_cut)                return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain_gaussian(extent, d_cs, Tc):        lon = d_cs['MHS_lon'].data    lat = d_cs['MHS_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[:, row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")        return Tc_crop[:,2:,:]#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu(extent, d_cs, tb_rttov):        # use extent to limit     var_cut    = []    for isnow in range(11):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu_gaus(extent, d_cs, tb_rttov):        var_cut    = []    for isnow in range(11):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain_gaussian(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liuliu_experiments_andcut(experiment, processedFolder):        #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for i in range(11):        rowi  = []; rowig  = []; rowim  = []; rowiN  = []        drowi = []; drowig = []; drowim = []; drowiN = []                for  j in range(11):            expname     = experiment+str(i)+'g'+str(j)+'.nc'            d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)            var         = d_liuliu['rttov_as'].values            var_gaus    = d_liuliu['rttov_as_Gaussianantennasigma_'].values            var_mean    = d_liuliu['rttov_as_footprintmean'].values            var_interp  = d_liuliu['rttov_as_pointInterpNearest'].values                        rowi.append(var)            rowig.append(var_gaus)            rowim.append(var_mean)            rowiN.append(var_interp)            drowi.append(var-tb_cs)            drowig.append(var_gaus-tb_cs_gaus)            drowim.append(var_mean-tb_cs_mean)            drowiN.append(var_interp-tb_cs_interp)                    tb_as.append(rowi)        tb_as_gaus.append(rowig)        tb_as_mean.append(rowi)        tb_as_interp.append(rowi)        dtb_as.append(drowi)        dtb_as_gaus.append(drowig)        dtb_as_mean.append(drowim)        dtb_as_interp.append(drowi)            tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            #WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     #cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)         rttov_as =dict({'rttov_as':          cut_extent_liuliu(extent, d_cs, tb_as),                     'rttov_as_Gaussian': cut_extent_liuliu_gaus(extent, d_cs, tb_as_gaus),                     'rttov_as_mean':     cut_extent_liuliu_gaus(extent, d_cs, tb_as_mean),                    'rttov_as_Interp':   cut_extent_liuliu_gaus(extent, d_cs, tb_as_interp),                    'delta_rttov_as':    cut_extent_liuliu(extent, d_cs, dtb_as),                    'delta_Gaussianan':  cut_extent_liuliu_gaus(extent, d_cs, dtb_as_gaus),                     'delta_mean':        cut_extent_liuliu_gaus(extent, d_cs, dtb_as_mean),                     'delta_Interp':      cut_extent_liuliu_gaus(extent, d_cs, dtb_as_interp) })             return rttov_as#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liuliu_experiments_NOcut(experiment, processedFolder):        instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for i in range(11):        rowi  = []; rowig  = []; rowim  = []; rowiN  = []        drowi = []; drowig = []; drowim = []; drowiN = []                for  j in range(11):            expname     = experiment+str(i)+'g'+str(j)+'.nc'            d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)            var         = d_liuliu['rttov_as'].values            var_gaus    = d_liuliu['rttov_as_Gaussianantennasigma_'].values            var_mean    = d_liuliu['rttov_as_footprintmean'].values            var_interp  = d_liuliu['rttov_as_pointInterpNearest'].values                        rowi.append(var)            rowig.append(var_gaus)            rowim.append(var_mean)            rowiN.append(var_interp)            drowi.append(var-tb_cs)            drowig.append(var_gaus-tb_cs_gaus)            drowim.append(var_mean-tb_cs_mean)            drowiN.append(var_interp-tb_cs_interp)                    tb_as.append(rowi)        tb_as_gaus.append(rowig)        tb_as_mean.append(rowim)        tb_as_interp.append(rowiN)        dtb_as.append(drowi)        dtb_as_gaus.append(drowig)        dtb_as_mean.append(drowim)        dtb_as_interp.append(drowiN)            tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            #WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     #cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)         rttov_as_nocut =dict({'rttov_as':          tb_as,                     'rttov_as_Gaussian': tb_as_gaus,                     'rttov_as_mean':     tb_as_mean,                    'rttov_as_Interp':   tb_as_interp,                    'delta_rttov_as':    dtb_as,                    'delta_Gaussianan':  dtb_as_gaus,                     'delta_mean':        dtb_as_mean,                     'delta_Interp':      dtb_as_interp })             return rttov_as_nocut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_iwc_experiments_andcut(processedFolder):        #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]    instrument = 'MHS'    outfile    = 'output_tb_'+instrument    # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        WRFvars    = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')            WRF_intqs_cut  = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intqs'].data)     WRF_intqg_cut  = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intqg'].data)     WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)         interp_intqs_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSinterp_intqs'].data)     interp_intqg_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSinterp_intqg'].data)     interp_intTot_cut = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSinterp_intTot'].data)     mean_intqs_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSfootprintmean_intqs'].data)     mean_intqg_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSfootprintmean_intqg'].data)     mean_intTot_cut = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSfootprintmean_intTot'].data)     gaus_intqs_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSGaussian_intqs'].data)     gaus_intqg_cut  = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSGaussian_intqg'].data)     gaus_intTot_cut = get_maskedDomain2d_gaussian(extent, d_cs, WRFvars['MHSGaussian_intTot'].data)                     iwcontents = dict({'WRF_intTot_cut': WRF_intTot_cut,                         'WRF_intqg_cut':  WRF_intqg_cut,                       'WRF_intqs_cut':  WRF_intqs_cut,                        'interp_intqs_cut':  interp_intqs_cut,                        'interp_intqg_cut':  interp_intqg_cut,                         'interp_intTot_cut': interp_intTot_cut,                        'mean_intqs_cut':  mean_intqs_cut,                        'mean_intTot_cut': mean_intTot_cut,                       'mean_intqg_cut':  mean_intqg_cut,                        'gaus_intqs_cut':  gaus_intqs_cut,                        'gaus_intqg_cut':  gaus_intqg_cut,                        'gaus_intTot_cut': gaus_intTot_cut})                 return iwcontents#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_iwc_experiment_andcut(experiment_1, processedFolder):        #extent = [ -64, -50, -40, -20]    extent = [ -65, -50, -40, -20]        # rttov clearsky simulations    instrument = 'MHS'    outfile   = 'output_tb_'+instrument    d_cs      = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # 1st Read nc files     #------------------------------------------------------------------------------------------    # WRF data     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')    WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)     lonlon    = WRFvars['wrf_lon'].data    latlat    = WRFvars['wrf_lat'].data    nx,ny=np.shape(lonlon)        tb_liuliu_snowhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_snowhalfiwc[:]=np.nan    tb_liuliu_grauhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_grauhalfiwc[:]=np.nan    tb_liuliu_grausnowhalfiwc = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_grausnowhalfiwc[:]=np.nan    tb_liuliu_rainhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_rainhalfiwc[:]=np.nan    tb_liuliu_noiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_noiwc[:]=np.nan    tb_liuliu_onlysnow  = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlysnow[:]=np.nan    tb_liuliu_onlygrau  = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlygrau[:]=np.nan    tb_liuliu_onlyrain  = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlyrain[:]=np.nan    tb_liuliu_onlyice   = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlyice[:]=np.nan        tb_liugrausp_onlygrau  = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liugrausp_onlygrau[:]=np.nan        tb_as_liuliu    = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_as_liuliu[:]=np.nan        liuopts = [3,9]    counter = 0    for i in liuopts:                expname     = experiment_1+str(i)+'g'+str(i)+'.nc'        d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var         = d_liuliu['rttov_as'].values        tb_as_liuliu[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'grau_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_grauhalfiwc[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'snow_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_snowhalfiwc[counter,0,:,:,:] = var                         expname = experiment_1+str(i)+'g'+str(i)+'rain_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_rainhalfiwc[counter,0,:,:,:] = var                          expname = experiment_1+str(i)+'g'+str(i)+'grausnow_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_grausnowhalfiwc[counter,0,:,:,:] = var          expname = experiment_1+str(i)+'g'+str(i)+'noiwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_noiwc[counter,0,:,:,:] = var                  expname = experiment_1+str(i)+'g'+str(i)+'onlygrau'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_onlygrau[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'onlysnow'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_onlysnow[counter,0,:,:,:] = var              counter = counter+1        i = 9    expname = experiment_1+str(i)+'g'+str(i)+'onlyrain'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liuliu_onlyrain[0,0,:,:,:] = var                      expname = experiment_1+str(i)+'g'+str(i)+'onlyice'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liuliu_onlyice[0,0,:,:,:] = var          # add only grau with soft sphere    expname = experiment_1+'3grausp'+'onlygrau'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liugrausp_onlygrau[0,0,:,:,:] = var                    rttov_as =dict({'control':      cut_extent_2snowsample(extent, 2, d_cs, tb_as_liuliu),                     'halfgrau':     cut_extent_2snowsample(extent, 2, d_cs, tb_as_liuliu),                     'halfsnow':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_snowhalfiwc),                    'halfrain':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_rainhalfiwc),                    'halfgrausnow': cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_grausnowhalfiwc),                    'noiwc':        cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_noiwc),                     'onlysnow':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_onlysnow),                     'onlygrau':     cut_extent_2snowsample(extent, 2, d_cs, tb_liuliu_onlygrau),                     'onlyrain':     cut_extent_2snowsample(extent, 1, d_cs, tb_liuliu_onlyrain),                    'onlyice':      cut_extent_2snowsample(extent, 1, d_cs, tb_liuliu_onlyice),                    'onlygrau_softsphere': cut_extent_2snowsample(extent, 1, d_cs, tb_liugrausp_onlygrau) })                         # how do i add also the liu3 + gp and liu9+graupel            return rttov_as, cloudmask_WRF#------------------------------------------------------------------------------def histogram_iwc_impacts(rttov_as, suptitle, cloudmask_WRF, plotpath):        # can also plot them in semilogy using add_hists_2fig_simple_2rowslog         maskdo = 0    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]        #---------------- 1st for Liu=3    fig, axes = plt.subplots(nrows=2, ncols=4, constrained_layout=True,figsize=[20,10])         axes[0,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[0,0].plot([],[], linewidth=1.2, color='darkred', label='onlysnow')    axes[0,0].plot([],[], linewidth=1.2, color='darkblue', label='onlygrau')    axes[0,0].plot([],[], linewidth=1.2, color='blue', label='onlygrau (softsphere)')    axes[0,0].plot([],[], linewidth=1.2, color='darkgreen', label='noiwc')     axes[0,0].plot([],[], linewidth=1.2, color='magenta', label='half_rain')    axes[0,0].plot([],[], linewidth=1.2, color='gray', label='onlyice')    #axes[0,0].legend(loc='upper left',ncol=6)    fig.legend(loc='lower left', ncol=7, bbox_to_anchor=(0.2,-0.05))    axes[1,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[1,0].plot([],[], linewidth=1.2, color=base_colors[0], label='halfsnow')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[1], label='halfgrau')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[2], label='halfgrausnow')     axes[1,0].plot([],[], linewidth=1.2, color='gray', label='halfrain')    axes[1,0].legend(loc='upper left')    #fig.legend(loc='lower left', ncol=5, bbox_to_anchor=(0.2,-0.14))    axes[1,0].set_ylabel('Counts')    axes[1,0].set_xlabel('BT [K]')    # --- FIGURE 1: BASIC    T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][0,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 0)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlysnow'][0,:,:,:], cloudmask_WRF, 'darkred', axes, 'onlysnow', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau'][0,:,:,:], cloudmask_WRF, 'darkblue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau_softsphere'][0,:,:,:], cloudmask_WRF, 'blue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['noiwc'][0,:,:,:], cloudmask_WRF, 'darkgreen', axes, 'noiwc', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyrain'][0,:,:,:], cloudmask_WRF, 'magenta', axes, 'half_rain', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyice'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'onlyice', '-', maskdo, 0)        # --- FIGURE 2: half contents impact     T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][0,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 1)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfsnow'][0,:,:,:], cloudmask_WRF, base_colors[0], axes, 'half_snow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrau'][0,:,:,:], cloudmask_WRF, base_colors[1], axes, 'half_grau', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrausnow'][0,:,:,:], cloudmask_WRF, base_colors[2], axes, 'half_grausnow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfrain'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 1)      plt.suptitle(suptitle+' (liu:3)')    fig.savefig(plotpath+'/poster/'+'testhistlog_iwcimpact_liu3'+suptitle+'.png', dpi=300,transparent=False, bbox_inches='tight')         #---------------- 2nd for Liu=9    fig, axes = plt.subplots(nrows=2, ncols=4, constrained_layout=True,figsize=[20,10])         # add dummy labels    axes[0,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[0,0].plot([],[], linewidth=1.2, color='darkred', label='onlysnow')    axes[0,0].plot([],[], linewidth=1.2, color='darkblue', label='onlygrau')    axes[0,0].plot([],[], linewidth=1.2, color='blue', label='onlygrau (softsphere)')    axes[0,0].plot([],[], linewidth=1.2, color='darkgreen', label='noiwc')     axes[0,0].plot([],[], linewidth=1.2, color='magenta', label='half_rain')    axes[0,0].plot([],[], linewidth=1.2, color='gray', label='onlyice')    #axes[0,0].legend(loc='upper left',ncol=6)    fig.legend(loc='lower left', ncol=7, bbox_to_anchor=(0.2,-0.05))    axes[1,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[1,0].plot([],[], linewidth=1.2, color=base_colors[0], label='halfsnow')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[1], label='halfgrau')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[2], label='halfgrausnow')     axes[1,0].plot([],[], linewidth=1.2, color='gray', label='halfrain')    axes[1,0].legend(loc='upper left')    #fig.legend(loc='lower left', ncol=5, bbox_to_anchor=(0.2,-0.14))    axes[1,0].set_ylabel('Counts')    axes[1,0].set_xlabel('BT [K]')    # --- FIGURE 1: BASIC    T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][1,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 0)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlysnow'][1,:,:,:], cloudmask_WRF, 'darkred', axes, 'onlysnow', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau'][1,:,:,:], cloudmask_WRF, 'darkblue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau_softsphere'][0,:,:,:], cloudmask_WRF, 'blue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['noiwc'][1,:,:,:], cloudmask_WRF, 'darkgreen', axes, 'noiwc', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyrain'][0,:,:,:], cloudmask_WRF, 'magenta', axes, 'half_rain', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyice'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 0)     T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][1,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 1)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfsnow'][1,:,:,:], cloudmask_WRF, base_colors[0], axes, 'half_snow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrau'][1,:,:,:], cloudmask_WRF, base_colors[1], axes, 'half_grau', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrausnow'][1,:,:,:], cloudmask_WRF, base_colors[2], axes, 'half_grausnow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfrain'][1,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 1)        plt.suptitle(suptitle+' (liu:9)')    fig.savefig(plotpath+'/poster/'+'testhistlog_iwcimpact_liu9'+suptitle+'.png', dpi=300,transparent=False, bbox_inches='tight')       return#------------------------------------------------------------------------------def make_histogram_iwc_impacts(server, processedFolder):        plotpath, folders = config_folders(server)        #---- READ DATA    #------------------------------------------------------------------------------------------    rttov_as_iwc_eqMass, _             = get_iwc_experiment_andcut( 'rttov_processed_allsky_eqMass_rsg_s', processedFolder)    rttov_as_iwc_WSM6, cloudmask_WRF   = get_iwc_experiment_andcut( 'rttov_processed_allsky_rsg_s', processedFolder)    #---- DO THE PLOTS: 1) impact of IWC sensitivities (note graupel soft sphere similar to liu3)     #------------------------------------------------------------------------------------------        # eqMass-WSM6 and WSM6    histogram_iwc_impacts(rttov_as_iwc_eqMass, 'eqMass_WSM6', cloudmask_WRF, plotpath)    histogram_iwc_impacts(rttov_as_iwc_WSM6, 'WSM6', cloudmask_WRF, plotpath)        return#------------------------------------------------------------------------------def make_barplots_liuliu(experiment_grid, rttov_eqMass, rttov_WSM6, server):            # check = rttov_eqMass['rttov_as'][0,0,0,:,:].copy()    # masked_arr = np.where(check <= 250, check, np.nan)    # plt.pcolor(masked_arr); plt.colorbar()    # plt.pcolor(rttov_eqMass['rttov_as'][0,0,0,:,:]); plt.colorbar()        import matplotlib.patches as mpatches  # Add this at the top of your script        plotpath, folders = config_folders(server)    ichan_title     = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx       = [0,1,3,4]    base_colors     = sns.color_palette('Paired')             all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)                categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']             var_wrfgrid_eqMass    = rttov_eqMass['delta_rttov_as'].copy()    var_wrfgrid          = rttov_WSM6['delta_rttov_as'].copy()            # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.7)    for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)                        axes[0,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[0,index].grid(True)        axes[0,index].set_ylim([-600,10])        axes[0,index].set_xticklabels(axes[0,index].get_xticklabels(), rotation=45, ha='right')    #axes[0,index].legend(loc='center left', title='Graupel', bbox_to_anchor=(1,0.5))            legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'Liu: {str(i)}') for i in range(11) ]    fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')    fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        for index, i in enumerate(chan_indx):        axes[1,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)            axes[1,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[1,index].set_ylim([-600,10])        axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[1,index].grid(True)    axes[1,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')    fig.text(0.5, 0.45, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    fig.savefig(plotpath+'/poster/'+'stack_liuliu_barplots.png', dpi=300,transparent=False, bbox_inches='tight')       #----------------------------        # One for aach i snow    # mean dTB (rttov_as - rttov_cs) below 240K    for isnow in range(11):        fig, axes = plt.subplots(nrows=2, ncols=4,figsize=[20,10])            fig.subplots_adjust(hspace=0.7)        for index, i in enumerate(chan_indx):            axes[0,index].set_title(ichan_title[index]+' GHz')                wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(masked_var) )            axes[0,index].bar(categories, wrfgridmean, color=base_colors)            axes[0,index].set_ylim([-50,10])            axes[0,index].grid(True)            axes[0,index].set_xticklabels(axes[0,index].get_xticklabels(), rotation=45, ha='right')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')                legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'Liu: {str(i)}') for i in range(11) ]        fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        for index, i in enumerate(chan_indx):            wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(masked_var) )            axes[1,index].bar(categories, wrfgridmean, color=base_colors)            axes[1,index].set_ylim([-50,10])            axes[1,index].grid(True)            axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[1,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                        fig.text(0.5, 0.45, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        fig.savefig(plotpath+'/poster/'+f'singleisnow_{isnow}_liuliu_barplots.png', dpi=300,transparent=False, bbox_inches='tight')               return#------------------------------------------------------------------------------def return_data4stats_inputs(rttov):         values     = rttov['delta_rttov_as']        var        = values[0,0,0,:,:]    nlon,nlat = var.shape        values     = rttov['delta_Gaussianan']    var        = values[0,0,0,:,:]    nlon_obs,nlat_obs = var.shape    delta_rttov  = np.zeros((11,11,5,nlon,nlat)); delta_rttov[:] = np.nan     delta_gaus   = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_gaus[:]  = np.nan     delta_mean   = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_mean[:]  = np.nan     delta_interp = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_interp[:] = np.nan         for isnow in range(11):        for igrau in range(11):            for ifreq in range(5):                values     = rttov['delta_rttov_as']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_rttov[isnow,igrau,ifreq,:,:] = masked_var                values     = rttov['delta_Gaussianan']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_gaus[isnow,igrau,ifreq,:,:] = masked_var                                values     = rttov['delta_mean']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_mean[isnow,igrau,ifreq,:,:] = masked_var                                values     = rttov['delta_Interp']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_interp[isnow,igrau,ifreq,:,:] = masked_var                    ifreq = 0    data_array_0 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 1    data_array_1 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 2    data_array_2 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 3    data_array_3 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 4    data_array_4 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }        return data_array_0, data_array_1, data_array_2, data_array_3, data_array_4#------------------------------------------------------------------------------def return_barplot_inputs(rttov):     means_delta_rttov  = np.zeros((11,11,5)); means_delta_rttov[:] = np.nan     means_delta_gaus   = np.zeros((11,11,5)); means_delta_gaus[:]  = np.nan     means_delta_mean   = np.zeros((11,11,5)); means_delta_mean[:]  = np.nan     means_delta_interp = np.zeros((11,11,5)); means_delta_interp[:] = np.nan         for isnow in range(11):        for igrau in range(11):            for ifreq in range(5):                values     = rttov['delta_rttov_as']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_rttov[isnow,igrau,ifreq] = np.nanmean(masked_var)                values     = rttov['delta_Gaussianan']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_gaus[isnow,igrau,ifreq] = np.nanmean(masked_var)                                values     = rttov['delta_mean']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_mean[isnow,igrau,ifreq] = np.nanmean(masked_var)                                values     = rttov['delta_Interp']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_interp[isnow,igrau,ifreq] = np.nanmean(masked_var)                    ifreq = 0    data_array_0 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 1    data_array_1 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 2    data_array_2 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 3    data_array_3 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 4    data_array_4 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }        return data_array_0, data_array_1, data_array_2, data_array_3, data_array_4#------------------------------------------------------------------------------def make_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server):        import matplotlib.patches as mpatches  # Add this at the top of your script    plotpath, folders = config_folders(server)        #- for the plot:    categories = ['Thick hex col','Sector']         category_positions = np.arange(len(categories))  # Numeric positions for categories    experiments = ['wrf grid', 'gaussian', 'mean', 'nearest' ]    colors_     = ['k','darkblue','darkred','darkgreen']    x           = np.arange(4)  # the label locations    width       = 0.2    # the width of the bars    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.5)        #- get data for the first row        data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_barplot_inputs(rttov_eqMass)    row = 0    #- frequency 89GHz    axes[row,0].bar( x, data_array_0['wrf_grid'], width, color='k')    axes[row,0].bar( x+0.2, data_array_0['gaussian'], width, color='darkblue')    axes[row,0].bar( x+0.4, data_array_0['delta_mean'], width, color='darkred')    axes[row,0].bar( x+0.6, data_array_0['delta_Interp'], width, color='darkgreen')    axes[row,0].set_title('89.0 GHz')        #- frequency 157GHz    axes[row,1].bar( x, data_array_1['wrf_grid'], width, color='k')    axes[row,1].bar( x+0.2, data_array_1['gaussian'], width, color='darkblue')    axes[row,1].bar( x+0.4, data_array_1['delta_mean'], width, color='darkred')    axes[row,1].bar( x+0.6, data_array_1['delta_Interp'], width, color='darkgreen')    axes[row,1].set_title('157 GHz')                #- frequency 157GHz    axes[row,2].bar( x, data_array_3['wrf_grid'], width, color='k')    axes[row,2].bar( x+0.2, data_array_3['gaussian'], width, color='darkblue')    axes[row,2].bar( x+0.4, data_array_3['delta_mean'], width, color='darkred')    axes[row,2].bar( x+0.6, data_array_3['delta_Interp'], width, color='darkgreen')    axes[row,2].set_title('183.311$\pm$3 GHz')                    #- frequency 190GHz    axes[row,3].bar( x, data_array_4['wrf_grid'], width, color='k')    axes[row,3].bar( x+0.2, data_array_4['gaussian'], width, color='darkblue')    axes[row,3].bar( x+0.4, data_array_4['delta_mean'], width, color='darkred')    axes[row,3].bar( x+0.6, data_array_4['delta_Interp'], width, color='darkgreen')    axes[row,3].set_title('190.311 GHz')                    for i in range(4):        axes[row,i].set_xticks(x + width, ['s3g3','s3g9','s9g3','s9g9'])        axes[row,i].set_ylim([-50,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')                legend_elements = [ mpatches.Patch(facecolor=colors_[i], label=f'{experiments[i]}') for i in range(4) ]    fig.legend(        handles=legend_elements,         loc='center left',         bbox_to_anchor=(0.93, 0.5),        title='Footprint')        axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                        #- get data for the first row        data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_barplot_inputs(rttov_WSM6)    row = 1    #- frequency 89GHz    axes[row,0].bar( x, data_array_0['wrf_grid'], width, color='k')    axes[row,0].bar( x+0.2, data_array_0['gaussian'], width, color='darkblue')    axes[row,0].bar( x+0.4, data_array_0['delta_mean'], width, color='darkred')    axes[row,0].bar( x+0.6, data_array_0['delta_Interp'], width, color='darkgreen')    axes[row,0].set_title('89.0 GHz')        #- frequency 157GHz    axes[row,1].bar( x, data_array_1['wrf_grid'], width, color='k')    axes[row,1].bar( x+0.2, data_array_1['gaussian'], width, color='darkblue')    axes[row,1].bar( x+0.4, data_array_1['delta_mean'], width, color='darkred')    axes[row,1].bar( x+0.6, data_array_1['delta_Interp'], width, color='darkgreen')    axes[row,1].set_title('157 GHz')                #- frequency 157GHz    axes[row,2].bar( x, data_array_3['wrf_grid'], width, color='k')    axes[row,2].bar( x+0.2, data_array_3['gaussian'], width, color='darkblue')    axes[row,2].bar( x+0.4, data_array_3['delta_mean'], width, color='darkred')    axes[row,2].bar( x+0.6, data_array_3['delta_Interp'], width, color='darkgreen')    axes[row,2].set_title('183.311$\pm$3 GHz')                    #- frequency 190GHz    axes[row,3].bar( x, data_array_4['wrf_grid'], width, color='k')    axes[row,3].bar( x+0.2, data_array_4['gaussian'], width, color='darkblue')    axes[row,3].bar( x+0.4, data_array_4['delta_mean'], width, color='darkred')    axes[row,3].bar( x+0.6, data_array_4['delta_Interp'], width, color='darkgreen')    axes[row,3].set_title('190.311 GHz')                    for i in range(4):        axes[row,i].set_xticks(x + width, ['s3g3','s3g9','s9g3','s9g9'])        axes[row,i].set_ylim([-50,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')                 axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.48, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    fig.savefig(plotpath+'/poster/'+f'sampleexperment_4footprintmodel_barplots.png', dpi=300,transparent=False, bbox_inches='tight')       return#------------------------------------------------------------------------------def do_whiskers(row, col_index, axes, x, data, color_in, width):        offset = [0, 10, 20, 30]    for i in range(len(data)):        p15 = np.nanpercentile(data[i], 15)        p25 = np.nanpercentile(data[i], 25)        p75 = np.nanpercentile(data[i], 75)        p95 = np.nanpercentile(data[i], 95)                mean_ = np.nanmean(data[i])        # Draw the box from 25th to 75th        axes[row,col_index].vlines(x+offset[i], ymin=p25, ymax=p75, color=color_in, linewidth=10)        axes[row,col_index].vlines(x+offset[i], ymin=p15, ymax=p95, color=color_in, linewidth=2)        # Draw the mean as a bold vertical line        x1 = x+offset[i]        axes[row,col_index].hlines(y=mean_, xmin=x1-(width/2), xmax=x1+(width/2), color='k', linewidth=3)    return axes #------------------------------------------------------------------------------def make_distrib_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server):        import matplotlib.patches as mpatches  # Add this at the top of your script    plotpath, folders = config_folders(server)        #- for the plot:    categories = ['Thick hex col','Sector']         category_positions = np.arange(len(categories))  # Numeric positions for categories    experiments = ['wrf grid', 'gaussian', 'mean', 'nearest' ]    colors_     = ['k','darkblue','darkred','darkgreen']    x           = [0, 2, 4, 6] # the label locations    width       = 1    # the width of the bars    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.5)    #------     #- get data for the first row      row = 0    data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_eqMass)    #- frequency 89GHz    axes = do_whiskers(row, 0, axes, x[0], data_array_0['wrf_grid'], 'k', width)    axes = do_whiskers(row, 0, axes, x[1], data_array_0['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 0, axes, x[2], data_array_0['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 0, axes, x[3], data_array_0['delta_Interp'], 'darkgreen', width)    axes[row,0].set_title('89.0 GHz')            #- frequency 157    axes = do_whiskers(row, 1, axes, x[0], data_array_1['wrf_grid'], 'k', width)    axes = do_whiskers(row, 1, axes, x[1], data_array_1['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 1, axes, x[2], data_array_1['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 1, axes, x[3], data_array_1['delta_Interp'], 'darkgreen', width)    axes[row,1].set_title('157 GHz')                #- frequency 183    axes = do_whiskers(row, 2, axes, x[0], data_array_3['wrf_grid'], 'k', width)    axes = do_whiskers(row, 2, axes, x[1], data_array_3['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 2, axes, x[2], data_array_3['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 2, axes, x[3], data_array_3['delta_Interp'], 'darkgreen', width)    axes[row,2].set_title('183.311$\pm$3 GHz')            #- frequency 190    axes = do_whiskers(row, 3, axes, x[0], data_array_4['wrf_grid'], 'k', width)    axes = do_whiskers(row, 3, axes, x[1], data_array_4['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 3, axes, x[2], data_array_4['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 3, axes, x[3], data_array_4['delta_Interp'], 'darkgreen', width)    axes[row,3].set_title('190.311 GHz')                   for i in range(4):        axes[row,i].set_xticks( [5,15,25,35], ['s3g3','s3g9','s9g3','s9g9'])        #axes[row,i].set_ylim([-,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')              legend_elements = [ mpatches.Patch(facecolor=colors_[i], label=f'{experiments[i]}') for i in range(4) ]    fig.legend(        handles=legend_elements,         loc='center left',         bbox_to_anchor=(0.93, 0.5),        title='Footprint')        axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    #------     #- get data for the first row      row = 1    data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_WSM6)    #- frequency 89GHz    axes = do_whiskers(row, 0, axes, x[0], data_array_0['wrf_grid'], 'k', width)    axes = do_whiskers(row, 0, axes, x[1], data_array_0['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 0, axes, x[2], data_array_0['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 0, axes, x[3], data_array_0['delta_Interp'], 'darkgreen', width)    axes[row,0].set_title('89.0 GHz')            #- frequency 157    axes = do_whiskers(row, 1, axes, x[0], data_array_1['wrf_grid'], 'k', width)    axes = do_whiskers(row, 1, axes, x[1], data_array_1['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 1, axes, x[2], data_array_1['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 1, axes, x[3], data_array_1['delta_Interp'], 'darkgreen', width)    axes[row,1].set_title('157 GHz')                #- frequency 183    axes = do_whiskers(row, 2, axes, x[0], data_array_3['wrf_grid'], 'k', width)    axes = do_whiskers(row, 2, axes, x[1], data_array_3['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 2, axes, x[2], data_array_3['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 2, axes, x[3], data_array_3['delta_Interp'], 'darkgreen', width)    axes[row,2].set_title('183.311$\pm$3 GHz')            #- frequency 190    axes = do_whiskers(row, 3, axes, x[0], data_array_4['wrf_grid'], 'k', width)    axes = do_whiskers(row, 3, axes, x[1], data_array_4['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 3, axes, x[2], data_array_4['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 3, axes, x[3], data_array_4['delta_Interp'], 'darkgreen', width)    axes[row,3].set_title('190.311 GHz')                   for i in range(4):        axes[row,i].set_xticks( [5,15,25,35], ['s3g3','s3g9','s9g3','s9g9'])        #axes[row,i].set_ylim([-,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')              axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.48, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    fig.savefig(plotpath+'/poster/'+f'sampleexperment_4footprintmodel_barplots_whiskers.png', dpi=300,transparent=False, bbox_inches='tight')               return #------------------------------------------------------------------------------------------#------------------------------------------------------------------------------------------def get_mean_deltaBT(iwc, varBT):        x_bins = np.arange(0,20,2)    x_bin_centers = (x_bins[:-1] + x_bins[1:]) / 2            x1   = iwc.flatten()    var1 = varBT.flatten()    mask1 = ~np.isnan(x1) & ~np.isnan(var1)                # Prepare an array to store the means    mean_y_per_bin = []    x1_valid = x1[mask1]    y1_valid = var1[mask1]        # For each x-bin, compute the mean y-value    for i in range(len(x_bins)-1):        mask = (x1_valid >= x_bins[i]) & (x1_valid < x_bins[i+1])        if np.any(mask):            mean_y = np.nanmean(y1_valid[mask])        else:            mean_y = np.nan  # if no data in bin        mean_y_per_bin.append(mean_y)        return x_bin_centers, mean_y_per_bin    #------------------------------------------------------------------------------#------------------------------------------------------------------------------def analysis_function_iwc(iwcontents, rttov_eqMass, rttov_WSM6, experiment, server):    import matplotlib.colors as colors    plotpath, folders = config_folders(server)    var_wrfgrid_eqMass   = rttov_eqMass[experiment].copy()    var_wrfgrid          = rttov_WSM6[experiment].copy()    # For log hist2d:     # x_bins = np.arange(0,20,2)    # y_bins = np.arange(-250, -5, 5)    # # mean dTB (rttov_as - rttov_cs) below 240K    # fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    # for index, i in enumerate(chan_indx):    #     axes[0,index].set_title(ichan_title[index]+' GHz')            #     for snow_index, isnow in enumerate([3,9]):    #         x1   = iwcontents['WRF_intTot_cut'].flatten()    #         var1 = var_wrfgrid_eqMass[isnow,3,i,:,:].flatten()    #         var2 = var_wrfgrid_eqMass[isnow,9,i,:,:].flatten()    #         mask1 = ~np.isnan(x1) & ~np.isnan(var1)    #         mask2 = ~np.isnan(x1) & ~np.isnan(var2)    #         h = axes[snow_index,index].hist2d(x1[mask1], var1[mask1], bins=[x_bins, y_bins], cmap='viridis', norm=colors.LogNorm())    #         fig.colorbar(h[3], ax=axes[snow_index, index])                    #- for the plot:    categories  = ['Thick hex col','Sector']             ichan_title = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx   = [0,1,3,4]    base_colors = sns.color_palette('Paired')           all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.4)    # dummy legends    for isnow in [3,9]:        for igrau in [3,9]:                        axes[0,0].plot([],[], linewidth=1.2, color=all_shades[isnow][igrau], label=f's{str(isnow)}g{str(igrau)}')    fig.legend(loc='lower left', ncol=4, bbox_to_anchor=(0.2,-0.02))    for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')                for snow_index, isnow in enumerate([3,9]):            for igrau in [3,9]:                x_bins, mean_y_per_bin = get_mean_deltaBT(iwcontents, var_wrfgrid_eqMass[isnow,igrau,i,:,:])                axes[0,index].plot(x_bins, mean_y_per_bin, linewidth=1.2, color=all_shades[isnow][igrau])        axes[0,index].grid(True)        axes[0,index].set_ylim([-250,0])    fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment})', ha='center', va='center', fontsize=16,fontweight='bold')    for index, i in enumerate(chan_indx):        axes[1,index].set_title(ichan_title[index]+' GHz')                for snow_index, isnow in enumerate([3,9]):            for igrau in [3,9]:                x_bins, mean_y_per_bin = get_mean_deltaBT(iwcontents, var_wrfgrid[isnow,igrau,i,:,:])                axes[1,index].plot(x_bins, mean_y_per_bin, linewidth=1.2, color=all_shades[isnow][igrau])        axes[1,index].grid(True)        axes[1,index].set_ylim([-250,0])            axes[0,0].set_ylabel(r'$\Delta$BT [K] for eqMass')    axes[1,0].set_ylabel(r'$\Delta$BT [K] for WSM6')    axes[1,0].set_xlabel(r'model int. iwc(tot)')    fig.text(0.5, 0.5, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment})', ha='center', va='center', fontsize=16,fontweight='bold')    fig.savefig(plotpath+'/poster/'+f'meanBTper_iwc_forexp{experiment}.png', dpi=300,transparent=False, bbox_inches='tight')       return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_maps(rttov_as, isnow, igrau, experiment):        experiment = experiment+f's{isnow}g{igrau}'        plotpath, folders = config_folders(server)        instrument = 'MHS'    outfile    = 'output_tb_'+instrument    d_cs       = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        #extent = [ -64, -50, -40, -20]        extent = [ -65, -50, -40, -20]        #lonlon = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lon'].data)     #latlat = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lat'].data)         #lon_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lon'])    #lat_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lat'])    lonlon = d_cs['wrf_lon'].data     latlat = d_cs['wrf_lat'].data    lon_obs_cut = d_cs['MHS_lon']    lat_obs_cut = d_cs['MHS_lat']    fig, axes = plt.subplots(nrows=5, ncols=4, constrained_layout=True,figsize=[15,20])    axes = T2P.plot_MHS_row_WRFgrid_largeobs(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data, server, axes, 0, 'OBS')            for ii in range(4):        axes[0, ii].set_xlim([-64.3,-61.5])  #[-68,-62]);         axes[0, ii].set_ylim([-34.5,-31])   #[-36,-31])            T2P.plot_MHS_row_WRFgrid_large(lonlon, latlat, rttov_as['rttov_as'][isnow,igrau,:,:,:], server, axes, 1, 'EqMass_WSM6 (s3g3)')            T2P.plot_MHS_row_WRFgrid_large(lon_obs_cut, lat_obs_cut, rttov_as['rttov_as_Gaussian'][isnow,igrau,:,:,:], server, axes, 2, 'EqMass WSM6 (s9g9)')           T2P.plot_MHS_row_WRFgrid_large(lon_obs_cut, lat_obs_cut, rttov_as['rttov_as_mean'][isnow,igrau,:,:,:], server, axes, 3, 'WSM6 (s3g3)')            axes,pcm = T2P.plot_MHS_row_WRFgrid_large(lon_obs_cut, lat_obs_cut, rttov_as['rttov_as_Interp'][isnow,igrau,:,:,:], server, axes, 4, 'WSM6 (s9g9)')           for i in [1,2,3,4]:        for ii in range(4):            axes[i, ii].set_xlim([-64.2,-61.6])  #[-68,-62]);             axes[i, ii].set_ylim([-34.5,-31])   #[-36,-31])    axes[0,0].set_ylabel('wrf grid', fontweight='bold', fontsize=14)    axes[0,1].set_ylabel('gaussian', fontweight='bold', fontsize=14)    axes[0,2].set_ylabel('mean', fontweight='bold', fontsize=14)    axes[0,3].set_ylabel('interp.', fontweight='bold', fontsize=14)        cbar = fig.colorbar(pcm, ax=axes,orientation='vertical',fraction=0.2, pad=0.04)        plt.suptitle( f'{experiment}', fontweight='bold')    fig.savefig(plotpath+'/RTTOV/'+f'{experiment}_allfootprints_maps_zoomout.png', dpi=300,transparent=False)       #plt.close()        return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_deltamaps(rttov_as, isnow, igrau, experiment):        experiment = experiment+f's{isnow}g{igrau}'        plotpath, folders = config_folders(server)        instrument = 'MHS'    outfile    = 'output_tb_'+instrument    d_cs       = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        #extent = [ -64, -50, -40, -20]        extent = [ -65, -50, -40, -20]        #lonlon = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lon'].data)     #latlat = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lat'].data)         #lon_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lon'])    #lat_obs_cut = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lat'])    lonlon = d_cs['wrf_lon'].data     latlat = d_cs['wrf_lat'].data    lon_obs_cut = d_cs['MHS_lon']    lat_obs_cut = d_cs['MHS_lat']    fig, axes = plt.subplots(nrows=5, ncols=4, constrained_layout=True,figsize=[15,20])    axes = T2P.plot_MHS_row_WRFgrid_largeobs(d_cs['MHS_lon'], d_cs['MHS_lat'], d_cs['MHs_domain_obs'].data, server, axes, 0, 'OBS')            for ii in range(4):        axes[0, ii].set_xlim([-64.3,-61.5])  #[-68,-62]);         axes[0, ii].set_ylim([-34.5,-31])   #[-36,-31])            T2P.plot_MHS_row_WRFgrid_deltalarge(lonlon, latlat, rttov_as['delta_rttov_as'][isnow,igrau,:,:,:], server, axes, 1, 'EqMass_WSM6 (s3g3)')            T2P.plot_MHS_row_WRFgrid_deltalarge(lon_obs_cut, lat_obs_cut, rttov_as['delta_Gaussianan'][isnow,igrau,:,:,:], server, axes, 2, 'EqMass WSM6 (s9g9)')           T2P.plot_MHS_row_WRFgrid_deltalarge(lon_obs_cut, lat_obs_cut, rttov_as['delta_mean'][isnow,igrau,:,:,:], server, axes, 3, 'WSM6 (s3g3)')            axes,pcm = T2P.plot_MHS_row_WRFgrid_deltalarge(lon_obs_cut, lat_obs_cut, rttov_as['delta_Interp'][isnow,igrau,:,:,:], server, axes, 4, 'WSM6 (s9g9)')           for i in [1,2,3,4]:        for ii in range(4):            axes[i, ii].set_xlim([-64.2,-61.6])  #[-68,-62]);             axes[i, ii].set_ylim([-34.5,-31])   #[-36,-31])    axes[0,0].set_ylabel('wrf grid', fontweight='bold', fontsize=14)    axes[0,1].set_ylabel('gaussian', fontweight='bold', fontsize=14)    axes[0,2].set_ylabel('mean', fontweight='bold', fontsize=14)    axes[0,3].set_ylabel('interp.', fontweight='bold', fontsize=14)        cbar = fig.colorbar(pcm, ax=axes,orientation='vertical',fraction=0.2, pad=0.04)        plt.suptitle( r'$\Delta$BT [K] (BT(89clear)<250K) for'+f'{experiment}', fontweight='bold')    fig.savefig(plotpath+'/RTTOV/'+f'{experiment}_delta_allfootprints_maps_zoomout.png', dpi=300,transparent=False)       #plt.close()        return#------------------------------------------------------------------------------#------------------------------------------------------------------------------def plot_iwc_row_(lonlon, latlat, iwc_snow, iwc_grau, iwc_tot, server, axes, col, experiment_name):        # Some basic info for colormaps      if 'yakaira' in server:        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')            fn = '/home/vito.galligani/Work/Tools/etopo1_bedrock.nc'    elif 'cnrm' in server:        prov = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')            fn = '/home/galliganiv/ACMS_hail/src/etopo1_bedrock.nc'       # Topografia    ds = nc.Dataset(fn)    topo_lat = ds.variables['lat'][:]    topo_lon = ds.variables['lon'][:]    topo_dat = ds.variables['Band1'][:]/1e3    lons_topo, lats_topo = np.meshgrid(topo_lon,topo_lat)           pcm = axes[col, 0].pcolormesh(lonlon, latlat, iwc_snow,  cmap='viridis', vmin=0, vmax=20)    pcm = axes[col, 1].pcolormesh(lonlon, latlat, iwc_grau,  cmap='viridis', vmin=0, vmax=20)    pcm = axes[col, 2].pcolormesh(lonlon, latlat, iwc_tot,  cmap='viridis', vmin=0, vmax=20)    for ii in range(3):        axes[col, ii].set_xlim([-64.3,-61.5])  #[-68,-62]);         axes[col, ii].set_ylim([-34.5,-31])   #[-36,-31])              axes[col, ii].plot(prov[:,0],prov[:,1],color='w');         axes[col, ii].contour(lons_topo, lats_topo, topo_dat, levels=[0.5,1], colors=['gray','gray'], linewidths=2)        axes[col, ii].set_xticklabels([])        axes[col, ii].set_yticklabels([])        axes[col,0].set_ylabel(experiment_name)        return axes, pcm#------------------------------------------------------------------------------#------------------------------------------------------------------------------def make_iwc_maps(iwc_data):            plotpath, folders = config_folders(server)        instrument = 'MHS'    outfile    = 'output_tb_'+instrument    d_cs       = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        extent = [ -65, -50, -40, -20]        lonlon = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lon'].data)     latlat = get_maskedDomain2d(extent, d_cs, d_cs['wrf_lat'].data)         lonlon_ = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lon'])    latlat_ = get_maskedDomain2d_gaussian(extent, d_cs, d_cs['MHS_lat'])        fig, axes = plt.subplots(nrows=4, ncols=3, constrained_layout=True,figsize=[15,15])    plot_iwc_row_(lonlon, latlat, iwcontents['WRF_intqs_cut'], iwcontents['WRF_intqg_cut'], iwcontents['WRF_intTot_cut'], server, axes, 0, 'wrf grid')    plot_iwc_row_(lonlon_, latlat_, iwcontents['gaus_intqs_cut'], iwcontents['gaus_intqg_cut'], iwcontents['gaus_intTot_cut'], server, axes, 1, 'gaussian')    plot_iwc_row_(lonlon_, latlat_, iwcontents['mean_intqs_cut'], iwcontents['mean_intqg_cut'], iwcontents['mean_intTot_cut'], server, axes, 2, 'mean')    axes, pcm = plot_iwc_row_(lonlon_, latlat_, iwcontents['interp_intqs_cut'], iwcontents['interp_intqg_cut'], iwcontents['interp_intTot_cut'], server, axes, 3, 'interp')          cbar = fig.colorbar(pcm, ax=axes,orientation='vertical',fraction=0.2, pad=0.04)            axes[0,0].set_title('int. snow')    axes[0,1].set_title('int. grau')    axes[0,2].set_title('int. tot')        plt.suptitle( 'Footprint model on int. iwc', fontweight='bold')    fig.savefig(plotpath+'/RTTOV/'+f'footprint_intiiwc_maps_zoomout.png', dpi=300,transparent=False)       return# cd datosmunin3/Work/Studies/HAILCASE_10112018/src/rttov_call/#------------------------------------------------------------------------------------------#------------------------------------------------------------------------------------------mp_physics = 'WRF-WSM6'server = 'yakaira'# Select server and folder locations#--------------------------------------------------------------------------if 'yakaira' in server:     upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'    sys.path.insert(1,'/home/vito.galligani/datosmunin3/Work/Studies/HAILCASE_10112018/src')    processedFolder = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/Processed/'+mp_physics    mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'            elif 'cnrm' in server:    upfolder    = '/home/galliganiv/'       sys.path.insert(1,'/home/galliganiv/ACMS_hail/src')    processedFolder = '/home/galliganiv/Work/HAILCASE_10112018/RTTOVinout/Processed/'+mp_physics    mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'        already_run_final = 1#------------------------------------------------------------------------------------------# Lots of experiments now. I want to # 1) Look at histograms for experiiments on iwc#------------------------------------------------------------------------------------------if already_run_final == 1:    make_histogram_iwc_impacts('yakaira', processedFolder) # 2) Barplots of the impact of the different liuliu combinations #------------------------------------------------------------------------------------------rttov_eqMass = get_liuliu_experiments_andcut('rttov_processed_allsky_eqMass_rsg_s', processedFolder)rttov_WSM6   = get_liuliu_experiments_andcut('rttov_processed_allsky_rsg_s', processedFolder)if already_run_final == 1:    make_barplots_liuliu('wrf grid', rttov_eqMass, rttov_WSM6, 'yakaira')# 3) Barplots of the impact of the different lantenna resolutions? for liu3 ad liu9 (w/ whiskers)#------------------------------------------------------------------------------------------if already_run_final == 1:    make_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, 'yakaira')    make_distrib_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, 'yakaira')# 4) impact of IWC sensitivities depending on footprint model#------------------------------------------------------------------------------------------ iwcontents = get_iwc_experiments_andcut(processedFolder)    if already_run_final == 1:    analysis_function_iwc(iwcontents['WRF_intTot_cut'],   rttov_eqMass, rttov_WSM6, 'delta_rttov_as', 'yakaira')    analysis_function_iwc(iwcontents['interp_intTot_cut'], rttov_eqMass, rttov_WSM6, 'delta_Interp', 'yakaira')    analysis_function_iwc(iwcontents['mean_intTot_cut'],  rttov_eqMass, rttov_WSM6, 'delta_mean', 'yakaira')    analysis_function_iwc(iwcontents['gaus_intTot_cut'],  rttov_eqMass, rttov_WSM6, 'delta_Gaussianan', 'yakaira')# 5) General maps for the different footprints#------------------------------------------------------------------------------------------ rttov_eqMass_full = get_liuliu_experiments_NOcut('rttov_processed_allsky_eqMass_rsg_s', processedFolder)rttov_WSM6_full = get_liuliu_experiments_NOcut('rttov_processed_allsky_rsg_s', processedFolder)if already_run_final == 1:    make_maps(rttov_eqMass_full, 3, 3, 'eqMass_WSM6')    make_maps(rttov_eqMass_full, 9, 9, 'eqMass_WSM6')    make_maps(rttov_WSM6_full, 3, 3, 'WSM6')    make_maps(rttov_WSM6_full, 9, 9, 'WSM6')        make_deltamaps(rttov_eqMass_full, 3, 3, 'eqMass_WSM6')    make_deltamaps(rttov_eqMass_full, 9, 9, 'eqMass_WSM6')    make_deltamaps(rttov_WSM6_full, 3, 3, 'WSM6')    make_deltamaps(rttov_WSM6_full, 9, 9, 'WSM6')    # 6) IWC footprint impact if already_run_final == 1:    make_iwc_maps(iwcontents)#experiments = ['wrf grid', 'gaussian', 'mean', 'nearest' ]#colors_     = ['k','darkblue','darkred','darkgreen']#iwcontents['gaus_intTot_cut'].flatten(), rttov_eqMass['delta_Gaussianan'][]# final take on the index? # run a differnt clud fraction or sieron et al. approach ?        