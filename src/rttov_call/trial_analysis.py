import Tools2Plot as T2Pimport seaborn as sns import numpy as npimport xarray as xrfrom config import config_foldersimport sysimport matplotlib.pyplot as pltplt.matplotlib.rc('font', family='serif', size = 16)plt.rcParams['xtick.labelsize']=16plt.rcParams['ytick.labelsize']=16  #------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain(extent, d_cs, Tc):        lon = d_cs['wrf_lon'].data    lat = d_cs['wrf_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[:, row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")            return Tc_crop#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain2d(extent, d_cs, var2d):        lon = d_cs['wrf_lon'].data    lat = d_cs['wrf_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        var2d_crop = var2d[row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")        return var2d_crop#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu(d_cs, tb_rttov):        # use extent to limit     extent = [ -64, -50, -40, -20]    var_cut    = []    for isnow in range(11):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_2snowsample(isnow_ranges, d_cs, tb_rttov):        # use extent to limit     extent = [ -64, -50, -40, -20]    var_cut    = []    for isnow in range(isnow_ranges):        var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,0,:,:,:])        var_cut.append(var_cut1)          var_cut = np.array(var_cut)                return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_maskedDomain_gaussian(d_cs, Tc):        extent = [ -64, -50, -40, -20]    lon = d_cs['MHS_lon'].data    lat = d_cs['MHS_lat'].data        # Crop by extent    mask = (        (lon >= extent[0]) & (lon <= extent[1]) &        (lat >= extent[2]) & (lat <= extent[3])        )    rows, cols = np.where(mask)        # If any points are found, crop arrays to the bounding box    if rows.size > 0 and cols.size > 0:        row_min, row_max = rows.min(), rows.max()        col_min, col_max = cols.min(), cols.max()                # Crop all arrays accordingly        Tc_crop = Tc[:, row_min:row_max+1, col_min:col_max+1]        lat_crop = lat[row_min:row_max+1, col_min:col_max+1]        lon_crop = lon[row_min:row_max+1, col_min:col_max+1]            else:        raise ValueError("No data points found within the specified extent.")        return Tc_crop[:,2:,:]#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu(d_cs, tb_rttov):        # use extent to limit     extent = [ -64, -50, -40, -20]    var_cut    = []    for isnow in range(11):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain(extent, d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def cut_extent_liuliu_gaus(d_cs, tb_rttov):        var_cut    = []    for isnow in range(11):        rowi1 = []        for igrau in range(11):            var_cut1 = get_maskedDomain_gaussian(d_cs,  tb_rttov[isnow,igrau,:,:,:])            rowi1.append(var_cut1)        var_cut.append(rowi1)        var_cut = np.array(var_cut)                 return var_cut#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_liuliu_experiments_andcut(experiment, processedFolder):        extent = [ -64, -50, -40, -20]    instrument = 'MHS'    outfile    = 'output_tb_'+instrument        # rttov clearsky simulations    d_cs         = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')    tb_cs        = d_cs['rttov_cs'].values     tb_cs_gaus   = d_cs['rttov_cs_Gaussianantennasigma_'].values    tb_cs_mean   = d_cs['rttov_cs_footprintmean'].values    tb_cs_interp = d_cs['rttov_cs_pointInterpNearest'].values        # rttov allsky simulations    tb_as        = []     tb_as_gaus   = []    tb_as_mean   = []    tb_as_interp = []    dtb_as        = []     dtb_as_gaus   = []    dtb_as_mean   = []    dtb_as_interp = []    for i in range(11):        rowi  = []; rowig  = []; rowim  = []; rowiN  = []        drowi = []; drowig = []; drowim = []; drowiN = []                for  j in range(11):            expname     = experiment+str(i)+'g'+str(j)+'.nc'            d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)            var         = d_liuliu['rttov_as'].values            var_gaus    = d_liuliu['rttov_as_Gaussianantennasigma_'].values            var_mean    = d_liuliu['rttov_as_footprintmean'].values            var_interp  = d_liuliu['rttov_as_pointInterpNearest'].values                        rowi.append(var)            rowig.append(var_gaus)            rowim.append(var_mean)            rowiN.append(var_interp)            drowi.append(var-tb_cs)            drowig.append(var_gaus-tb_cs_gaus)            drowim.append(var_mean-tb_cs_mean)            drowiN.append(var_interp-tb_cs_interp)                    tb_as.append(rowi)        tb_as_gaus.append(rowig)        tb_as_mean.append(rowi)        tb_as_interp.append(rowi)        dtb_as.append(drowi)        dtb_as_gaus.append(drowig)        dtb_as_mean.append(drowim)        dtb_as_interp.append(drowi)            tb_as        = np.array(tb_as)    tb_as_gaus   = np.array(tb_as_gaus)    tb_as_mean   = np.array(tb_as_mean)    tb_as_interp = np.array(tb_as_interp)    dtb_as        = np.array(dtb_as)    dtb_as_gaus   = np.array(dtb_as_gaus)    dtb_as_mean   = np.array(dtb_as_mean)    dtb_as_interp = np.array(dtb_as_interp)        # WRF data     # Id like to get all intg and ints for gaussian and interp.     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')        dothis = 0    if (dothis==1):        # wrf grid             WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intqs'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intqg'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)                 WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSinterp_intqs'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSinterp_intqg'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSinterp_intTot'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSfootprintmean_intqs'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSfootprintmean_intqg'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSfootprintmean_intTot'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSGaussian_intqs'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSGaussian_intqg'].data)         WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['MHSGaussian_intTot'].data)             WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)         rttov_as =dict({'rttov_as':          cut_extent_liuliu(d_cs, tb_as),                     'rttov_as_Gaussian': cut_extent_liuliu_gaus(d_cs, tb_as_gaus),                     'rttov_as_mean':     cut_extent_liuliu_gaus(d_cs, tb_as_mean),                    'rttov_as_Interp':   cut_extent_liuliu_gaus(d_cs, tb_as_interp),                    'delta_rttov_as':    cut_extent_liuliu(d_cs, dtb_as),                    'delta_Gaussianan':  cut_extent_liuliu_gaus(d_cs, dtb_as_gaus),                     'delta_mean':        cut_extent_liuliu_gaus(d_cs, dtb_as_mean),                     'delta_Interp':      cut_extent_liuliu_gaus(d_cs, dtb_as_interp) })                 return rttov_as#------------------------------------------------------------------------------#------------------------------------------------------------------------------def get_iwc_experiment_andcut(experiment_1, processedFolder):        extent = [ -64, -50, -40, -20]        # rttov clearsky simulations    instrument = 'MHS'    outfile   = 'output_tb_'+instrument    d_cs      = xr.open_dataset(processedFolder+'/'+outfile+'rttov_processed_clearsky.nc')        # 1st Read nc files     #------------------------------------------------------------------------------------------    # WRF data     WRFvars        = xr.open_dataset(processedFolder+'/'+'wrfdata_processed.nc')    WRF_intTot_cut = get_maskedDomain2d(extent, d_cs, WRFvars['WRF_intTot'].data)     cloudmask_WRF  = np.ma.masked_less_equal(WRF_intTot_cut, 0.1)     lonlon    = WRFvars['wrf_lon'].data    latlat    = WRFvars['wrf_lat'].data    nx,ny=np.shape(lonlon)        tb_liuliu_snowhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_snowhalfiwc[:]=np.nan    tb_liuliu_grauhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_grauhalfiwc[:]=np.nan    tb_liuliu_grausnowhalfiwc = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_grausnowhalfiwc[:]=np.nan    tb_liuliu_rainhalfiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_rainhalfiwc[:]=np.nan    tb_liuliu_noiwc     = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_noiwc[:]=np.nan    tb_liuliu_onlysnow  = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlysnow[:]=np.nan    tb_liuliu_onlygrau  = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlygrau[:]=np.nan    tb_liuliu_onlyrain  = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlyrain[:]=np.nan    tb_liuliu_onlyice   = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liuliu_onlyice[:]=np.nan        tb_liugrausp_onlygrau  = np.zeros((1,1,5,lonlon.shape[0],lonlon.shape[1])); tb_liugrausp_onlygrau[:]=np.nan        tb_as_liuliu    = np.zeros((2,1,5,lonlon.shape[0],lonlon.shape[1])); tb_as_liuliu[:]=np.nan        liuopts = [3,9]    counter = 0    for i in liuopts:                expname     = experiment_1+str(i)+'g'+str(i)+'.nc'        d_liuliu    = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var         = d_liuliu['rttov_as'].values        tb_as_liuliu[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'grau_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_grauhalfiwc[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'snow_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_snowhalfiwc[counter,0,:,:,:] = var                         expname = experiment_1+str(i)+'g'+str(i)+'rain_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_rainhalfiwc[counter,0,:,:,:] = var                          expname = experiment_1+str(i)+'g'+str(i)+'grausnow_iwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_grausnowhalfiwc[counter,0,:,:,:] = var          expname = experiment_1+str(i)+'g'+str(i)+'noiwc'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_noiwc[counter,0,:,:,:] = var                  expname = experiment_1+str(i)+'g'+str(i)+'onlygrau'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_onlygrau[counter,0,:,:,:] = var                expname = experiment_1+str(i)+'g'+str(i)+'onlysnow'+'.nc'          d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)        var     = d_1['rttov_as'].values        tb_liuliu_onlysnow[counter,0,:,:,:] = var              counter = counter+1        i = 9    expname = experiment_1+str(i)+'g'+str(i)+'onlyrain'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liuliu_onlyrain[0,0,:,:,:] = var                      expname = experiment_1+str(i)+'g'+str(i)+'onlyice'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liuliu_onlyice[0,0,:,:,:] = var          # add only grau with soft sphere    expname = experiment_1+'3grausp'+'onlygrau'+'.nc'      d_1     = xr.open_dataset(processedFolder+'/'+'output_tb_'+instrument+expname)    var     = d_1['rttov_as'].values    tb_liugrausp_onlygrau[0,0,:,:,:] = var                    rttov_as =dict({'control':      cut_extent_2snowsample(2, d_cs, tb_as_liuliu),                     'halfgrau':     cut_extent_2snowsample(2, d_cs, tb_as_liuliu),                     'halfsnow':     cut_extent_2snowsample(2, d_cs, tb_liuliu_snowhalfiwc),                    'halfrain':     cut_extent_2snowsample(2, d_cs, tb_liuliu_rainhalfiwc),                    'halfgrausnow': cut_extent_2snowsample(2, d_cs, tb_liuliu_grausnowhalfiwc),                    'noiwc':        cut_extent_2snowsample(2, d_cs, tb_liuliu_noiwc),                     'onlysnow':     cut_extent_2snowsample(2, d_cs, tb_liuliu_onlysnow),                     'onlygrau':     cut_extent_2snowsample(2, d_cs, tb_liuliu_onlygrau),                     'onlyrain':     cut_extent_2snowsample(1, d_cs, tb_liuliu_onlyrain),                    'onlyice':      cut_extent_2snowsample(1, d_cs, tb_liuliu_onlyice),                    'onlygrau_softsphere': cut_extent_2snowsample(1, d_cs, tb_liugrausp_onlygrau) })                         # how do i add also the liu3 + gp and liu9+graupel            return rttov_as, cloudmask_WRF#------------------------------------------------------------------------------def histogram_iwc_impacts(rttov_as, suptitle, cloudmask_WRF, plotpath):        # can also plot them in semilogy using add_hists_2fig_simple_2rowslog         maskdo = 0    base_colors = sns.color_palette('Paired')             base_colors[10] = base_colors[10+1]        #---------------- 1st for Liu=3    fig, axes = plt.subplots(nrows=2, ncols=4, constrained_layout=True,figsize=[20,10])         axes[0,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[0,0].plot([],[], linewidth=1.2, color='darkred', label='onlysnow')    axes[0,0].plot([],[], linewidth=1.2, color='darkblue', label='onlygrau')    axes[0,0].plot([],[], linewidth=1.2, color='blue', label='onlygrau (softsphere)')    axes[0,0].plot([],[], linewidth=1.2, color='darkgreen', label='noiwc')     axes[0,0].plot([],[], linewidth=1.2, color='magenta', label='half_rain')    axes[0,0].plot([],[], linewidth=1.2, color='gray', label='onlyice')    #axes[0,0].legend(loc='upper left',ncol=6)    fig.legend(loc='lower left', ncol=7, bbox_to_anchor=(0.2,-0.05))    axes[1,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[1,0].plot([],[], linewidth=1.2, color=base_colors[0], label='halfsnow')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[1], label='halfgrau')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[2], label='halfgrausnow')     axes[1,0].plot([],[], linewidth=1.2, color='gray', label='halfrain')    axes[1,0].legend(loc='upper left')    #fig.legend(loc='lower left', ncol=5, bbox_to_anchor=(0.2,-0.14))    axes[1,0].set_ylabel('Counts')    axes[1,0].set_xlabel('BT [K]')    # --- FIGURE 1: BASIC    T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][0,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 0)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlysnow'][0,:,:,:], cloudmask_WRF, 'darkred', axes, 'onlysnow', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau'][0,:,:,:], cloudmask_WRF, 'darkblue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau_softsphere'][0,:,:,:], cloudmask_WRF, 'blue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['noiwc'][0,:,:,:], cloudmask_WRF, 'darkgreen', axes, 'noiwc', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyrain'][0,:,:,:], cloudmask_WRF, 'magenta', axes, 'half_rain', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyice'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'onlyice', '-', maskdo, 0)        # --- FIGURE 2: half contents impact     T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][0,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 1)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfsnow'][0,:,:,:], cloudmask_WRF, base_colors[0], axes, 'half_snow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrau'][0,:,:,:], cloudmask_WRF, base_colors[1], axes, 'half_grau', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrausnow'][0,:,:,:], cloudmask_WRF, base_colors[2], axes, 'half_grausnow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfrain'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 1)      plt.suptitle(suptitle+' (liu:3)')    fig.savefig(plotpath+'/poster/'+'testhistlog_iwcimpact_liu3'+suptitle+'.png', dpi=300,transparent=False, bbox_inches='tight')         #---------------- 2nd for Liu=9    fig, axes = plt.subplots(nrows=2, ncols=4, constrained_layout=True,figsize=[20,10])         # add dummy labels    axes[0,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[0,0].plot([],[], linewidth=1.2, color='darkred', label='onlysnow')    axes[0,0].plot([],[], linewidth=1.2, color='darkblue', label='onlygrau')    axes[0,0].plot([],[], linewidth=1.2, color='blue', label='onlygrau (softsphere)')    axes[0,0].plot([],[], linewidth=1.2, color='darkgreen', label='noiwc')     axes[0,0].plot([],[], linewidth=1.2, color='magenta', label='half_rain')    axes[0,0].plot([],[], linewidth=1.2, color='gray', label='onlyice')    #axes[0,0].legend(loc='upper left',ncol=6)    fig.legend(loc='lower left', ncol=7, bbox_to_anchor=(0.2,-0.05))    axes[1,0].plot([],[], linewidth=1.2, color='k', label='control')     axes[1,0].plot([],[], linewidth=1.2, color=base_colors[0], label='halfsnow')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[1], label='halfgrau')    axes[1,0].plot([],[], linewidth=1.2, color=base_colors[2], label='halfgrausnow')     axes[1,0].plot([],[], linewidth=1.2, color='gray', label='halfrain')    axes[1,0].legend(loc='upper left')    #fig.legend(loc='lower left', ncol=5, bbox_to_anchor=(0.2,-0.14))    axes[1,0].set_ylabel('Counts')    axes[1,0].set_xlabel('BT [K]')    # --- FIGURE 1: BASIC    T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][1,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 0)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlysnow'][1,:,:,:], cloudmask_WRF, 'darkred', axes, 'onlysnow', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau'][1,:,:,:], cloudmask_WRF, 'darkblue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlygrau_softsphere'][0,:,:,:], cloudmask_WRF, 'blue', axes, 'onlygrau', '-', maskdo, 0)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['noiwc'][1,:,:,:], cloudmask_WRF, 'darkgreen', axes, 'noiwc', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyrain'][0,:,:,:], cloudmask_WRF, 'magenta', axes, 'half_rain', '-', maskdo, 0)      T2P.add_hists_2fig_simple_2rowslog( rttov_as['onlyice'][0,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 0)     T2P.add_hists_2fig_simple_2rowslog( rttov_as['control'][1,:,:,:], cloudmask_WRF, 'k', axes, 'control', '-', maskdo, 1)        T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfsnow'][1,:,:,:], cloudmask_WRF, base_colors[0], axes, 'half_snow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrau'][1,:,:,:], cloudmask_WRF, base_colors[1], axes, 'half_grau', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfgrausnow'][1,:,:,:], cloudmask_WRF, base_colors[2], axes, 'half_grausnow', '-', maskdo, 1)          T2P.add_hists_2fig_simple_2rowslog( rttov_as['halfrain'][1,:,:,:], cloudmask_WRF, 'gray', axes, 'half_rain', '-', maskdo, 1)        plt.suptitle(suptitle+' (liu:9)')    fig.savefig(plotpath+'/poster/'+'testhistlog_iwcimpact_liu9'+suptitle+'.png', dpi=300,transparent=False, bbox_inches='tight')       return#------------------------------------------------------------------------------def make_histogram_iwc_impacts(server, processedFolder):        plotpath, folders = config_folders(server)        #---- READ DATA    #------------------------------------------------------------------------------------------    rttov_as_iwc_eqMass, _             = get_iwc_experiment_andcut( 'rttov_processed_allsky_eqMass_rsg_s', processedFolder)    rttov_as_iwc_WSM6, cloudmask_WRF   = get_iwc_experiment_andcut( 'rttov_processed_allsky_rsg_s', processedFolder)    #---- DO THE PLOTS: 1) impact of IWC sensitivities (note graupel soft sphere similar to liu3)     #------------------------------------------------------------------------------------------        # eqMass-WSM6 and WSM6    histogram_iwc_impacts(rttov_as_iwc_eqMass, 'eqMass_WSM6', cloudmask_WRF, plotpath)    histogram_iwc_impacts(rttov_as_iwc_WSM6, 'WSM6', cloudmask_WRF, plotpath)        return#------------------------------------------------------------------------------def make_barplots_liuliu(experiment_grid, rttov_eqMass, rttov_WSM6, server):            # check = rttov_eqMass['rttov_as'][0,0,0,:,:].copy()    # masked_arr = np.where(check <= 250, check, np.nan)    # plt.pcolor(masked_arr); plt.colorbar()    # plt.pcolor(rttov_eqMass['rttov_as'][0,0,0,:,:]); plt.colorbar()            import matplotlib.patches as mpatches  # Add this at the top of your script        plotpath, folders = config_folders(server)    ichan_title     = ['89.0', '157.0', '183.311$\pm$3', '190.311']    chan_indx       = [0,1,3,4]    base_colors     = sns.color_palette('Paired')             all_shades = []    for base in base_colors:        shades = sns.light_palette(base, n_colors=11, input='rgb') #, reverse=True)        all_shades.append(shades)                categories = ['Long hex col.','Short hex col.','Block hex col.','Thick hex col','Thin hex col.',                '3b ros.','4b ros.','5b ros.','6b ros.','Sector','Dendrite']             var_wrfgrid_eqMass    = rttov_eqMass['delta_rttov_as'].copy()    var_wrfgrid          = rttov_WSM6['delta_rttov_as'].copy()            # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.7)    for index, i in enumerate(chan_indx):        axes[0,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)                        axes[0,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[0,index].grid(True)        axes[0,index].set_ylim([-600,10])        axes[0,index].set_xticklabels(axes[0,index].get_xticklabels(), rotation=45, ha='right')    #axes[0,index].legend(loc='center left', title='Graupel', bbox_to_anchor=(1,0.5))            legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'Liu: {str(i)}') for i in range(11) ]    fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')    fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        for index, i in enumerate(chan_indx):        axes[1,index].set_title(ichan_title[index]+' GHz')        stacked_means = np.zeros(len(categories))         bottom = np.zeros(len(categories))         for isnow in range(11):            stacked_means = np.zeros(len(categories))             for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 stacked_means[igrau] = np.nanmean(masked_var)            axes[1,index].bar(categories, stacked_means, color=base_colors[isnow], bottom=bottom)            bottom += stacked_means         axes[1,index].set_ylim([-600,10])        axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[1,index].grid(True)    axes[1,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')    fig.text(0.5, 0.45, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')    fig.savefig(plotpath+'/poster/'+'stack_liuliu_barplots.png', dpi=300,transparent=False, bbox_inches='tight')       #----------------------------        # One for aach i snow    # mean dTB (rttov_as - rttov_cs) below 240K    for isnow in range(11):        fig, axes = plt.subplots(nrows=2, ncols=4,figsize=[20,10])            fig.subplots_adjust(hspace=0.7)        for index, i in enumerate(chan_indx):            axes[0,index].set_title(ichan_title[index]+' GHz')                wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid_eqMass[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid_eqMass[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(masked_var) )            axes[0,index].bar(categories, wrfgridmean, color=base_colors)            axes[0,index].set_ylim([-50,10])            axes[0,index].grid(True)            axes[0,index].set_xticklabels(axes[0,index].get_xticklabels(), rotation=45, ha='right')        axes[0,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')                legend_elements = [ mpatches.Patch(facecolor=base_colors[i], label=f'Liu: {str(i)}') for i in range(11) ]        fig.legend(            handles=legend_elements,             loc='center left',             bbox_to_anchor=(0.93, 0.5),            title='Graupel')        for index, i in enumerate(chan_indx):            wrfgridmean = []            for igrau in range(11):                var        = var_wrfgrid[isnow,igrau,i,:,:]                masked_var = np.where( (var_wrfgrid[isnow,igrau,0,:,:]) <= 250, var, np.nan)                masked_var = masked_var.flatten()                 wrfgridmean.append( np.nanmean(masked_var) )            axes[1,index].bar(categories, wrfgridmean, color=base_colors)            axes[1,index].set_ylim([-50,10])            axes[1,index].grid(True)            axes[1,index].set_xticklabels(axes[1,index].get_xticklabels(), rotation=45, ha='right')        axes[1,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')                        fig.text(0.5, 0.45, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+f' ({experiment_grid})', ha='center', va='center', fontsize=16,fontweight='bold')        fig.savefig(plotpath+'/poster/'+f'singleisnow_{isnow}_liuliu_barplots.png', dpi=300,transparent=False, bbox_inches='tight')               return#------------------------------------------------------------------------------def return_data4stats_inputs(rttov):         values     = rttov['delta_rttov_as']        var        = values[0,0,0,:,:]    nlon,nlat = var.shape        values     = rttov['delta_Gaussianan']    var        = values[0,0,0,:,:]    nlon_obs,nlat_obs = var.shape    delta_rttov  = np.zeros((11,11,5,nlon,nlat)); delta_rttov[:] = np.nan     delta_gaus   = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_gaus[:]  = np.nan     delta_mean   = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_mean[:]  = np.nan     delta_interp = np.zeros((11,11,5,nlon_obs,nlat_obs)); delta_interp[:] = np.nan         for isnow in range(11):        for igrau in range(11):            for ifreq in range(5):                values     = rttov['delta_rttov_as']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_rttov[isnow,igrau,ifreq,:,:] = masked_var                values     = rttov['delta_Gaussianan']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_gaus[isnow,igrau,ifreq,:,:] = masked_var                                values     = rttov['delta_mean']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_mean[isnow,igrau,ifreq,:,:] = masked_var                                values     = rttov['delta_Interp']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                delta_interp[isnow,igrau,ifreq,:,:] = masked_var                    ifreq = 0    data_array_0 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 1    data_array_1 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 2    data_array_2 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 3    data_array_3 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }    ifreq = 4    data_array_4 = {        'wrf_grid': (delta_rttov[3,3,ifreq,:,:], delta_rttov[3,9,ifreq,:,:], delta_rttov[9,3,ifreq,:,:], delta_rttov[9,9,ifreq,:,:]  ),        'gaussian': (delta_gaus[3,3,ifreq,:,:], delta_gaus[3,9,ifreq,:,:], delta_gaus[9,3,ifreq,:,:], delta_gaus[9,9,ifreq,:,:]  ),        'delta_mean': (delta_mean[3,3,ifreq,:,:], delta_mean[3,9,ifreq,:,:], delta_mean[9,3,ifreq,:,:], delta_mean[9,9,ifreq,:,:]  ),        'delta_Interp': (delta_interp[3,3,ifreq,:,:], delta_interp[3,9,ifreq,:,:], delta_interp[9,3,ifreq,:,:], delta_interp[9,9,ifreq,:,:]  ),        }        return data_array_0, data_array_1, data_array_2, data_array_3, data_array_4#------------------------------------------------------------------------------def return_barplot_inputs(rttov):     means_delta_rttov  = np.zeros((11,11,5)); means_delta_rttov[:] = np.nan     means_delta_gaus   = np.zeros((11,11,5)); means_delta_gaus[:]  = np.nan     means_delta_mean   = np.zeros((11,11,5)); means_delta_mean[:]  = np.nan     means_delta_interp = np.zeros((11,11,5)); means_delta_interp[:] = np.nan         for isnow in range(11):        for igrau in range(11):            for ifreq in range(5):                values     = rttov['delta_rttov_as']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_rttov[isnow,igrau,ifreq] = np.nanmean(masked_var)                values     = rttov['delta_Gaussianan']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_gaus[isnow,igrau,ifreq] = np.nanmean(masked_var)                                values     = rttov['delta_mean']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_mean[isnow,igrau,ifreq] = np.nanmean(masked_var)                                values     = rttov['delta_Interp']                var        = values[isnow,igrau,ifreq,:,:]                masked_var = np.where( (values[isnow,igrau,0,:,:]) <= 250, var, np.nan)                means_delta_interp[isnow,igrau,ifreq] = np.nanmean(masked_var)                    ifreq = 0    data_array_0 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 1    data_array_1 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 2    data_array_2 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 3    data_array_3 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }    ifreq = 4    data_array_4 = {        'wrf_grid': (means_delta_rttov[3,3,ifreq], means_delta_rttov[3,9,ifreq], means_delta_rttov[9,3,ifreq], means_delta_rttov[9,9,ifreq]  ),        'gaussian': (means_delta_gaus[3,3,ifreq], means_delta_gaus[3,9,ifreq], means_delta_gaus[9,3,ifreq], means_delta_gaus[9,9,ifreq]  ),        'delta_mean': (means_delta_mean[3,3,ifreq], means_delta_mean[3,9,ifreq], means_delta_mean[9,3,ifreq], means_delta_mean[9,9,ifreq]  ),        'delta_Interp': (means_delta_interp[3,3,ifreq], means_delta_interp[3,9,ifreq], means_delta_interp[9,3,ifreq], means_delta_interp[9,9,ifreq]  ),        }        return data_array_0, data_array_1, data_array_2, data_array_3, data_array_4#------------------------------------------------------------------------------def make_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server):        import matplotlib.patches as mpatches  # Add this at the top of your script    plotpath, folders = config_folders(server)        #- for the plot:    categories = ['Thick hex col','Sector']         category_positions = np.arange(len(categories))  # Numeric positions for categories    experiments = ['wrf grid', 'gaussian', 'mean', 'nearest' ]    colors_     = ['k','darkblue','darkred','darkgreen']    x           = np.arange(4)  # the label locations    width       = 0.2    # the width of the bars    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.5)        #- get data for the first row        data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_barplot_inputs(rttov_eqMass)    row = 0    #- frequency 89GHz    axes[row,0].bar( x, data_array_0['wrf_grid'], width, color='k')    axes[row,0].bar( x+0.2, data_array_0['gaussian'], width, color='darkblue')    axes[row,0].bar( x+0.4, data_array_0['delta_mean'], width, color='darkred')    axes[row,0].bar( x+0.6, data_array_0['delta_Interp'], width, color='darkgreen')    axes[row,0].set_title('89.0 GHz')        #- frequency 157GHz    axes[row,1].bar( x, data_array_1['wrf_grid'], width, color='k')    axes[row,1].bar( x+0.2, data_array_1['gaussian'], width, color='darkblue')    axes[row,1].bar( x+0.4, data_array_1['delta_mean'], width, color='darkred')    axes[row,1].bar( x+0.6, data_array_1['delta_Interp'], width, color='darkgreen')    axes[row,1].set_title('157 GHz')                #- frequency 157GHz    axes[row,2].bar( x, data_array_3['wrf_grid'], width, color='k')    axes[row,2].bar( x+0.2, data_array_3['gaussian'], width, color='darkblue')    axes[row,2].bar( x+0.4, data_array_3['delta_mean'], width, color='darkred')    axes[row,2].bar( x+0.6, data_array_3['delta_Interp'], width, color='darkgreen')    axes[row,2].set_title('183.311$\pm$3 GHz')                    #- frequency 190GHz    axes[row,3].bar( x, data_array_4['wrf_grid'], width, color='k')    axes[row,3].bar( x+0.2, data_array_4['gaussian'], width, color='darkblue')    axes[row,3].bar( x+0.4, data_array_4['delta_mean'], width, color='darkred')    axes[row,3].bar( x+0.6, data_array_4['delta_Interp'], width, color='darkgreen')    axes[row,3].set_title('190.311 GHz')                    for i in range(4):        axes[row,i].set_xticks(x + width, ['s3g3','s3g9','s9g3','s9g9'])        axes[row,i].set_ylim([-50,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')                legend_elements = [ mpatches.Patch(facecolor=colors_[i], label=f'{experiments[i]}') for i in range(4) ]    fig.legend(        handles=legend_elements,         loc='center left',         bbox_to_anchor=(0.93, 0.5),        title='Footprint')        axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                        #- get data for the first row        data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_barplot_inputs(rttov_WSM6)    row = 1    #- frequency 89GHz    axes[row,0].bar( x, data_array_0['wrf_grid'], width, color='k')    axes[row,0].bar( x+0.2, data_array_0['gaussian'], width, color='darkblue')    axes[row,0].bar( x+0.4, data_array_0['delta_mean'], width, color='darkred')    axes[row,0].bar( x+0.6, data_array_0['delta_Interp'], width, color='darkgreen')    axes[row,0].set_title('89.0 GHz')        #- frequency 157GHz    axes[row,1].bar( x, data_array_1['wrf_grid'], width, color='k')    axes[row,1].bar( x+0.2, data_array_1['gaussian'], width, color='darkblue')    axes[row,1].bar( x+0.4, data_array_1['delta_mean'], width, color='darkred')    axes[row,1].bar( x+0.6, data_array_1['delta_Interp'], width, color='darkgreen')    axes[row,1].set_title('157 GHz')                #- frequency 157GHz    axes[row,2].bar( x, data_array_3['wrf_grid'], width, color='k')    axes[row,2].bar( x+0.2, data_array_3['gaussian'], width, color='darkblue')    axes[row,2].bar( x+0.4, data_array_3['delta_mean'], width, color='darkred')    axes[row,2].bar( x+0.6, data_array_3['delta_Interp'], width, color='darkgreen')    axes[row,2].set_title('183.311$\pm$3 GHz')                    #- frequency 190GHz    axes[row,3].bar( x, data_array_4['wrf_grid'], width, color='k')    axes[row,3].bar( x+0.2, data_array_4['gaussian'], width, color='darkblue')    axes[row,3].bar( x+0.4, data_array_4['delta_mean'], width, color='darkred')    axes[row,3].bar( x+0.6, data_array_4['delta_Interp'], width, color='darkgreen')    axes[row,3].set_title('190.311 GHz')                    for i in range(4):        axes[row,i].set_xticks(x + width, ['s3g3','s3g9','s9g3','s9g9'])        axes[row,i].set_ylim([-50,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')                 axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.48, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    fig.savefig(plotpath+'/poster/'+f'sampleexperment_4footprintmodel_barplots.png', dpi=300,transparent=False, bbox_inches='tight')       return#------------------------------------------------------------------------------def do_whiskers(row, col_index, axes, x, data, color_in, width):        offset = [0, 10, 20, 30]    for i in range(len(data)):        p15 = np.nanpercentile(data[i], 15)        p25 = np.nanpercentile(data[i], 25)        p75 = np.nanpercentile(data[i], 75)        p95 = np.nanpercentile(data[i], 95)                mean_ = np.nanmean(data[i])        # Draw the box from 25th to 75th        axes[row,col_index].vlines(x+offset[i], ymin=p25, ymax=p75, color=color_in, linewidth=10)        axes[row,col_index].vlines(x+offset[i], ymin=p15, ymax=p95, color=color_in, linewidth=2)        # Draw the mean as a bold vertical line        x1 = x+offset[i]        axes[row,col_index].hlines(y=mean_, xmin=x1-(width/2), xmax=x1+(width/2), color='k', linewidth=3)    return axes #------------------------------------------------------------------------------def make_distrib_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, server):        import matplotlib.patches as mpatches  # Add this at the top of your script    plotpath, folders = config_folders(server)        #- for the plot:    categories = ['Thick hex col','Sector']         category_positions = np.arange(len(categories))  # Numeric positions for categories    experiments = ['wrf grid', 'gaussian', 'mean', 'nearest' ]    colors_     = ['k','darkblue','darkred','darkgreen']    x           = [0, 2, 4, 6] # the label locations    width       = 1    # the width of the bars    # mean dTB (rttov_as - rttov_cs) below 240K    fig, axes = plt.subplots(nrows=2, ncols=4,  figsize=[20,12])    #constrained_layout=True,    fig.subplots_adjust(hspace=0.5)    #------     #- get data for the first row      row = 0    data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_eqMass)    #- frequency 89GHz    axes = do_whiskers(row, 0, axes, x[0], data_array_0['wrf_grid'], 'k', width)    axes = do_whiskers(row, 0, axes, x[1], data_array_0['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 0, axes, x[2], data_array_0['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 0, axes, x[3], data_array_0['delta_Interp'], 'darkgreen', width)    axes[row,0].set_title('89.0 GHz')            #- frequency 157    axes = do_whiskers(row, 1, axes, x[0], data_array_1['wrf_grid'], 'k', width)    axes = do_whiskers(row, 1, axes, x[1], data_array_1['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 1, axes, x[2], data_array_1['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 1, axes, x[3], data_array_1['delta_Interp'], 'darkgreen', width)    axes[row,1].set_title('157 GHz')                #- frequency 183    axes = do_whiskers(row, 2, axes, x[0], data_array_3['wrf_grid'], 'k', width)    axes = do_whiskers(row, 2, axes, x[1], data_array_3['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 2, axes, x[2], data_array_3['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 2, axes, x[3], data_array_3['delta_Interp'], 'darkgreen', width)    axes[row,2].set_title('183.311$\pm$3 GHz')            #- frequency 190    axes = do_whiskers(row, 3, axes, x[0], data_array_4['wrf_grid'], 'k', width)    axes = do_whiskers(row, 3, axes, x[1], data_array_4['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 3, axes, x[2], data_array_4['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 3, axes, x[3], data_array_4['delta_Interp'], 'darkgreen', width)    axes[row,3].set_title('190.311 GHz')                   for i in range(4):        axes[row,i].set_xticks( [5,15,25,35], ['s3g3','s3g9','s9g3','s9g9'])        #axes[row,i].set_ylim([-,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')              legend_elements = [ mpatches.Patch(facecolor=colors_[i], label=f'{experiments[i]}') for i in range(4) ]    fig.legend(        handles=legend_elements,         loc='center left',         bbox_to_anchor=(0.93, 0.5),        title='Footprint')        axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.95, r'$\Delta$BT (rttov_as - rttov_cl) eqMass_WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    #------     #- get data for the first row      row = 1    data_array_0, data_array_1, data_array_2, data_array_3, data_array_4 = return_data4stats_inputs(rttov_WSM6)    #- frequency 89GHz    axes = do_whiskers(row, 0, axes, x[0], data_array_0['wrf_grid'], 'k', width)    axes = do_whiskers(row, 0, axes, x[1], data_array_0['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 0, axes, x[2], data_array_0['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 0, axes, x[3], data_array_0['delta_Interp'], 'darkgreen', width)    axes[row,0].set_title('89.0 GHz')            #- frequency 157    axes = do_whiskers(row, 1, axes, x[0], data_array_1['wrf_grid'], 'k', width)    axes = do_whiskers(row, 1, axes, x[1], data_array_1['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 1, axes, x[2], data_array_1['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 1, axes, x[3], data_array_1['delta_Interp'], 'darkgreen', width)    axes[row,1].set_title('157 GHz')                #- frequency 183    axes = do_whiskers(row, 2, axes, x[0], data_array_3['wrf_grid'], 'k', width)    axes = do_whiskers(row, 2, axes, x[1], data_array_3['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 2, axes, x[2], data_array_3['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 2, axes, x[3], data_array_3['delta_Interp'], 'darkgreen', width)    axes[row,2].set_title('183.311$\pm$3 GHz')            #- frequency 190    axes = do_whiskers(row, 3, axes, x[0], data_array_4['wrf_grid'], 'k', width)    axes = do_whiskers(row, 3, axes, x[1], data_array_4['gaussian'], 'darkblue', width)    axes = do_whiskers(row, 3, axes, x[2], data_array_4['delta_mean'], 'darkred', width)    axes = do_whiskers(row, 3, axes, x[3], data_array_4['delta_Interp'], 'darkgreen', width)    axes[row,3].set_title('190.311 GHz')                   for i in range(4):        axes[row,i].set_xticks( [5,15,25,35], ['s3g3','s3g9','s9g3','s9g9'])        #axes[row,i].set_ylim([-,4])        axes[row,i].grid(True)        axes[row,i].set_xticklabels(axes[row,0].get_xticklabels(), rotation=45, ha='right')              axes[row,0].set_ylabel(r'$\Delta$BT [K] (BT(89clear)<250K)')            fig.text(0.5, 0.48, r'$\Delta$BT (rttov_as - rttov_cl) WSM6'+' (Footprint model)', ha='center', va='center', fontsize=16,fontweight='bold')                    fig.savefig(plotpath+'/poster/'+f'sampleexperment_4footprintmodel_barplots_whiskers.png', dpi=300,transparent=False, bbox_inches='tight')               return # cd datosmunin3/Work/Studies/HAILCASE_10112018/src/rttov_call/#------------------------------------------------------------------------------------------#------------------------------------------------------------------------------------------mp_physics = 'WRF-WSM6'server = 'yakaira'# Select server and folder locations#--------------------------------------------------------------------------if 'yakaira' in server:     upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'    sys.path.insert(1,'/home/vito.galligani/datosmunin3/Work/Studies/HAILCASE_10112018/src')    processedFolder = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/Processed/'+mp_physics    mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'            elif 'cnrm' in server:    upfolder    = '/home/galliganiv/'       sys.path.insert(1,'/home/galliganiv/ACMS_hail/src')    processedFolder = '/home/galliganiv/Work/HAILCASE_10112018/RTTOVinout/Processed/'+mp_physics    mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'        already_run_final = 1#------------------------------------------------------------------------------------------# Lots of experiments now. I want to # 1) Look at histograms for experiiments on iwc#------------------------------------------------------------------------------------------if already_run_final == 0:    make_histogram_iwc_impacts('yakaira', processedFolder) # 2) Barplots of the impact of the different liuliu combinations #------------------------------------------------------------------------------------------rttov_eqMass = get_liuliu_experiments_andcut('rttov_processed_allsky_eqMass_rsg_s', processedFolder)rttov_WSM6   = get_liuliu_experiments_andcut('rttov_processed_allsky_rsg_s', processedFolder)if already_run_final == 0:    make_barplots_liuliu('wrf grid', rttov_eqMass, rttov_WSM6, 'yakaira')# 3) Barplots of the impact of the different lantenna resolutions? for liu3 ad liu9 (w/ whiskers)#------------------------------------------------------------------------------------------if already_run_final == 0:    make_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, 'yakaira')    make_distrib_barplots_liuliu_footprints(rttov_eqMass, rttov_WSM6, 'yakaira')                                already_run_final = 0#---- DO THE PLOTS: 2) impact of IWC sensitivities depending on footprint model#------------------------------------------------------------------------------------------  # final take on the index? # run a differnt clud fraction or sieron et al. approach ?#---- DO THE PLOTS: 3)#------------------------------------------------------------------------------------------  #  what about iwc? and what about cloud fractions?         