#------------------------------------------------------------------------------# to ensure that pyrttov is importableimport sys#import pyrttov#import globimport numpy as npfrom netCDF4 import Datasetimport os #import typhon  as tyimport matplotlib.pyplot as pltimport xarray as xrfrom matplotlib.colors import ListedColormapfrom datetime import datetimeimport gpm_api as gpm##from gpm.utils.geospatial import get_continent_extentfrom scipy.interpolate import griddata#------------------------------------------------------------------------------# This script reads nc file of IFS profilesdef read_wrf(ncfile):         # NOTES:    # 1/ PSFC is a diagnostic variable, which is calculated based on hydrostatic equilibrium equation.     # Unless the vertical motion is very strong, it is rare that PSFC could be lower than upper level pressure.     # 2/ voy a ignorar pq sino en algunos casos psfc me queda mas abajo que lowest level ???.         # Open ncfile    #data = xr.open_dataset(ncfile)    data = Dataset(ncfile,'r')           # Hydrometeor content    A = {}        A['swc']    = data.variables['QSNOW'][0,:,:,:]      # mixing ration: kg/kg    A['iwc']    = data.variables['QICE'][0,:,:,:]       # mixing ration: kg/kg    A['gwc']    = data.variables['QGRAUP'][0,:,:,:]     # mixing ration: kg/kg    A['rwc']    = data.variables['QRAIN'][0,:,:,:]      # mixing ration: kg/kg    #A['cc']    = data.variables['cc'][:]               # cloud cover    A['cldfra'] = data.variables['CLDFRA'][0,:,:,:]     # cloud fraction        A['h20']  = data.variables['QVAPOR'][0,:,:,:]       # mixing ration: kg/kg     #A['o3']  = data.variables['o3'][:]                 # kg/kg         #A['pf']   = data.variables['pressure_full'][:]     # Pa, n = 137    #A['ph']   = data.variables['pressure_half'][:]     # Pa, n = 138    A['pertT'] = data.variables['T'][0,:,:,:]           # perturbation potential temperature  % (theta-t0) (K)     A['tsfc']  = data.variables['TSK'][0,:,:]           # surface temperature    A['z0']    = data.variables['HGT'][0,:,:]           # terrein height in m     A['XLAT']  = data.variables['XLAT'][0,:,:]          # lat     A['XLONG'] = data.variables['XLONG'][0,:,:]         # lon    A['P']     = data.variables['P'][0,:,:,:]           # perturbation pressure (Pa)    A['PB']    = data.variables['PB'][:][0,:,:,:]       # base state (Pa)     A['PSFC']  = data.variables['PSFC'][0,:,:]/100      # surface pressure (hPa)    #A['T00']   = data.variables['T00'][:]              # base state temperature (K)      A['PH']    = data.variables['PH'][0,:,:,:]          # perturbation geopotential (m2s-2)    A['PHB']   = data.variables['PHB'][0,:,:,:]         # base-state geopotential (m2s-2)    A['LANDMASK']  = data.variables['LANDMASK'][0,:,:]  # 1-land, 0-water    # Calculate the temperature and pressure    A['pressure'] = (A['P']+A['PB'])/100;               # (ds.P + ds.PB)/100. # ignore perturbation pressure as this could break monotonicity in p, and RTTOV    theta         = A['pertT']+300                      # theta    A['T']        = theta*(A['pressure']*1e-3)**(2/7)   # ignoring water vapor in conversion to dry temperature    nlev          = A['pressure'].shape[0]        # check monotonicity in WRF total pressure:    # for i in range(A['XLONG'].shape[0]):     #     for j in range(5): #A['XLONG'].shape[1]):     #         for k in range(nlev-1, 0, -1):        # From bottom to top (kte to kts+1 in reverse)    #             if A['pressure'][k,i,j] >= A['pressure'][k-1,i,j]:    #                 message = f"Should skip the pixel at loc {i}, {j} where the pressure is not monotonic"    #                 print(message)                    # Constuct the half-pressure levels: TSFC concatinated with 'pressure'    del nlev    nlev          = A['pressure'].shape[0] + 1    PSFC_expanded = np.expand_dims(A['PSFC'], axis=0)    A['halfpressure'] = np.concatenate((PSFC_expanded, A['pressure']), axis=0)        # The easy way to calculate surface pressure (psfc) is (suppose you have sea level pressure 'mslp', temperature, terrain etc)    # psfc = mslp * ( 1.0 + gamma * ter / avgsfct) ** ( - g / ( Rd * gamma ) )    # where gamma = 6.5E-3, g = 9.8, rd = = 287.04, "ter" is terrain height, avgsfct is surface temperature    # Convert Surface Pressure to Mean Sea Level Pressure	    #stemps = data.variables['T2'] + 6.5*data.variables['HGT'][0,:,:]/1000.    #mslp = A['PSFC']*np.exp(9.81/(287.0*stemps)*data.variables['HGT'][0,:,:])*0.01 + (6.7 * data.variables['HGT'][0,:,:] / 1000)    #psfc = mslp * ( 1.0 + 6.5E-3 *  A['z0'] / A['tsfc']) ** ( - 9.8 / ( 287.04 * 6.5E-3 ) )    check_psfc = 0     if check_psfc == 1:                 # For this case scenario: Total WRF profiles: 504*440 = 221.760        # hard code to make them samller        prov = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')        #plt.pcolormesh(A['XLONG'][0,:,:], A['XLAT'][0,:,:], np.sum(A['swc'], axis=1)[0,:,:]); plt.show()        #plt.plot(prov[:,0],prov[:,1],color='w'); plt.xlim([-68,-62]); plt.ylim([-36,-31])        # Try 100: lo bajamos a 350x410 == 143.500        #plt.pcolormesh(A['XLONG'][0,100:450,30:], A['XLAT'][0,100:450,30:], np.sum(A['swc'][:,:,100:450,30:], axis=1)[0,:,:]); plt.show()        # para hacer pruebas vamos a probar primero un poco: 21000 perfiles        #plt.pcolormesh(A['XLONG'][0,250:400,300:], A['XLAT'][0,250:400,300:], np.sum(A['swc'][:,:,250:400,300:], axis=1)[0,:,:]);                 ncfile_d01   = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/WRFout_WSM6_v4.5.2/wrfout_d01_2018-11-10_20:30:00'        data_d01     = Dataset(ncfile_d01,'r')        datad01_p    = data_d01.variables['P'][0,0,:,:]        datad01_pb   = data_d01.variables['PB'][0,0,:,:]        datad01_ptot = datad01_pb+datad01_p        plt.pcolormesh( data_d01.variables['XLONG'][0,:,:], data_d01.variables['XLAT'][0,:,:],                        (data_d01.variables['PSFC'][0,:,:]/100)-(datad01_ptot/100)); plt.colorbar();         plt.title('WSM6 WRFOUT D01 PSFC - (P+PB) in hPa')        plt.plot(prov[:,0],prov[:,1],color='w'); plt.xlim([-70,-60]); plt.ylim([-38,-29])        plt.show()                 data_p    = data.variables['P'][0,0,:,:]        data_pb   = data.variables['PB'][0,0,:,:]        data_ptot = data_pb+data_p        plt.pcolormesh( data.variables['XLONG'][0,:,:], data.variables['XLAT'][0,:,:],                        (data.variables['PSFC'][0,:,:]/100)-(data_ptot/100)); plt.colorbar();         plt.title('WSM6 WRFOUT D02 PSFC - (P+PB) in hPa')        plt.plot(prov[:,0],prov[:,1],color='w'); plt.xlim([-70,-60]); plt.ylim([-38,-29])        plt.show()                        data_ind01 = Dataset('/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/WRFout_WSM6_v4.5.2/wrfinput_d01','r')            data_ind02 = Dataset('/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/WRFout_WSM6_v4.5.2/wrfinput_d02','r')            dataind01_p    = data_ind01.variables['P'][0,0,:,:]        dataind01_pb   = data_ind01.variables['PB'][0,0,:,:]        dataind01_ptot = dataind01_p+dataind01_pb        plt.pcolormesh( data_ind01.variables['XLONG'][0,:,:], data_ind01.variables['XLAT'][0,:,:],                        (data_ind01.variables['PSFC'][0,:,:]/100)-(dataind01_ptot/100), vmin=100, vmax=350); plt.colorbar();         plt.title('WSM6 wrfinput_d01 PSFC - (P+PB) in hPa')        plt.plot(prov[:,0],prov[:,1],color='w'); plt.xlim([-70,-60]); plt.ylim([-38,-29])        plt.show()                 dataind02_p    = data_ind02.variables['P'][0,0,:,:]        dataind02_pb   = data_ind02.variables['PB'][0,0,:,:]        dataind02_ptot = dataind02_p+dataind02_pb        plt.pcolormesh( data_ind02.variables['XLONG'][0,:,:], data_ind02.variables['XLAT'][0,:,:],                        (data_ind02.variables['PSFC'][0,:,:]/100)-(dataind02_ptot/100), vmin=100, vmax=350); plt.colorbar();         plt.title('WSM6 wrfinput_d02 PSFC - (P+PB) in hPa')        plt.plot(prov[:,0],prov[:,1],color='w'); plt.xlim([-70,-60]); plt.ylim([-38,-29])        plt.show()             print( '-------------------------------------------------------' )    return A  #------------------------------------------------------------------------------# This script outputs a specific profile of the IFS global profilesdef SelectProf(A,ii,jj):     Ai = {}    F1 = list(A.keys())    for k in range(len(F1)):        fname = F1[k]        if len(A[fname].shape) == 2:            Ai[fname] = A[fname].data[ii,jj]        else:            Ai[fname] = A[fname].data[:,ii,jj]    return Ai  #------------------------------------------------------------------------------# This script crate the input clear-sky and all-sky profiles for rttov v4def rttov14_prof_realistic_fixedZenith(Ai, surface_emissivity, file_path_atm, file_path_hydro, counter, i, j):             # note that the convention in RTTOV is TOA to surface that is why i reverse the order     #------------------------------------------------------------------------------------    # Variables in full levels (hPa):  space ---> surface    full_t = Ai['T'][::-1]                    # Temperature         full_q = Ai['h20'][::-1]                  # Water vapor # kg/kg        # Pressure levels     #full_p = Ai['pressure'][::-1]            # 'Full levels' n = 44       NO LO VOY A AGREGAR. QUE SE CALCULE INTERNAMENTE      half_p = Ai['halfpressure'][::-1]         # 'half levels' nlevels = n+1                LandFlag = Ai['LANDMASK']     if LandFlag == 1:        LandFlag = 0             # rttov surftype (land=0, sea=1, sea-ice=2). The surface type specified in the profiles(:)%skin(:)%surftype variable (Table 7.2, Annex J) determines the type of                                 # emissivity and/or reflectance calculation performed for channels                                  # where calc_emis/brdf/diffuse_refl(:) are true    elif LandFlag == 0:        LandFlag = 1     latitude  = Ai['XLAT']    longitude = Ai['XLONG']  + 360    # TRANSFORM TO Longitude (0-360)      #------    # Plot the levels     plot_pres = 0    if plot_pres == 1:         fig = plt.figure(figsize=(4,4))         plt.axhline(np.nan, color = 'k', linestyle = '-', label='half levels')         plt.legend(ncol=2)        #for i in range(len(full_p)):        #    plt.axhline(y = full_p[i]/100, color = 'r', linestyle = '-')         for i in range(len(half_p)):             plt.axhline(y = half_p[i], color = 'k', linestyle = '-')                 #plt.ylim([1000, 1035])        plt.ylabel('Pressure [hPa]')            plt.title('Pressure levels')            plt.show()        # Surface     rte_pos = np.abs( Ai['z0']/1e3 )    # surface altitude: km    t_sfc = Ai['tsfc']        #--------------------------------------------------------------------------    # Hydrometeor info: (qx_mass_grid[:,0] == CLW) in full levels    qx_mass_full      = np.zeros(( len(full_t), 5))    qx_mass_full[:,1] = Ai['iwc'][::-1]   # iwc kg/kg    qx_mass_full[:,2] = Ai['rwc'][::-1]   # rwc kg/kg    qx_mass_full[:,3] = Ai['swc'][::-1]   # swc kg/kg    qx_mass_full[:,4] = Ai['gwc'][::-1]   # gwc kg/kg    #--------------------------------------------------------------------------    # For cloud fraction        #id1 = qx_mass_full[:,0]>0   #clw is 0    id2 = qx_mass_full[:,1]>0    id3 = qx_mass_full[:,2]>0    id4 = qx_mass_full[:,3]>0    id5 = qx_mass_full[:,4]>0    indices_id2 = np.where(id2 > 0)[0]    indices_id3 = np.where(id3 > 0)[0]    indices_id4 = np.where(id4 > 0)[0]    indices_id5 = np.where(id5 > 0)[0]    # Concatenate the indices (lwc is zero)    cc = np.concatenate((indices_id2, indices_id3, indices_id4, indices_id5))    cc = np.unique(cc)    cf = np.zeros(( len(full_t) ))     cf[cc] = 1            #--------------------------------------------------------------------------        # open in append mode hydro file    with open(file_path_hydro, 'a') as fid:                # Save profile info to file        fid.write(f'! --- Profile --- counter({counter}), i({i}), j({j}) \n')                # Write cloud fraction and hydromteor concentration profiles        fid.write('! cloud fraction and hydromteor concentration profiles \n')             # Loop over each element in 'full_p' (assuming it's a list or NumPy array)         for nn in range(len(full_t)):             # Extract eachlevel value             fid.write(f'{cf[nn]:.6f}\n')                # 6 decimal places            qx_mass_full_nn = qx_mass_full[nn]                    fid.write(f'{qx_mass_full_nn[0]:.10f}\n')  # 6 decimal places            fid.write(f'{qx_mass_full_nn[1]:.10f}\n')  # 6 decimal places            fid.write(f'{qx_mass_full_nn[2]:.10f}\n')  # 6 decimal places            fid.write(f'{qx_mass_full_nn[3]:.10f}\n')  # 6 decimal places            fid.write(f'{qx_mass_full_nn[4]:.10f}\n')  # 6 decimal places                   # Write end of profile marker        fid.write('!\n')        fid.write('! --- End of profile ---\n')                   # Close the file        fid.close()                    # open in append mode Clear-Sky atm    # Correction for clear sky, the last level was the same as at the surface    with open(file_path_atm, 'a') as fid:                # Save profile info to file        fid.write(f'! --- Profile --- counter({counter}), i({i}), j({j}) \n')                # Write gas units        fid.write('! Gas units\n')         fid.write(f'{1}\n')  # Writing integer value (assuming gas units is 1 == kg/kg)        # Write pressure        fid.write('! half pressure levels (hPa)\n')             # Loop over each element in 'full_p' (assuming it's a list or NumPy array)         for nn in range(len(half_p)):             # Extract pressure level value for the current iteration            pressure_hPa = half_p[nn]            fid.write(f'{pressure_hPa:.6f}\n')  # Writing pressure level in hPa format with 6 decimal places                # Write temp        fid.write('! Temperature levels (K)\n')        # Loop over each element in 'full_t' (assuming it's a list or NumPy array)        for temperature in full_t:            fid.write(f'{temperature:.6f}\n')  # Writing temperature level in Kelvin with 6 decimal places           # Write water vapor profiles header        fid.write('! Water vapour profiles (ppmv)\n')        # Loop over each element in 'full_q' (assuming it's a list or NumPy array)        for water_vapor in full_q:            # Convert water vapor level to ppmv and write to file            water_vapor_ppmv = water_vapor            fid.write(f'{water_vapor_ppmv:.6E}\n')  # Writing water vapor level with 6 decimal places        # Write near-surface variables header        fid.write('! Near-surface variables:\n')        # Write near-surface variable descriptions (no longer readl 2mp as == lowest half pressure level)        fid.write('! 2m T (K)    2m q (ppmv)   10m wind u (m/s)      10m wind v (m/s)\n')                # Write near-surface variables data        fid.write(f'{full_t[-1]:.6f}   {full_q[-1]:.6E}   0.00   0.00\n')                # Write skin variables header         fid.write('! Skin variables:\n')        fid.write('! Skin T (K)  FASTEM parameters for land surfaces\n')        # Write skin variables data         fid.write(f'{t_sfc:.2f}  3.00  5.00  15.00  0.10  0.30\n')        # Land Flag        fid.write('! LandFlag: surfacetype_land (0) and surfacetype_sea (1) \n')        fid.write(f'{LandFlag}\n')                  # Write elevation, latitude, and longitude header        fid.write('! Elevation (km) \n')        fid.write(f'{rte_pos:.3f}\n')        # Write latitude        fid.write('! Latitude (degrees)\n')        fid.write(f'{latitude:.4f}\n')        # Write longitude         fid.write('! Longitude (degrees)\n')        fid.write(f'{longitude:.4f}\n')        # Write zenith and azimuth angles header        #fid.write('! Sat. zenith and azimuth angles, solar zenith and azimuth angles (degrees)\n')        #fid.write(f'{zenith:.2f}   0.0\n')                # Write end of profile marker        fid.write('!\n')        fid.write('! --- End of profile ---\n')                   # Close the file        fid.close()    return #------------------------------------------------------------------------------# This script crate the input clear-sky and all-sky profiles for rttov v4def rttov14_prof_realistic(Ai, surface_emissivity, file_path_atm, file_path_hydro, counter, i, j, zenith):             # note that the convention in RTTOV is TOA to surface that is why i reverse the order     #------------------------------------------------------------------------------------    # Variables in full levels (hPa):  space ---> surface    full_t = Ai['T'][::-1]                    # Temperature         full_q = Ai['h20'][::-1]                  # Water vapor # kg/kg        # Pressure levels     #full_p = Ai['pressure'][::-1]            # 'Full levels' n = 44       NO LO VOY A AGREGAR. QUE SE CALCULE INTERNAMENTE      half_p = Ai['halfpressure'][::-1]         # 'half levels' nlevels = n+1                LandFlag = Ai['LANDMASK']     if LandFlag == 1:        LandFlag = 0             # rttov surftype (land=0, sea=1, sea-ice=2). The surface type specified in the profiles(:)%skin(:)%surftype variable (Table 7.2, Annex J) determines the type of                                 # emissivity and/or reflectance calculation performed for channels                                  # where calc_emis/brdf/diffuse_refl(:) are true    elif LandFlag == 0:        LandFlag = 1     latitude  = Ai['XLAT']    longitude = Ai['XLONG']  + 360    # TRANSFORM TO Longitude (0-360) for RTTOV!      #------    # Plot the levels     plot_pres = 0    if plot_pres == 1:         fig = plt.figure(figsize=(4,4))         plt.axhline(np.nan, color = 'k', linestyle = '-', label='half levels')         plt.legend(ncol=2)        #for i in range(len(full_p)):        #    plt.axhline(y = full_p[i]/100, color = 'r', linestyle = '-')         for i in range(len(half_p)):             plt.axhline(y = half_p[i], color = 'k', linestyle = '-')                 #plt.ylim([1000, 1035])        plt.ylabel('Pressure [hPa]')            plt.title('Pressure levels')            plt.show()        # Surface     rte_pos = np.abs( Ai['z0']/1e3 )    # surface altitude: km    t_sfc = Ai['tsfc']        #--------------------------------------------------------------------------    # Hydrometeor info: (qx_mass_grid[:,0] == CLW) in full levels            #--------------------------------------------------------------------------        qx_mass_full      = np.zeros(( len(full_t), 6))    #qx_mass_full      = np.zeros(( len(full_t), 5))    #--------------------------------------------------------------------------    #qx_mass_full[:,1] = Ai['iwc'][::-1]     # iwc kg/kg    #qx_mass_full[:,2] = Ai['rwc'][::-1]     # rwc kg/kg    #qx_mass_full[:,3] = Ai['swc'][::-1]/2   # swc kg/kg part 1    #qx_mass_full[:,4] = Ai['gwc'][::-1]     # gwc kg/kg    #qx_mass_full[:,5] = Ai['swc'][::-1]/2   # swc kg/kg part 2        #--------------------------------------------------------------------------    # qx_mass_full[:,1] = Ai['iwc'][::-1]     # iwc kg/kg    # qx_mass_full[:,2] = Ai['rwc'][::-1]     # rwc kg/kg    # qx_mass_full[:,3] = Ai['swc'][::-1]/2   # swc kg/kg part 1    # qx_mass_full[:,4] = Ai['gwc'][::-1]   # swc kg/kg part 2    # qx_mass_full[:,5] = Ai['swc'][::-1]/2    # gwc kg/kg        #--------------------------------------------------------------------------    snow_lowtemp  = Ai['swc'].copy()    snow_hightemp = Ai['swc'].copy()        # temp1    # snow_lowtemp[Ai['T']>273-8] = 0    # snow_hightemp[Ai['T']<=273-8]=0    # temp2    snow_lowtemp[Ai['T']>273-2] = 0    snow_hightemp[Ai['T']<=273-2]=0        qx_mass_full[:,1] = Ai['iwc'][::-1]     # iwc kg/kg    qx_mass_full[:,2] = Ai['rwc'][::-1]     # rwc kg/kg    qx_mass_full[:,3] = snow_lowtemp[::-1]  # swc kg/kg part 1    qx_mass_full[:,4] = Ai['gwc'][::-1]     # swc kg/kg part 2    qx_mass_full[:,5] = snow_hightemp[::-1] # gwc kg/kg        #Ai['swc'][Ai['T']>280]=0      #--------------------------------------------------------------------------    # For cloud fraction        #id1 = qx_mass_full[:,0]>0   #clw is 0    id2 = qx_mass_full[:,1]>0    id3 = qx_mass_full[:,2]>0    id4 = qx_mass_full[:,3]>0    id5 = qx_mass_full[:,4]>0    #--------------------------------------------------------------------------    id6 = qx_mass_full[:,5]>0    #id7 = qx_mass_full[:,6]>0    indices_id2 = np.where(id2 > 0)[0]    indices_id3 = np.where(id3 > 0)[0]    indices_id4 = np.where(id4 > 0)[0]    indices_id5 = np.where(id5 > 0)[0]    #--------------------------------------------------------------------------    indices_id6 = np.where(id6 > 0)[0]    #indices_id7 = np.where(id7 > 0)[0]    # Concatenate the indices (lwc is zero)    cc = np.concatenate((indices_id2, indices_id3, indices_id4, indices_id5, indices_id6))# , indices_id7))    #cc = np.concatenate((indices_id2, indices_id3, indices_id4, indices_id5))    cc = np.unique(cc)    cf = np.zeros(( len(full_t) ))     cf[cc] = 1            #--------------------------------------------------------------------------        # open in append mode hydro file    with open(file_path_hydro, 'a') as fid:                # Save profile info to file        fid.write(f'! --- Profile --- counter({counter}), i({i}), j({j}) \n')                # Write cloud fraction and hydromteor concentration profiles        fid.write('! cloud fraction and hydromteor concentration profiles \n')             # Loop over each element in 'full_p' (assuming it's a list or NumPy array)         for nn in range(len(full_t)):             # Extract eachlevel value             fid.write(f'{cf[nn]:.6f}\n')                # 6 decimal places            qx_mass_full_nn = qx_mass_full[nn]                    fid.write(f'{qx_mass_full_nn[0]:.10f}\n')  # 6 decimal places cloud            fid.write(f'{qx_mass_full_nn[1]:.10f}\n')  # 6 decimal places ice            fid.write(f'{qx_mass_full_nn[2]:.10f}\n')  # 6 decimal places rain            fid.write(f'{qx_mass_full_nn[3]:.10f}\n')  # 6 decimal places snow/2            fid.write(f'{qx_mass_full_nn[4]:.10f}\n')  # 6 decimal places grau            #--------------------------------------------------------------------------             fid.write(f'{qx_mass_full_nn[5]:.10f}\n')  # 6 decimal places snow/2            #fid.write(f'{qx_mass_full_nn[6]:.10f}\n')  # 6 decimal places                    # Write end of profile marker        fid.write('!\n')        fid.write('! --- End of profile ---\n')                   # Close the file        fid.close()                    # open in append mode Clear-Sky atm    # Correction for clear sky, the last level was the same as at the surface    with open(file_path_atm, 'a') as fid:                # Save profile info to file        fid.write(f'! --- Profile --- counter({counter}), i({i}), j({j}) \n')                # Write gas units        fid.write('! Gas units\n')         fid.write(f'{1}\n')  # Writing integer value (assuming gas units is 1 == kg/kg)        # Write pressure        fid.write('! half pressure levels (hPa)\n')             # Loop over each element in 'full_p' (assuming it's a list or NumPy array)         for nn in range(len(half_p)):             # Extract pressure level value for the current iteration            pressure_hPa = half_p[nn]            fid.write(f'{pressure_hPa:.6f}\n')  # Writing pressure level in hPa format with 6 decimal places                # Write temp        fid.write('! Temperature levels (K)\n')        # Loop over each element in 'full_t' (assuming it's a list or NumPy array)        for temperature in full_t:            fid.write(f'{temperature:.6f}\n')  # Writing temperature level in Kelvin with 6 decimal places           # Write water vapor profiles header        fid.write('! Water vapour profiles (ppmv)\n')        # Loop over each element in 'full_q' (assuming it's a list or NumPy array)        for water_vapor in full_q:            # Convert water vapor level to ppmv and write to file            water_vapor_ppmv = water_vapor            fid.write(f'{water_vapor_ppmv:.6E}\n')  # Writing water vapor level with 6 decimal places        # Write near-surface variables header        fid.write('! Near-surface variables:\n')        # Write near-surface variable descriptions (no longer readl 2mp as == lowest half pressure level)        fid.write('! 2m T (K)    2m q (ppmv)   10m wind u (m/s)      10m wind v (m/s)\n')                # Write near-surface variables data        fid.write(f'{full_t[-1]:.6f}   {full_q[-1]:.6E}   0.00   0.00\n')                # Write skin variables header         fid.write('! Skin variables:\n')        fid.write('! Skin T (K)  FASTEM parameters for land surfaces\n')        # Write skin variables data         fid.write(f'{t_sfc:.2f}  3.00  5.00  15.00  0.10  0.30\n')        # Land Flag        fid.write('! LandFlag: surfacetype_land (0) and surfacetype_sea (1) \n')        fid.write(f'{LandFlag}\n')                  # Write elevation, latitude, and longitude header        fid.write('! Elevation (km) \n')        fid.write(f'{rte_pos:.3f}\n')        # Write latitude        fid.write('! Latitude (degrees)\n')        fid.write(f'{latitude:.4f}\n')        # Write longitude         fid.write('! Longitude (degrees)\n')        fid.write(f'{longitude:.4f}\n')                # Write zenith and azimuth angles header        fid.write('! Sat. zenith (degrees)\n') # and azimuth angles, solar zenith and azimuth angles (degrees)\n')        fid.write(f'{zenith:.2f}\n')                # Write end of profile marker        fid.write('!\n')        fid.write('! --- End of profile ---\n')                   # Close the file        fid.close()    return #------------------------------------------------------------------------------# This is the main rttov 14 version set-up. Where all profiles are written into one file def run_IFS_rttov14(ipnd, mp_version, HHtime, sensor_config, Flagged_Profs, server, half_p_levels):        if 'yakaira' in server:         paths_rttov  = '/home/vito.galligani/Work/RTTOV/rttov14.0_beta'        upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        general_path = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/'        prov         = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        paths_rttov  = '/home/galliganiv/Work/rttov14'        upfolder    = '/home/galliganiv/'               general_path = '/home/galliganiv/Work/HAILCASE_10112018/RTTOVinout/InputAll/'        prov         = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')        mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    sys.path.append(paths_rttov+'/wrapper')         # WRFOUT     if mp_version == 6:        mp_physics = 'WRF-WSM6'        ncfolder   = upfolder+'WRFOUT/WSM6_domain3_NoahMP/'        ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'    elif mp_version == 6.1:        mp_physics = 'WRFWSM6_YSU12hr'        ncfolder  = upfolder+'WRFOUT_1domain/WSM6_1domaintest_12hrs_YSU/'            ncfile    = ncfolder+'wrfout_d01_2018-11-10_'+HHtime+':00'          ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'    flag_name = 'rttov14_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime        # rttov main output path     paths_outfolder  = general_path+mp_physics    # Creates main output folder         if not os.path.exists(paths_outfolder):        os.makedirs(paths_outfolder)             # Load all profiles    A = read_wrf(ncfile)        print('-------------------------------------------------------------------')        # Configure the instrument?     if 'AMSR2' in sensor_config:         # TRY HARD CODED 1C-AMSR2-GCOMW1 1739        # Conical: 55° zenith angle; swath: 1450 km         # Note 20-02-2025: Get it from the observations files I'm comparing it with!!!         satzen = 55.   # satellite zenith angle        satazi = 180.  # satellite azimuth angle               elif 'MHS' in sensor_config:         # Note 20-02-2025: Get it from the observations files I'm comparing it with!!!         print('ZENITH ANGLE VARIES DEFINE!')        mhs_noaa19_file = mhs_noaa19_dir+'1C.NOAA19.MHS.XCAL2021-V.20181110-S201428-E215628.050287.V07A.HDF5'        ds = gpm.open_granule(mhs_noaa19_file)                lat_OBS       = ds['lat'].data        lon_OBS       = ds['lon'].data                # ncidenceAngle ==  the angle of the satellite from the local zenith as seen at the pixel        # location on the earth. Values range from 0 to 90 degrees. === satzen!!! dont't need to convert!         incidence_OBS = ds['incidenceAngle'].data[:,:,0]                # Interpolate the incidence angle to the lat/lon grid of WRF        #----------------------------------------------------------------------        lon_wrf = (A['XLONG']).ravel()             lat_wrf = (A['XLAT']).ravel()                 # Flatten the input coordinate grids and data        lon_OBS_flat = lon_OBS.ravel()  # Shape (90*2296,)        lat_OBS_flat = lat_OBS.ravel()  # Shape (90*2296,)        incidence_OBS_flat = incidence_OBS.ravel()  # Ensure it matches the number of points                incidence_interp_flat = griddata((lon_OBS_flat, lat_OBS_flat), incidence_OBS_flat ,                                          (lon_wrf, lat_wrf), method='nearest')                # Reshape back to WRF grid shape        incidence_interp = incidence_interp_flat.reshape(A['XLAT'].shape)                do_this_plot = 0         if do_this_plot == 1:                                     fig = plt.figure(figsize=[8,8])            plt.pcolormesh(lon_OBS, lat_OBS, incidence_OBS[:,:,0], vmin=-45, vmax=0); plt.colorbar();             plt.plot(prov[:,0],prov[:,1],color='k'); plt.xlim([-70,-60]); plt.ylim([-38,-29])            plt.title('MHS OBS. incidence angle')            fig = plt.figure(figsize=[8,8])            plt.pcolormesh(A['XLONG'], A['XLAT'], incidence_interp, vmin=-45, vmax=0); plt.colorbar();             plt.plot(prov[:,0],prov[:,1],color='k'); plt.xlim([-70,-60]); plt.ylim([-38,-29])            plt.title('WRF interpolated MHS incidence angle')                # Filenames following flag    flag2name = flag_name+'_'+'satzen_OBSinterp'    # Experimento with surface_emissivity = 1     surface_emissivity = 1    print('Experiment with surface_emissivity == ' + str(surface_emissivity))        # Construct filename string All-sky    filename = f"atm_{flag2name}.dat"    filename_hydro = f"atm_{flag2name}_hydro.dat"    print('filename: '+filename)    print('filename: '+filename_hydro)        # Construct full file path    file_path_hydro = os.path.join(general_path, f"{mp_physics}/{filename_hydro}")    file_path_atm = os.path.join(general_path, f"{mp_physics}/{filename}")    print('full path of AllSky file: '+ file_path_hydro)        ##skips = [2325, 8947, 10251, 10247] #, 2325, 2761, 2796, 3647] #13/03/2025: skip 10247?     ##for iprofflag in skips:        ##    Flagged_Profs.append(iprofflag)    unique_values, counts = np.unique(Flagged_Profs,return_counts=True)            ProfileNrs    = (A['XLONG'].shape[0] * A['XLONG'].shape[1])-len(unique_values)    #ProfileNrs    = (A['XLONG'].shape[0] * A['XLONG'].shape[1])-len(Flagged_Profs)    # else:    # ProfileNrs    = 5 * 5                #half_p_levels = 45      # p_full + 1     with open(file_path_atm, 'a') as fid:                fid.write('! Number of profiles\n')        fid.write(f'{ProfileNrs}\n')        # Write size of profile        fid.write('! Size of profile\n')        fid.write(f'{half_p_levels}\n')                # Close the file        fid.close()    toti = A['XLONG'].shape[0]    totj = A['XLONG'].shape[1]        print('Total number of profiles: '+ str( (A['XLONG'].shape[0]) * (A['XLONG'].shape[1]) ))        counter = 0    for i in range(A['XLONG'].shape[0]):         for j in range(A['XLONG'].shape[1]):             counter = counter+1            # i need to make sure that i skip the following profiles:            if counter in Flagged_Profs:                print('Skipping this profile '+str(counter))                continue # Skip this iteration                            else:                                Ai     = SelectProf(A,i,j)                satzen = np.abs( incidence_interp[i,j])                # In case there is ice hydrometeor above 290 K, set the content to zero from 285 to 280                Ai['swc'][Ai['T']>280]=0                 Ai['iwc'][Ai['T']>280]=0                 Ai['gwc'][Ai['T']>280]=0                    rttov14_prof_realistic(Ai, surface_emissivity, file_path_atm, file_path_hydro, counter, i, j, satzen)                        #fas.write(f'{prof_filename} {ipnd:.2f}\n')                    #print('Loop i:'+str(i)+'/'+str(toti)+ ' done and j:'+str(j)+'/'+str(totj)+' done')            print('-----------------------------------------------------------')    return A, Flagged_Profs#------------------------------------------------------------------------------# Here I create new profiles to run rttov 14. I plan to run a few experiments where graupel is soft sphere, but I divide# the snow iwc in three different hydromeoteors. This is a very basic 1st test. In the future I should:# 1) test dividing in two different habits. # 2) this division think about it in terms of location in the z axis. def run_IFS_rttov14_version2(ipnd, mp_version, HHtime, sensor_config, Flagged_Profs, server, half_p_levels):        if 'yakaira' in server:         paths_rttov  = '/home/vito.galligani/Work/RTTOV/rttov14.0_beta'        upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        general_path = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/'        prov         = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        paths_rttov  = '/home/galliganiv/Work/rttov14'        upfolder    = '/home/galliganiv/'               general_path = '/home/galliganiv/Work/HAILCASE_10112018/RTTOVinout/InputAll/'        prov         = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')        mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    sys.path.append(paths_rttov+'/wrapper')         # WRFOUT     if mp_version == 6:        mp_physics = 'WRF-WSM6'        ncfolder   = upfolder+'WRFOUT/WSM6_domain3_NoahMP/'        ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'    elif mp_version == 6.1:        mp_physics = 'WRFWSM6_YSU12hr'        ncfolder  = upfolder+'WRFOUT_1domain/WSM6_1domaintest_12hrs_YSU/'            ncfile    = ncfolder+'wrfout_d01_2018-11-10_'+HHtime+':00'                  #flag_name = 'rttov14_1snowprofile_5nhydro_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime    #flag_name = 'rttov14_2snowprofile_cirssg_6nhydro_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime    #flag_name = 'rttov14_2snowprofile_cirsgs_6nhydro_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime    #flag_name = 'rttov14_2grauprofile_cirsgg_6nhydro_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime    flag_name = 'rttov14_2snowprofile_temp2_cirsgs_6nhydro_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime    #flag_name = 'rttov14_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime        # rttov main output path     paths_outfolder  = general_path+mp_physics    # Creates main output folder         if not os.path.exists(paths_outfolder):        os.makedirs(paths_outfolder)             # Load all profiles    A = read_wrf(ncfile)        print('-------------------------------------------------------------------')        # Configure the instrument?     if 'AMSR2' in sensor_config:         # TRY HARD CODED 1C-AMSR2-GCOMW1 1739        # Conical: 55° zenith angle; swath: 1450 km         # Note 20-02-2025: Get it from the observations files I'm comparing it with!!!         satzen = 55.   # satellite zenith angle        satazi = 180.  # satellite azimuth angle               elif 'MHS' in sensor_config:         # Note 20-02-2025: Get it from the observations files I'm comparing it with!!!         print('ZENITH ANGLE VARIES DEFINE!')        mhs_noaa19_file = mhs_noaa19_dir+'1C.NOAA19.MHS.XCAL2021-V.20181110-S201428-E215628.050287.V07A.HDF5'        ds = gpm.open_granule(mhs_noaa19_file)                lat_OBS       = ds['lat'].data        lon_OBS       = ds['lon'].data                # ncidenceAngle ==  the angle of the satellite from the local zenith as seen at the pixel        # location on the earth. Values range from 0 to 90 degrees. === satzen!!! dont't need to convert!         incidence_OBS = ds['incidenceAngle'].data[:,:,0]                # Interpolate the incidence angle to the lat/lon grid of WRF        #----------------------------------------------------------------------        lon_wrf = (A['XLONG']).ravel()             lat_wrf = (A['XLAT']).ravel()                 # Flatten the input coordinate grids and data        lon_OBS_flat = lon_OBS.ravel()  # Shape (90*2296,)        lat_OBS_flat = lat_OBS.ravel()  # Shape (90*2296,)        incidence_OBS_flat = incidence_OBS.ravel()  # Ensure it matches the number of points                incidence_interp_flat = griddata((lon_OBS_flat, lat_OBS_flat), incidence_OBS_flat ,                                          (lon_wrf, lat_wrf), method='nearest')                # Reshape back to WRF grid shape        incidence_interp = incidence_interp_flat.reshape(A['XLAT'].shape)                do_this_plot = 0         if do_this_plot == 1:                                     fig = plt.figure(figsize=[8,8])            plt.pcolormesh(lon_OBS, lat_OBS, incidence_OBS[:,:,0], vmin=-45, vmax=0); plt.colorbar();             plt.plot(prov[:,0],prov[:,1],color='k'); plt.xlim([-70,-60]); plt.ylim([-38,-29])            plt.title('MHS OBS. incidence angle')            fig = plt.figure(figsize=[8,8])            plt.pcolormesh(A['XLONG'], A['XLAT'], incidence_interp, vmin=-45, vmax=0); plt.colorbar();             plt.plot(prov[:,0],prov[:,1],color='k'); plt.xlim([-70,-60]); plt.ylim([-38,-29])            plt.title('WRF interpolated MHS incidence angle')                # Filenames following flag    flag2name = flag_name+'_'+'satzen_OBSinterp'    # Experimento with surface_emissivity = 1     surface_emissivity = 1    print('Experiment with surface_emissivity == ' + str(surface_emissivity))        # Construct filename string All-sky    filename = f"atm_{flag2name}.dat"    filename_hydro = f"atm_{flag2name}_hydro.dat"    print('filename: '+filename)    print('filename: '+filename_hydro)        # Construct full file path    file_path_hydro = os.path.join(general_path, f"{mp_physics}/{filename_hydro}")    file_path_atm = os.path.join(general_path, f"{mp_physics}/{filename}")    print('full path of AllSky file: '+ file_path_hydro)    ##skips = [2325, 8947, 10251, 10247] #, 2325, 2761, 2796, 3647] #13/03/2025: skip 10247?     ##for iprofflag in skips:        ##    Flagged_Profs.append(iprofflag)    unique_values, counts = np.unique(Flagged_Profs,return_counts=True)        #ProfileNrs    = (A['XLONG'].shape[0] * A['XLONG'].shape[1])-len(unique_values)    #ProfileNrs    = (A['XLONG'][:700,100:].shape[0] * A['XLONG'][:700,100:].shape[1])-len(unique_values)    #ProfileNrs    = (A['XLONG'][100:600,100:800].shape[0] * A['XLONG'][100:600,100:800].shape[1])-len(unique_values)    ProfileNrs    = (A['XLONG'][390:550,100:410].shape[0] * A['XLONG'][390:550,100:410].shape[1])-len(unique_values)          #half_p_levels = 45      # p_full + 1     with open(file_path_atm, 'a') as fid:                fid.write('! Number of profiles\n')        fid.write(f'{ProfileNrs}\n')        # Write size of profile        fid.write('! Size of profile\n')        fid.write(f'{half_p_levels}\n')                # Close the file        fid.close()    toti = A['XLONG'].shape[0]    totj = A['XLONG'].shape[1]        counter = 0    # for i in range(A['XLONG'].shape[0]):     #     for j in range(A['XLONG'].shape[1]):     for i in range(390,550):         for j in range(100,410):                             counter = counter+1            # i need to make sure that i skip the following profiles:            if counter in Flagged_Profs:                print('Skipping this profile '+str(counter))                continue # Skip this iteration                            else:                                Ai     = SelectProf(A,i,j)                satzen = np.abs( incidence_interp[i,j])                # In case there is ice hydrometeor above 290 K, set the content to zero from 285 to 280                Ai['swc'][Ai['T']>280]=0                 Ai['iwc'][Ai['T']>280]=0                 Ai['gwc'][Ai['T']>280]=0                    rttov14_prof_realistic(Ai, surface_emissivity, file_path_atm, file_path_hydro, counter, i, j, satzen)                        #fas.write(f'{prof_filename} {ipnd:.2f}\n')                    #print('Loop i:'+str(i)+'/'+str(toti)+ ' done and j:'+str(j)+'/'+str(totj)+' done')            print('-----------------------------------------------------------')    return A, Flagged_Profs#------------------------------------------------------------------------------def filter_pixels(mp_version, HHtime, server):          if 'yakaira' in server:         paths_rttov = '/home/vito.galligani/Work/RTTOV/rttov14.0_beta'        upfolder    = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        if mp_version == 6:            mp_physics = 'WRF-WSM6'            ncfolder   = upfolder+'WRFout_WSM6_v4.5.2/'                elif 'cnrm' in server:        paths_rttov = '/home/galliganiv/Work/rttov14'        upfolder    = '/home/galliganiv/'        if mp_version == 6:            mp_physics = 'WRF-WSM6'            ncfolder   = upfolder+'WRFOUT/WSM6_domain3_NoahMP/'        sys.path.append(paths_rttov+'/wrapper')         # WRF     ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'           # Load all profiles    A = read_wrf(ncfile)    # Ignore values that have negative vales    skipProfs = []         counter = 0    # for i in range(A['XLONG'].shape[0]):     #     for j in range(A['XLONG'].shape[1]):     for i in range(390,550):         for j in range(100,410):                 counter=counter+1            if np.any( A['h20'].data[:,i,j] < 0):                print(f'negative values in counter ({counter}), i({i}), j({j})')                skipProfs.append(counter)                    return skipProfs#------------------------------------------------------------------------------def find_pixels(pres, mp_version, HHtime, server):            if 'yakaira' in server:         paths_rttov = '/home/vito.galligani/Work/RTTOV/rttov14.0_beta'        upfolder    = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        if mp_version == 6:            mp_physics = 'WRF-WSM6'            ncfolder   = upfolder+'WRFout_WSM6_v4.5.2/'                elif 'cnrm' in server:        paths_rttov = '/home/galliganiv/Work/rttov14'        upfolder    = '/home/galliganiv/'        if mp_version == 6:            mp_physics = 'WRF-WSM6'            ncfolder   = upfolder+'WRFOUT/WSM6_domain3_NoahMP/'        sys.path.append(paths_rttov+'/wrapper')         # WRF     ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'            # Load all profiles    A = read_wrf(ncfile)    # Ignore values that have negative vales    skipProfs = []         counter = 0    for i in range(A['XLONG'].shape[0]):         for j in range(A['XLONG'].shape[1]):             counter=counter+1            if np.any( A['halfpressure'].data[:,i,j] == pres):                print(f'negative values in counter ({counter}), i({i}), j({j})')                skipProfs.append(counter)                    return skipProfs#------------------------------------------------------------------------------def filter_pixels_monotonic(mp_version, HHtime, server):        # Note that counter + 1 notation to follow up errors in fortran! CAREFUL in the future        if 'yakaira' in server:         paths_rttov = '/home/vito.galligani/Work/RTTOV/rttov14.0_beta'        upfolder    = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        if mp_version == 6:            mp_physics = 'WRF-WSM6'            ncfolder   = upfolder+'WRFOUT/WSM6_domain3_NoahMP/'                    ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'          elif mp_version == 6.1:            mp_physics = 'WRFWSM6_YSU12hr'            ncfolder  = upfolder+'WRFOUT_1domain/WSM6_1domaintest_12hrs_YSU/'                ncfile    = ncfolder+'wrfout_d01_2018-11-10_'+HHtime+':00'                  elif 'cnrm' in server:        paths_rttov = '/home/galliganiv/Work/rttov14'        upfolder    = '/home/galliganiv/'        if mp_version == 6:            mp_physics = 'WRF-WSM6'            ncfolder   = upfolder+'WRFOUT/WSM6_domain3_NoahMP/'                ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'      sys.path.append(paths_rttov+'/wrapper')         # Load all profiles    A = read_wrf(ncfile)        # Ignore values that have negative vales    skipProfs = []         nlev          = A['pressure'].shape[0] + 1            counter = 0    # for i in range(A['XLONG'].shape[0]):     #     for j in range(A['XLONG'].shape[1]):     for i in range(390,550):         for j in range(100,410):                      counter=counter+1            # Check monotonicity in WRF total pressure            for k in range(nlev-1, 0, -1):        # From bottom to top (kte to kts+1 in reverse)                if A['halfpressure'][k,i,j] >= A['halfpressure'][k-1,i,j]:                    #message = f"Should skip the pixel at counter ({counter}) loc ({i}), ({j}) where the pressure is not monotonic"                    #print(message)                    skipProfs.append(counter)                                            # y also min water vapour value:    counter = 0    # for i in range(A['XLONG'].shape[0]):     #     for j in range(A['XLONG'].shape[1]):     for i in range(390,550):         for j in range(100,410):                 counter=counter+1            # Check for invalid min water vapour             for k in range(0, nlev-1, 1):                      if A['h20'][k,i,j] <=  0.1000E-10:                    #message = f"Should skip the pixel at counter ({counter}) loc ({i}), ({j}) where the min q invalid"                    #print(message)                    skipProfs.append(counter)                                    return skipProfs#------------------------------------------------------------------------------# footprint operator def to_radians(lat,lon):    return np.radians(np.column_stack(( lat.ravel(),lon.ravel() )))    #------------------------------------------------------------------------------# footprint operator using Haversine Distance? def mhs_simplefootprint(MHSlon, MHSlat, WRFlon, WRFlat):        from math import pi     from sklearn.neighbors import BallTree    # Follow only circles in nadir:    radius = 16E3     carea  = pi*(radius**2)        # convert to radians    mhs_radians = to_radians(MHSlat, MHSlon)    WRF_radians = to_radians(WRFlat, WRFlon)        # Create BallTree     earthR = 6371    tree = BallTree(WRF_radians, metric='haversine')        # Query with 16km radius (convert to degrees)    radius  = 16/earthR    indices, distances = tree.query_radius(mhs_radians, r=radius, return_distance=True) # indices of matching points?     return indices, distances*6371#------------------------------------------------------------------------------#------------------------------------------------------------------------------# Single Profile for rttov analysis of bulk propertiesdef run_IFS_rttov14_singleProf(ipnd, mp_version, HHtime, sensor_config, server, i, j):        if 'yakaira' in server:         paths_rttov  = '/home/vito.galligani/Work/RTTOV/rttov14.0_beta'        upfolder     = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/'        general_path = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/RTTOVout/'        prov         = np.genfromtxt("/home/vito.galligani/Work/Tools/Maps/provincias.txt", delimiter='')        mhs_noaa19_dir  = '/home/vito.galligani/datosmunin3/Work/HAILCASE_10112018_datos/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    elif 'cnrm' in server:        paths_rttov  = '/home/galliganiv/Work/rttov14'        upfolder    = '/home/galliganiv/'               general_path = '/home/galliganiv/Work/HAILCASE_10112018/RTTOVinout/Input1Prof/'        prov         = np.genfromtxt("/home/galliganiv/ACMS_hail/src/provincias.txt", delimiter='')        mhs_noaa19_dir  = '/home/galliganiv/Work/HAILCASE_10112018/PMW/GPM/RS/V07/PMW/1C-MHS-NOAA19/2018/11/10/'    sys.path.append(paths_rttov+'/wrapper')         # WRFOUT     if mp_version == 6:        mp_physics = 'WRF-WSM6'        ncfolder   = upfolder+'WRFOUT/WSM6_domain3_NoahMP/'        ncfile    = ncfolder+'wrfout_d02_2018-11-10_'+HHtime+':00'    flag_name = 'rttov14_'+sensor_config+'_'+mp_physics+'_2018-11-10_'+HHtime        # rttov main output path     paths_outfolder  = general_path+mp_physics    # Creates main output folder         if not os.path.exists(paths_outfolder):        os.makedirs(paths_outfolder)             # Load all profiles    A = read_wrf(ncfile)        print('-------------------------------------------------------------------')        # Configure the instrument?     if 'AMSR2' in sensor_config:         # TRY HARD CODED 1C-AMSR2-GCOMW1 1739        # Conical: 55° zenith angle; swath: 1450 km         # Note 20-02-2025: Get it from the observations files I'm comparing it with!!!         satzen = 55.   # satellite zenith angle        satazi = 180.  # satellite azimuth angle               elif 'MHS' in sensor_config:         # Note 20-02-2025: Get it from the observations files I'm comparing it with!!!         print('ZENITH ANGLE VARIES DEFINE!')        mhs_noaa19_file = mhs_noaa19_dir+'1C.NOAA19.MHS.XCAL2021-V.20181110-S201428-E215628.050287.V07A.HDF5'        ds = gpm.open_granule(mhs_noaa19_file)                lat_OBS       = ds['lat'].data        lon_OBS       = ds['lon'].data                # ncidenceAngle ==  the angle of the satellite from the local zenith as seen at the pixel        # location on the earth. Values range from 0 to 90 degrees. === satzen!!! dont't need to convert!         incidence_OBS = ds['incidenceAngle'].data[:,:,0]                # Interpolate the incidence angle to the lat/lon grid of WRF        #----------------------------------------------------------------------        lon_wrf = (A['XLONG']).ravel()             lat_wrf = (A['XLAT']).ravel()                 # Flatten the input coordinate grids and data        lon_OBS_flat = lon_OBS.ravel()  # Shape (90*2296,)        lat_OBS_flat = lat_OBS.ravel()  # Shape (90*2296,)        incidence_OBS_flat = incidence_OBS.ravel()  # Ensure it matches the number of points                incidence_interp_flat = griddata((lon_OBS_flat, lat_OBS_flat), incidence_OBS_flat ,                                          (lon_wrf, lat_wrf), method='nearest')                # Reshape back to WRF grid shape        incidence_interp = incidence_interp_flat.reshape(A['XLAT'].shape)                        # Filenames following flag    flag2name = flag_name+'_'+'satzen_OBSinterp'+'_i'+str(i)+'_j'+str(j)    # Experimento with surface_emissivity = 1     surface_emissivity = 1    print('Experiment with surface_emissivity == ' + str(surface_emissivity))        # Construct filename string All-sky    filename = f"atm_{flag2name}.dat"    filename_hydro = f"atm_{flag2name}_hydro.dat"    print('filename: '+filename)    print('filename: '+filename_hydro)        # Construct full file path    file_path_hydro = os.path.join(general_path, f"{mp_physics}/{filename_hydro}")    file_path_atm = os.path.join(general_path, f"{mp_physics}/{filename}")    print('full path of AllSky file: '+ file_path_hydro)        ProfileNrs    = 1    half_p_levels = 45      # p_full + 1     with open(file_path_atm, 'a') as fid:                fid.write('! Number of profiles\n')        fid.write(f'{ProfileNrs}\n')        # Write size of profile        fid.write('! Size of profile\n')        fid.write(f'{half_p_levels}\n')                # Close the file        fid.close()    toti = 1    totj = 1        counter = 0        #### i and j    Ai     = SelectProf(A,i,j)    satzen = np.abs( incidence_interp[i,j])    # In case there is ice hydrometeor above 290 K, set the content to zero from 285 to 280    Ai['swc'][Ai['T']>280]=0     Ai['iwc'][Ai['T']>280]=0     Ai['gwc'][Ai['T']>280]=0        rttov14_prof_realistic(Ai, surface_emissivity, file_path_atm, file_path_hydro, counter, i, j, satzen)            #fas.write(f'{prof_filename} {ipnd:.2f}\n')    #print('Loop i:'+str(i)+'/'+str(toti)+ ' done and j:'+str(j)+'/'+str(totj)+' done')            print('-----------------------------------------------------------')    return